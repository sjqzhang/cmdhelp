-- MySQL dump 10.13  Distrib 5.6.19, for Linux (x86_64)
--
-- Host: 172.16.3.92    Database: cmdhelp
-- ------------------------------------------------------
-- Server version	5.6.19-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `cmdhelp`
--

DROP TABLE IF EXISTS `cmdhelp`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cmdhelp` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `cmd` varchar(255) DEFAULT NULL COMMENT '命令',
  `cmdinfo` text COMMENT '命令详情',
  `description` varchar(1024) DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=78 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cmdhelp`
--

LOCK TABLES `cmdhelp` WRITE;
/*!40000 ALTER TABLE `cmdhelp` DISABLE KEYS */;
INSERT INTO `cmdhelp` VALUES (4,'cobbler','cobbler system add --name=network --ip=192.168.98.0/8 --profile=centos6.6 --interface eth0',''),(5,'cobbler','cobbler system add --name=network --ip=192.168.98.0/8 --profile=centos6.6 --interface eth0 ','//在可花样百出颉'),(6,'cobbler','cobbler system search cobbler',''),(12,'cobbler','cobbler profile edit --name=centos6.6 --kickstart=/var/lib/cobbler/kickstarts/custom.ks --distro=images-x86_64 --repos=Centos6-UPDATES cloudera epel6-x86_64 epel6-x86_64-testing mesosphere percona --virt-auto-boot=1 --virt-cpus=8 --virt-file-size=200 --virt-disk-driver=qcow2 --virt-ram=4096 --virt-type=kvm --virt-bridge=br0 --virt-path=/data/kvm',''),(11,'cobbler','cobbler system add --name=host-188116 --hostname=host-188116 --mac=00:50:56:3C:49:44 --interface=eth0 --ip-address=192.168.98.130 --subnet=255.255.255.0 --gateway=192.168.98.128 --static=1 --profile=centos6.6',''),(20,'ci','\nci 常用函数\r\n   \r\n  $this->table->generate() \r\n  $this->db->get(\'news\') \r\n  $this->agent->accept_charset() \r\n  $this->agent->accept_charset(\'utf-8\') \r\n  $this->agent->accept_lang() \r\n  $this->agent->accept_lang(\'en\') \r\n  $this->agent->agent_string() \r\n  $this->agent->browser() \r\n  $this->agent->is_browser() \r\n  $this->agent->is_browser(\'Safari\') \r\n  $this->agent->is_mobile() \r\n  $this->agent->is_mobile(\'iphone\') \r\n  $this->agent->is_referral() \r\n  $this->agent->is_robot() \r\n  $this->agent->mobile() \r\n  $this->agent->platform() \r\n  $this->agent->referrer() \r\n  $this->agent->robot() \r\n  $this->agent->version() \r\n  $this->benchmark->elapsed_time() \r\n  $this->benchmark->elapsed_time(\'cat\', \'bird\') \r\n  $this->benchmark->elapsed_time(\'dog\', \'bird\') \r\n  $this->benchmark->elapsed_time(\'dog\', \'cat\') \r\n  $this->benchmark->mark(\'another_mark_end\') \r\n  $this->benchmark->mark(\'another_mark_start\') \r\n  $this->benchmark->mark(\'bird\') \r\n  $this->benchmark->mark(\'cat\') \r\n  $this->benchmark->mark(\'dog\') \r\n  $this->benchmark->mark(\'my_mark_end\') \r\n  $this->benchmark->mark(\'my_mark_start\') \r\n  $this->benchmark->memory_usage() \r\n  $this->Blog->get_last_ten_entries() \r\n  $this->cache->apc->get(\'my_cache\') \r\n  $this->cache->apc->is_supported() \r\n  $this->cache->apc->save(\'foo\', \'bar\', 10) \r\n  $this->cache->cache_info() \r\n  $this->cache->clean() \r\n  $this->cache->delete(\'cache_item_id\') \r\n  $this->cache->file->save(\'foo\', \'bar\', 10) \r\n  $this->cache->get() \r\n  $this->cache->get(\'foo\') \r\n  $this->cache->get_metadata(\'my_cached_item\') \r\n  $this->cache->get(\'my_cached_item\') \r\n  $this->cache->memcached->save(\'foo\', \'bar\', 10) \r\n  $this->cache->save(\'cache_item_id\', \'data_to_cache\') \r\n  $this->cache->save(\'foo\', $foo, 300) \r\n  $this->calendar->generate() \r\n  $this->calendar->generate(2006, 6) \r\n  $this->calendar->generate(2006, 6, $data) \r\n  $this->calendar->generate($this->uri->segment(3) \r\n  $this->cart->contents() \r\n  $this->cart->destroy() \r\n  $this->cart->format_number($items[\'price\']) \r\n  $this->cart->format_number($items[\'subtotal\']) \r\n  $this->cart->format_number($this->cart->total() \r\n  $this->cart->has_options($items[\'rowid\']) \r\n  $this->cart->has_options(rowid) \r\n  $this->cart->insert() \r\n  $this->cart->insert($data) \r\n  $this->cart->product_options($items[\'rowid\']) \r\n  $this->cart->product_options(rowid) \r\n  $this->cart->total() \r\n  $this->cart->total_items() \r\n  $this->cart->update() \r\n  $this->cart->update($data) \r\n  $this->CI =&amp; get_instance() \r\n  $this->CI->output->get_output() \r\n  $this->comments() \r\n  $this->config->base_url() \r\n  $this->config[\'blog_settings\'] = $config<br /> \r\n  $this->config->item() \r\n  $this->config->item(\'blog_settings\') \r\n  $this->config->item(\'item name\') \r\n  $this->config->item(\'language\') \r\n  $this->config->load() \r\n  $this->config->load(\'blog_settings\', TRUE) \r\n  $this->config->load(\'filename\') \r\n  $this->config->load 中使用了第二个参数，你可以通过指定函数 $this->config->item() \r\n  $this->config->set_item(\'item_name\', \'item_value\') \r\n  $this->config->site_url() \r\n  $this->config->system_url() \r\n  $this->conn_id was a resource instead of an object.  \r\n  $this->content = $_POST[\'content\'];<br /> \r\n  $this->date = time() \r\n  $this->db->affected_rows() \r\n  $this->db->cache_delete() \r\n  $this->db->cache_delete_all() \r\n  $this->db->cache_delete(\'/blog\', \'comments\') \r\n  $this->db->cache_delete(\'blog\', \'comments\') \r\n  $this->db->cache_off() \r\n  $this->db->cache_on() \r\n  $this->db->call_function() \r\n  $this->db->call_function(\'get_client_info\') \r\n  $this->db->call_function(\'some_function\', $param1, $param2, etc..) \r\n  $this->db->close() \r\n  $this->db->count_all() \r\n  $this->db->count_all(\'my_table\') \r\n  $this->db->count_all_results() \r\n  $this->db->count_all_results(\'my_table\') \r\n  $this->db->dbprefix() \r\n  $this->db->dbprefix(\'tablename\') \r\n  $this->db->delete() \r\n  $this->db->delete(\'mytable\') \r\n  $this->db->delete(\'mytable\', array(\'id\' => $id) \r\n  $this->db->delete($tables) \r\n  $this->db->distinct() \r\n  $this->db->empty_table() \r\n  $this->db->empty_table(\'mytable\') \r\n  $this->db->escape() \r\n  $this->db->escape_like_str() \r\n  $this->db->escape_like_str($search) \r\n  $this->db->escape($name) \r\n  $this->db->escape_str() \r\n  $this->db->escape_str($title) \r\n  $this->db->escape($title) \r\n  $this->db->field_data() \r\n  $this->db->field_data(\'table_name\') \r\n  $this->db->field_exists() \r\n  $this->db->field_exists(\'field_name\', \'table_name\') \r\n  $this->db->field_names() \r\n  $this->db->fields() \r\n  $this->db->flush_cache() \r\n  $this->dbforge->add_column() \r\n  $this->dbforge->add_column(\'table_name\', $fields) \r\n  $this->dbforge->add_field() \r\n  $this->dbforge->add_field(array( \r\n  $this->dbforge->add_field($fields) \r\n  $this->dbforge->add_field(\'id\') \r\n  $this->dbforge->add_field(&quot;label varchar(100) \r\n  $this->dbforge->add_key(array(\'blog_name\', \'blog_label\') \r\n  $this->dbforge->add_key(\'blog_id\', TRUE) \r\n  $this->dbforge->add_key(\'blog_name\') \r\n  $this->dbforge->add_key(\'field\') \r\n  $this->dbforge->add_key(\'site_id\', TRUE) \r\n  $this->dbforge->create_database(\'db_name\') \r\n  $this->dbforge->create_database(\'my_db\') \r\n  $this->dbforge->create_table(\'blog\') \r\n  $this->dbforge->create_table(\'table_name\') \r\n  $this->dbforge->create_table(\'table_name\', TRUE) \r\n  $this->dbforge->drop_column() \r\n  $this->dbforge->drop_column(\'table_name\', \'column_to_drop\') \r\n  $this->dbforge->drop_database(\'db_name\') \r\n  $this->dbforge->drop_database(\'my_db\') \r\n  $this->dbforge->drop_table(\'blog\') \r\n  $this->dbforge->drop_table(\'table_name\') \r\n  $this-> dbforge -> modify_column() \r\n  $this->dbforge->modify_column() \r\n  $this->dbforge->modify_column(\'table_name\', $fields) \r\n  $this->dbforge->rename_table(\'old_table_name\', \'new_table_name\') \r\n  $this->db->from() \r\n  $this->db->from(\'blogs\') \r\n  $this->db->from(\'my_table\') \r\n  $this->db->from(\'mytable\') \r\n  $this->db->get() \r\n  $this->db->get(\'entries\', 10) \r\n  $this->db->get(\'members\') \r\n  $this->db->get(\'mytable\') \r\n  $this->db->get(\'mytable\', 10, 20) \r\n  $this->db->get(\'table\') \r\n  $this->db->get(\'table_name\') \r\n  $this->db->get(\'tablename\') \r\n  $this->db->get_where() \r\n  $this->db->get_where(\'mytable\', array(\'id\' => $id) \r\n  $this->db->get_where(\'news\', array(\'slug\' => $slug) \r\n  $this->db->group_by() \r\n  $this->db->group_by(array(\"title\", \"date\") \r\n  $this->db->group_by(\"title\") \r\n  $this->db->having() \r\n  $this->db->having(array(\'title =\' => \'My Title\', \'id &lt;\' => $id) \r\n  $this->db->having(\'user_id = 45\') \r\n  $this->db->having(\'user_id\',  45) \r\n  $this->db->having(\'user_id\',  45, FALSE) \r\n  $this->db->insert() \r\n  $this->db->insert_batch() \r\n  $this->db->insert_batch(\'mytable\', $data) \r\n  $this->db->insert(\'entries\',$this) \r\n  $this->db->insert_id() \r\n  $this->db->insert(\'mytable\') \r\n  $this->db->insert(\'mytable\', $data) \r\n  $this->db->insert(\'mytable\', $object) \r\n  $this->db->insert(\'news\', $data) \r\n  $this->db->insert_string() \r\n  $this->db->insert_string(\'table_name\', $data) \r\n  $this->db->insert_string(\'trackbacks\', $data) \r\n  $this->db->insert_string(&#x27;captcha&#x27;, $data) \r\n  $this->db->join() \r\n  $this->db->join(\'comments\', \'comments.id = blogs.id\') \r\n  $this->db->join(\'comments\', \'comments.id = blogs.id\', \'left\') \r\n  $this->db->last_query() \r\n  $this->db->like() \r\n  $this->db->like($array) \r\n  $this->db->like(\'body\', \'match\') \r\n  $this->db->like(\'title\', \'match\') \r\n  $this->db->like(\'title\', \'match\', \'after\') \r\n  $this->db->like(\'title\', \'match\', \'before\') \r\n  $this->db->like(\'title\', \'match\', \'both\') \r\n  $this->db->like(\'title\', \'match\', \'none\') \r\n  $this->db->limit() \r\n  $this->db->limit(10) \r\n  $this->db->limit(10, 20) \r\n  $this->db->list_fields() \r\n  $this->db->list_fields(\'table_name\') \r\n  $this->db->list_tables() \r\n  $this->db->not_like() \r\n  $this->db->not_like(\'title\', \'match\') \r\n  $this->db->order_by() \r\n  $this->db->order_by(\"name\", \"asc\") \r\n  $this->db->order_by(\"title\", \"desc\") \r\n  $this->db->order_by(\'title desc, name asc\') \r\n  $this->db->or_having() \r\n  $this->db->or_like() \r\n  $this->db->or_like(\'body\', $match) \r\n  $this->db->or_not_like() \r\n  $this->db->or_not_like(\'body\', \'match\') \r\n  $this->db->or_where() \r\n  $this->db->or_where(\'id >\', $id) \r\n  $this->db->or_where_in() \r\n  $this->db->or_where_in(\'username\', $names) \r\n  $this->db->or_where_not_in() \r\n  $this->db->or_where_not_in(\'username\', $names) \r\n  $this->db->platform() \r\n  $this->db->protect_identifiers(\'table_name\') \r\n  $this->db->protect_identifiers(\'table_name\', TRUE) \r\n  $this->db->query() \r\n  $this->db->query(\'AND YET ANOTHER QUERY...\') \r\n  $this->db->query(\'ANOTHER QUERY...\') \r\n  $this->db->query(\'AN SQL QUERY...\') \r\n  $this->db->query($query) \r\n  $this->db->query(&quot;DELETE FROM captcha WHERE captcha_time &lt; &quot;.$expiration) \r\n  $this->db->query(\"SELECT foo, bar, baz, foofoo, foobar AS raboof, foobaz<br />  FROM exp_pre_email_addresses<br />  WHERE foo != \'oof\'<br />  AND baz != \'zab\'<br />  ORDER BY foobaz<br />  LIMIT 5, 100\") \r\n  $this->db->query(\"select foo, bar, baz, foofoo, foobar as raboof, foobaz from exp_pre_email_addresses ...where foo != \'oof\' and baz != \'zab\' order by foobaz limit 5, 100\") \r\n  $this->db->query(\"SELECT * FROM another_table\") \r\n  $this->db->query(\"SELECT * FROM blog\") \r\n  $this->db->query(\"SELECT * FROM members WHERE member_id = \'$current_user\'\") \r\n  $this->db->query(\'SELECT * FROM my_table\') \r\n  $this->db->query(\"SELECT * FROM my_table\") \r\n  $this->db->query(\"SELECT * FROM mytable\") \r\n  $this->db->query(\'SELECT * FROM some_table\') \r\n  $this->db->query(\"SELECT * FROM users;\") \r\n  $this->db->query(\"SELECT * FROM users LIMIT 1;\") \r\n  $this->db->query(\'SELECT name FROM my_table LIMIT 1\') \r\n  $this->db->query(\'SELECT name FROM some_table\') \r\n  $this->db->query(\'SELECT name, title, email FROM my_table\') \r\n  $this->db->query(\'SELECT title FROM my_table\') \r\n  $this->db->query($sql) \r\n  $this->db->query($sql, array(3, \'live\', \'Rick\') \r\n  $this->db->query($sql, $binds) \r\n  $this->db->query(\"YOUR QUERY\") \r\n  $this->db->query(\'YOUR QUERY HERE\') \r\n  $this->db->query(\'一条SQL查询...\') \r\n  $this->db->query(\'另一条查询...\') \r\n  $this->db->query(\"要执行的 SQL\") \r\n  $this->db->query(\'还有一条查询...\') \r\n  $this->db->reconnect() \r\n  $this->db->result() \r\n  $this->db->select(\'*\') \r\n  $this->db->select() \r\n  $this->db->select_avg() \r\n  $this->db->select_avg(\'age\') \r\n  $this->db->select(\'field1\') \r\n  $this->db->select(\'field2\') \r\n  $this->db->select_max() \r\n  $this->db->select_max(\'age\') \r\n  $this->db->select_max(\'age\', \'member_age\') \r\n  $this->db->select_min() \r\n  $this->db->select_min(\'age\') \r\n  $this->db->select(\"(\'SELECT SUM(payments.amount) \r\n  $this->db->select_sum() \r\n  $this->db->select_sum(\'age\') \r\n  $this->db->select(\'title, content, date\') \r\n  $this->db->set() \r\n  $this->db->set($array) \r\n  $this->db->set_dbprefix() \r\n  $this->db->set_dbprefix(\'newprefix\') \r\n  $this->db->set(\'field\', \'field+1\') \r\n  $this->db->set(\'field\', \'field+1\', FALSE) \r\n  $this->db->set(\'name\', $name) \r\n  $this->db->set($object) \r\n  $this->db->set(\'status\', $status) \r\n  $this->db->set(\'title\', $title) \r\n  $this->db->simple_query() \r\n  $this->db->smart_escape_str() \r\n  $this->db->start_cache() \r\n  $this->db->stop_cache() \r\n  $this->db->table_exists() \r\n  $this->db->table_exists(\'table_name\') \r\n  $this->db->trans_begin() \r\n  $this->db->trans_commit() \r\n  $this->db->trans_complete() \r\n  $this->db->trans_off() \r\n  $this->db->trans_rollback() \r\n  $this->db->trans_start() \r\n  $this->db->trans_start(TRUE) \r\n  $this->db->trans_status() \r\n  $this->db->trans_strict(FALSE) \r\n  $this->db->truncate() \r\n  $this->db->truncate(\'mytable\') \r\n  $this->db->update() \r\n  $this->db->update_batch() \r\n  $this->db->update_batch(\'mytable\', $data, \'title\') \r\n  $this->db->update(\'entries\',$this, array(\'id\' => $_POST[\'id\']) \r\n  $this->db->update(\'mytable\', $data) \r\n  $this->db->update(\'mytable\', $data, array(\'id\' => $id) \r\n  $this->db->update(\'mytable\', $data, \"id = 4\") \r\n  $this->db->update(\'mytable\', $object) \r\n  $this->db->update_string() \r\n  $this->db->update_string(\'table_name\', $data, $where) \r\n  $this->db->use_table() \r\n  $this->dbutil->backup() \r\n  $this->dbutil->backup($prefs) \r\n  $this->dbutil->csv_from_result($db_result) \r\n  $this->dbutil->csv_from_result($query) \r\n  $this->dbutil->csv_from_result($query, $delimiter, $newline) \r\n  $this->dbutil->database_exists() \r\n  $this->dbutil->database_exists(\'database_name\') \r\n  $this->dbutil->list_databases() \r\n  $this->dbutil->optimize_database() \r\n  $this->dbutil->optimize_table(\'table_name\') \r\n  $this->dbutil->repair_table(\'table_name\') \r\n  $this->dbutil->xml_from_result($db_result) \r\n  $this->dbutil->xml_from_result($query, $config) \r\n  $this->db->version() \r\n  $this->db->where() \r\n  $this->db->where($array) \r\n  $this->db->where(\'id\', \'5\') \r\n  $this->db->where(\'id <\', $id) \r\n  $this->db->where(\'id\', $id) \r\n  $this->db->where_in() \r\n  $this->db->where_in(\'username\', $names) \r\n  $this->db->where(\'MATCH (field) \r\n  $this->db->where(\'name !=\', $name) \r\n  $this->db->where(\'name\', $name) \r\n  $this->db->where_not_in() \r\n  $this->db->where_not_in(\'username\', $names) \r\n  $this->db->where(\'status\', $status) \r\n  $this->db->where(\'title\', $title) \r\n  $this->db->where($where) \r\n  $this->email->attach() \r\n  $this->email->attach(\'path/photo1.jpg\') \r\n  $this->email->attach(\'path/photo2.jpg\') \r\n  $this->email->attach(\'path/photo3.jpg\') \r\n  $this->email->bcc() \r\n  $this->email->bcc(\'them@their-example.com\') \r\n  $this->email->cc() \r\n  $this->email->cc(\'another@another-example.com\') \r\n  $this->email->clear() \r\n  $this->email->clear(TRUE) \r\n  $this->email->from() \r\n  $this->email->from(\'you@example.com\', \'Your Name\') \r\n  $this->email->from(\'your@example.com\') \r\n  $this->email->from(\'your@example.com\', \'Your Name\') \r\n  $this->email->initialize() \r\n  $this->email->initialize($config) \r\n  $this->email->message() \r\n  $this->email->message(\'Hi \'.$name.\' Here is the info you requested.\') \r\n  $this->email->message(\'Testing the email class.\') \r\n  $this->email->message(\'This is my message\') \r\n  $this->email->print_debugger() \r\n  $this->email->reply_to() \r\n  $this->email->reply_to(\'you@example.com\', \'Your Name\') \r\n  $this->email->send() \r\n  $this->email->set_alt_message() \r\n  $this->email->set_alt_message(\'This is the alternative message\') \r\n  $this->email->some_function() \r\n  $this->email->subject() \r\n  $this->email->subject(\'Email Test\') \r\n  $this->email->subject(\'Here is your info \'.$name) \r\n  $this->email->subject(\'This is my subject\') \r\n  $this->email->to() \r\n  $this->email->to($address) \r\n  $this->email->to($list) \r\n  $this->email->to(\'one@example.com, two@example.com, three@example.com\') \r\n  $this->email->to(\'someone@example.com\') \r\n  $this->encrypt->set_cipher() \r\n  $this->encrypt->set_cipher(MCRYPT_BLOWFISH) \r\n  $this->encrypt->set_mode() \r\n  $this->encrypt->set_mode(MCRYPT_MODE_CFB) \r\n  $this->encrypt->sha1() \r\n  $this->encrypt->sha1(\'Some string\') \r\n  $this->foo($parts) \r\n  $this->form_validation->required($string) \r\n  $this->form_validation->run() \r\n  $this->form_validation->run(\'signup\') \r\n  $this->form_validation->set_error_delimiters(\'&lt;div class=\"error\">\', \'&lt;/div>\') \r\n  $this->form_validation->set_message() \r\n  $this->form_validation->set_message(\'required\', \'Your custom message here\') \r\n  $this->form_validation->set_message(\'rule\', \'Error Message\') \r\n  $this->form_validation->set_message(\'username_check\') \r\n  $this->form_validation->set_message(\'username_check\', \'The %s field can not be the word \"test\"\') \r\n  $this->form_validation->set_rules() \r\n  $this->form_validation->set_rules($config) \r\n  $this->form_validation->set_rules(\'email\', \'Email\', \'required\') \r\n  $this->form_validation->set_rules(\'email\', \'Email\', \'required|is_unique[users.email]\') \r\n  $this->form_validation->set_rules(\'email\', \'Email\', \'required|valid_email|is_unique[users.email]\') \r\n  $this->form_validation->set_rules(\'email\', \'Email\', \'trim|required|valid_email\') \r\n  $this->form_validation->set_rules(\'first_name\', \'lang:first_name\', \'required\') \r\n  $this->form_validation->set_rules(\'options[]\', \'Options\', \'required\') \r\n  $this->form_validation->set_rules(\'passconf\', \'Password Confirmation\', \'required\') \r\n  $this->form_validation->set_rules(\'passconf\', \'Password Confirmation\', \'trim|required\') \r\n  $this->form_validation->set_rules(\'password\', \'Password\', \'required\') \r\n  $this->form_validation->set_rules(\'password\', \'Password\', \'required|matches[passconf]\') \r\n  $this->form_validation->set_rules(\'password\', \'Password\', \'trim|required|matches[passconf]|md5\') \r\n  $this->form_validation->set_rules(\'text\', \'text\', \'required\') \r\n  $this->form_validation->set_rules(\'title\', \'Title\', \'required\') \r\n  $this->form_validation->set_rules(\'username\', \'Username\', \'callback_username_check\') \r\n  $this->form_validation->set_rules(\'username\', \'Username\', \'required\') \r\n  $this->form_validation->set_rules(\'username\', \'Username\', \'required|min_length[5]|max_length[12]|is_unique[users.username]\') \r\n  $this->form_validation->set_rules(\'username\', \'Username\', \'trim|required|min_length[5]|max_length[12]|xss_clean\') \r\n  $this->form_validation.【译者注：所有使用下列函数的表单项都必须有验证规则，规则可以为\'\'，或者为简单的trim函数，不可为NULL】 \r\n  $this->ftp->chmod() \r\n  $this->ftp->chmod(\'/public_html/foo/bar/\', DIR_WRITE_MODE) \r\n  $this->ftp->close() \r\n  $this->ftp->connect() \r\n  $this->ftp->connect($config) \r\n  $this->ftp->delete_dir() \r\n  $this->ftp->delete_dir(\'/public_html/path/to/folder/\') \r\n  $this->ftp->delete_file() \r\n  $this->ftp->download() \r\n  $this->ftp->download(\'/public_html/myfile.html\', \'/local/path/to/myfile.html\', \'ascii\') \r\n  $this->ftp->list_files() \r\n  $this->ftp->list_files(\'/public_html/\') \r\n  $this->ftp->mirror() \r\n  $this->ftp->mirror(\'/path/to/myfolder/\', \'/public_html/myfolder/\') \r\n  $this->ftp->mkdir() \r\n  $this->ftp->mkdir(\'/public_html/foo/bar/\', DIR_WRITE_MODE) \r\n  $this->ftp->move() \r\n  $this->ftp->move(\'/public_html/joe/blog.html\', \'/public_html/fred/blog.html\') \r\n  $this->ftp->rename() \r\n  $this->ftp->rename(\'/public_html/foo/green.html\', \'/public_html/foo/blue.html\') \r\n  $this->ftp->upload() \r\n  $this->ftp->upload(\'/local/path/to/myfile.html\', \'/public_html/myfile.html\', \'ascii\', 0775) \r\n  $this->fubar->function() \r\n  $this->image_lib->clear() \r\n  $this->image_lib->crop() \r\n  $this->image_lib->display_errors() \r\n  $this->image_lib->display_errors(\'&lt;p>\', \'&lt;/p>\') \r\n  $this->image_lib->initialize($config) \r\n  $this->image_lib->resize() \r\n  $this->image_lib->rotate() \r\n  $this->image_lib->watermark() \r\n  $this->input->cookie() \r\n  $this->input->cookie(\'some_data\', TRUE) \r\n  $this->input->get() \r\n  $this->input->get(NULL, TRUE) \r\n  $this->input->get_post() \r\n  $this->input->get_post(\'some_data\', TRUE) \r\n  $this->input->get_request_header() \r\n  $this->input->get_request_header(\'some-header\', TRUE) \r\n  $this->input->get(\'some_data\', TRUE) \r\n  $this->input->ip_address() \r\n  $this->input->is_ajax_request() \r\n  $this->input->is_cli_request() \r\n  $this->input->post() \r\n  $this->input->post(NULL, TRUE) \r\n  $this->input->post(\'some_data\') \r\n  $this->input->post(\'some_data\', TRUE) \r\n  $this->input->post(\'something\') \r\n  $this->input->post(\'text\') \r\n  $this->input->post(\'title\') \r\n  $this->input->request_headers() \r\n  $this->input->server() \r\n  $this->input->server(\'some_data\') \r\n  $this->input->set_cookie() \r\n  $this->input->set_cookie($cookie) \r\n  $this->input->set_cookie($name, $value, $expire, $domain, $path, $prefix, $secure) \r\n  $this->input->user_agent() \r\n  $this->input->valid_ip($ip) \r\n  $this->jquery->animate(target, parameters, optional speed, optional extra information) \r\n  $this->jquery->click(\'#trigger\', $this->jquery->animate(\'#note\', $params, normal) \r\n  $this->jquery->corner(&quot;#note&quot;, &quot;cool tl br&quot;) \r\n  $this->jquery->corner(target, corner_style) \r\n  $this->jquery->effect(\'bounce\') \r\n  $this->jquery->effect([optional path] plugin name) \r\n  $this->jquery->fadeIn(target,  optional speed, optional extra information) \r\n  $this->jquery->fadeOut(target,  optional speed, optional extra information) \r\n  $this->jquery->hide(target,  optional speed, optional extra information) \r\n  $this->jquery->show(target,  optional speed, optional extra information) \r\n  $this->jquery->slideDown(target,  optional speed, optional extra information) \r\n  $this->jquery->slideToggle(target,  optional speed, optional extra information) \r\n  $this->jquery->slideUp(target,  optional speed, optional extra information) \r\n  $this->jquery->toggleClass(target, class) \r\n  $this->jquery->toggle(target) \r\n  $this->lang->line() \r\n  $this->lang->line(\'invalid_selection\') \r\n  $this->lang->line(\'language_key\') \r\n  $this->lang->load() \r\n  $this->lang->load(\'file_name\') \r\n  $this->load->add_package_path() \r\n  $this->load->add_package_path(APPPATH.\'my_app\', FALSE) \r\n  $this->load->add_package_path(APPPATH.\'my_app\', TRUE) \r\n  $this->load->add_package_path(APPPATH.\'third_party/foo_bar/\') \r\n  $this->load->config(\'file_name\') \r\n  $this->load->database() \r\n  $this->load->database($config) \r\n  $this->load->database($dsn) \r\n  $this->load->database(\'group_name\') \r\n  $this->load->database(\'group_one\', TRUE) \r\n  $this->load->database(\'group_two\', TRUE) \r\n  $this->load->database(\'options\', true/false) \r\n  $this->load->dbforge() \r\n  $this->load->dbutil() \r\n  $this->load->driver(\'cache\') \r\n  $this->load->driver(\'cache\', array(\'adapter\' => \'apc\', \'backup\' => \'file\') \r\n  $this->load->driver(\'class name\') \r\n  $this->load->driver(\'some_parent\') \r\n  $this->load->file(\'filepath/filename\', true/false) \r\n  $this->load->get_var() \r\n  $this->load->get_var($key) \r\n  $this->load->helper(\'array\') \r\n  $this->load->helper(array(\'form\', \'url\') \r\n  $this->load->helper( array(\'helper1\', \'helper2\', \'helper3\') \r\n  $this->load->helper(\'captcha\') \r\n  $this->load->helper(\'cookie\') \r\n  $this->load->helper(\'date\') \r\n  $this->load->helper(\'directory\') \r\n  $this->load->helper(\'download\') \r\n  $this->load->helper(\'email\') \r\n  $this->load->helper(\'file\') \r\n  $this->load->helper(\'file_name\') \r\n  $this->load->helper(\'foo\') \r\n  $this->load->helper(\'form\') \r\n  $this->load->helper(\'html\') \r\n  $this->load->helper(\'inflector\') \r\n  $this->load->helper(\'language\') \r\n  $this->load->helper(\'name\') \r\n  $this->load->helper(\'number\') \r\n  $this->load->helper(\'path\') \r\n  $this->load->helper(\'security\') \r\n  $this->load->helper(\'smiley\') \r\n  $this->load->helper(\'string\') \r\n  $this->load->helper(\'text\') \r\n  $this->load->helper(\'typography\') \r\n  $this->load->helper(\'url\') \r\n  $this->load->helper(&#x27;captcha&#x27;) \r\n  $this->load->helper(\'xml\') \r\n  $this->load->language (#3520) \r\n  $this->load->language(\'file_name\') \r\n  $this->load->library() \r\n  $this->load->library(array(\'email\', \'table\') \r\n  $this->load->library(\'calendar\') \r\n  $this->load->library(\'calendar\', $prefs) \r\n  $this->load->library(\'class name\') \r\n  $this->load->library(\'class_name\', $config, \'object name\') \r\n  $this->load->library(\'email\') \r\n  $this->load->library(\'email\', $config) \r\n  $this->load->library(\'flavors/chocolate\') \r\n  $this->load->library(\'foo_bar\') \r\n  $this->load->library(\'form_validation\') \r\n  $this->load->library(\'ftp\') \r\n  $this->load->library function from working in constructors.  \r\n  $this->load->library(\'image_lib\', $config) \r\n  $this->load->library(\'javascript\', array(\'js_library_driver\' => \'scripto\', \'autoload\' => FALSE) \r\n  $this->load->library(\'jquery\', FALSE) \r\n  $this->load->library(\'migration\') \r\n  $this->load->library(\'pagination\') \r\n  $this->load->library(\'parser\') \r\n  $this->load->library(\'someclass\') \r\n  $this->load->library(\'Someclass\', $params) \r\n  $this->load->library(\'table\') \r\n  $this->load->library(\'trackback\') \r\n  $this->load->library(\'typography\') \r\n  $this->load->library(\'upload\', $config) \r\n  $this->load->library(\'user_agent\') \r\n  $this->load->library(\'validation\') \r\n  $this->load->library(\'xmlrpc\') \r\n  $this->load->library(\'xmlrpcs\') \r\n  $this->load->model(\'Blog\') \r\n  $this->load->model(\'blog/queries\') \r\n  $this->load->model(\'Model_name\') \r\n  $this->load->model(\'Model_name\', \'\', $config) \r\n  $this->load->model(\'Model_name\', \'fubar\') \r\n  $this->load->model(\'Model_name\', \'\', TRUE) \r\n  $this->load->model(\'news_model\') \r\n  $this->load->model(\'post_model\') \r\n  $this->load->plugin(\'foo\') \r\n  $this->load->remove_package_path() \r\n  $this->load->remove_package_path(APPPATH.\'my_app\') \r\n  $this->load->remove_package_path(APPPATH.\'third_party/foo_bar/\') \r\n  $this->load->vars() \r\n  $this->load->vars($array) \r\n  $this->load->view() \r\n  $this->load->view(\'blog\', $data) \r\n  $this->load->view(\'blogview\') \r\n  $this->load->view(\'blogview\', $data) \r\n  $this->load->view(\'blogview\', $data, true) \r\n  $this->load->view(\'content\') \r\n  $this->load->view(\'content\', $data) \r\n  $this->load->view(\'file_name\', $data, true/false) \r\n  $this->load->view(\'folder_name/file_name\') \r\n  $this->load->view(\'footer\') \r\n  $this->load->view(\'formsuccess\') \r\n  $this->load->view(\'header\') \r\n  $this->load->view(\'header\',$data) \r\n  $this->load->view(\'iphone/home\') \r\n  $this->load->view(\'menu\') \r\n  $this->load->view(\'mobile/home\') \r\n  $this->load->view(\'my_app_index\') \r\n  $this->load->view(\'myfile\', \'\', true) \r\n  $this->load->view(\'myform\') \r\n  $this->load->view(\'my_view\', $object) \r\n  $this->load->view(\'name\') \r\n  $this->load->view(\'news/create\') \r\n  $this->load->view(\'news/index\', $data) \r\n  $this->load->view(\'news/success\') \r\n  $this->load->view(\'news/view\', $data) \r\n  $this->load->view(\'pages/\'.$page, $data) \r\n  $this->load->view(\'smiley_view\', $data) \r\n  $this->load->view(\'templates/footer\') \r\n  $this->load->view(\'templates/footer\', $data) \r\n  $this->load->view(\'templates/header\', $data) \r\n  $this->load->view(\'upload_form\', array(\'error\' => \' \' ) \r\n  $this->load->view(\'upload_form\', $error) \r\n  $this->load->view(\'upload_success\', $data) \r\n  $this->load->view(\'web/home\') \r\n  $this->load->view(\'welcome_message\') \r\n  $this->load->view。如果有多个调用，那么他们将会被合并到一起。例如，你可能希望有一个标题视图、一个菜单视图、一个内容视图、和一个页脚视图。他们看起来应该是这样： \r\n  $this->$method() \r\n  $this->migrate->current() \r\n  $this->migration->current() \r\n  $this->migration->error_string() \r\n  $this->migration->latest() \r\n  $this->migration->version() \r\n  $this->migration->version(5) \r\n  $this->Model_name->function() \r\n  $this->my_session \r\n  $this->news_model->get_news() \r\n  $this->news_model->get_news($slug) \r\n  $this->news_model->set_news() \r\n  $this->output->append_output() \r\n  $this->output->append_output($data) \r\n  $this->output<br/> \r\n  $this->output->cache() \r\n  $this->output->cache_expiration > 0) \r\n  $this->output->cache(n) \r\n  $this->output->enable_profiler() \r\n  $this->output->enable_profiler(FALSE) \r\n  $this->output->enable_profiler(TRUE) \r\n  $this->output->get_output() \r\n  $this->output->set_content_type() \r\n  $this->output->set_header() \r\n  $this->output->set_header(\"Cache-Control: no-store, no-cache, must-revalidate\") \r\n  $this->output->set_header(\"Cache-Control: post-check=0, pre-check=0\") \r\n  $this->output->set_header(\"HTTP/1.0 200 OK\") \r\n  $this->output->set_header(\"HTTP/1.1 200 OK\") \r\n  $this->output->set_header(\'Last-Modified: \'.gmdate(\'D, d M Y H:i:s\', $last_update) \r\n  $this->output->set_header(\"Pragma: no-cache\") \r\n  $this->output->set_output() \r\n  $this->output->set_output($data) \r\n  $this->output->set_profiler_sections() \r\n  $this->output->set_profiler_sections($sections) \r\n  $this->output->set_status_header(\'401\') \r\n  $this->output->_write_cache($output) \r\n  $this->pagination->create_links() \r\n  $this->pagination->initialize($config) \r\n  $this->parser->parse() \r\n  $this->parser->parse(\'blog_template\', $data) \r\n  $this->parser->parse(\'blog_template\', $data, TRUE) \r\n  $this->parser->parse_string() \r\n  $this->post_model->update(elements(array(\'id\', \'title\', \'content\') \r\n  $this->security->sanitize_filename() \r\n  $this->security->sanitize_filename($this->input->post(\'filename\') \r\n  $this->security->xss_clean() \r\n  $this->security->xss_clean($data) \r\n  $this->security->xss_clean($file, TRUE) \r\n  $this->session->all_userdata() \r\n  $this->session->flashdata(\'item\') \r\n  $this->session->keep_flashdata(\'item\') \r\n  $this->session->sess_destroy() \r\n  $this->session->set_flashdata(\'item\', \'value\') \r\n  $this->session->set_userdata($array) \r\n  $this->session->set_userdata($newdata) \r\n  $this->session->set_userdata(\'some_name\', \'some_value\') \r\n  $this->session->unset_userdata($array_items) \r\n  $this->session->unset_userdata(\'some_name\') \r\n  $this->session->userdata(\'session_id\') \r\n  $this->someclass->some_function() \r\n  $this->some_parent->child_one->some_method() \r\n  $this->some_parent->child_two->another_method() \r\n  $this->some_parent->some_method() \r\n  $this->table->add_row() \r\n  $this->table->add_row(array(\'Blue\', \'Red\', \'Green\') \r\n  $this->table->add_row(array(\'Fred\', \'Blue\', \'Small\') \r\n  $this->table->add_row(array(\'John\', \'Green\', \'Medium\') \r\n  $this->table->add_row(array(\'Mary\', \'Red\', \'Large\') \r\n  $this->table->add_row(\'Blue\', \'Red\', \'Green\') \r\n  $this->table->add_row($cell, \'Red\', \'Green\') \r\n  $this->table->add_row(\'Fred\', \'Blue\', \'Small\') \r\n  $this->table->add_row(\'Fred\', \'&lt;strong>Blue&lt;/strong>\', \'Small\') \r\n  $this->table->add_row(\'Fred\', \'Wednesday\', \'Express\') \r\n  $this->table->add_row(\'John\', \'Green\', \'Medium\') \r\n  $this->table->add_row(\'John\', \'Saturday\', \'Overnight\') \r\n  $this->table->add_row(\'Mary\', \'Monday\', \'Air\') \r\n  $this->table->add_row(\'Mary\', \'Red\', \'Large\') \r\n  $this->table->clear() \r\n  $this->table->function \r\n  $this->table->function = \'htmlspecialchars\';<br /> \r\n  $this->table->generate() \r\n  $this->table->generate($col_array) \r\n  $this->table->generate($data) \r\n  $this->table->generate($new_list) \r\n  $this->table->generate($query) \r\n  $this->table->make_columns() \r\n  $this->table->make_columns($image_array, 8) \r\n  $this->table->make_columns($list, 3) \r\n  $this->table->set_caption() \r\n  $this->table->set_caption(\'Colors\') \r\n  $this->table->set_empty() \r\n  $this->table->set_empty(\"&amp;nbsp;\") \r\n  $this->table->set_heading() \r\n  $this->table->set_heading(array(\'Name\', \'Color\', \'Size\') \r\n  $this->table->set_heading(\'Name\', \'Color\', \'Size\') \r\n  $this->table->set_heading(\'Name\', \'Day\', \'Delivery\') \r\n  $this->table->set_template() \r\n  $this->table->set_template($tmpl) \r\n  $this->title = $_POST[\'title\'];<br /> \r\n  $this->title = $_POST[\'title\']; \n  $this->total_segment() \r\n  $this->total_segments() \r\n  $this->trackback->data(\'blog_name\') \r\n  $this->trackback->data(\'excerpt\') \r\n  $this->trackback->data(\'item\') \r\n  $this->trackback->data(\'title\') \r\n  $this->trackback->data(\'url\') \r\n  $this->trackback->display_errors() \r\n  $this->trackback->receive() \r\n  $this->trackback->send_error(\"The Trackback did not contain valid data\") \r\n  $this->trackback->send_error(\"Unable to determine the entry ID\") \r\n  $this->trackback->send_success() \r\n  $this->trackback->send($tb_data) \r\n  $this->typography->auto_typography($string, FALSE) \r\n  $this->typography->format_characters($string) \r\n  $this->typography->nl2br_except_pre($string) \r\n  $this->typography->protect_braced_quotes = TRUE; \r\n  $this->unit->active(FALSE) \r\n  $this->unit->report() \r\n  $this->unit->result() \r\n  $this->unit->run(1, TRUE) \r\n  $this->unit->run(\'Foo\', \'Foo\') \r\n  $this->unit->run(\'Foo\', \'is_string\') \r\n  $this->unit->run($test, $expected_result) \r\n  $this->unit->run($test, $expected_result, $test_name) \r\n  $this->unit->run( test, expected result, \'test name\', \'notes\') \r\n  $this->unit->set_items() \r\n  $this->unit->set_template($str) \r\n  $this->unit->set_test_items() \r\n  $this->unit->set_test_items(array(\'test_name\', \'result\') \r\n  $this->unit->use_strict(TRUE) \r\n  $this->upload->data() \r\n  $this->upload->display_errors() \r\n  $this->upload->display_errors(\'&lt;p>\', \'&lt;/p>\') \r\n  $this->upload->do_upload() \r\n  $this->upload->do_upload($field_name) \r\n  $this->upload->initialize($config) \r\n  $this->uri->assoc_to_uri() \r\n  $this->uri->assoc_to_uri($array) \r\n  $this->uri->rsegment_array() \r\n  $this->uri->rsegment(n) \r\n  $this->uri->ruri_string() \r\n  $this->uri->ruri_to_assoc(n) \r\n  $this->uri->segment() \r\n  $this->uri->segment(3) \r\n  $this->uri->segment(3, 0) \r\n  $this->uri->segment(4) \r\n  $this->uri->segment_array() \r\n  $this->uri->segment(n) \r\n  $this->uri->slash_rsegment(n) \r\n  $this->uri->slash_segment(3) \r\n  $this->uri->slash_segment(3, \'both\') \r\n  $this->uri->slash_segment(3, \'leading\') \r\n  $this->uri->slash_segment(n) \r\n  $this->uri->total_rsegments() \r\n  $this->uri->total_segments() \r\n  $this->uri->uri_string() \r\n  $this->uri->uri_to_assoc(3) \r\n  $this->uri->uri_to_assoc(3, $default) \r\n  $this->uri->uri_to_assoc(n) \r\n  $this->validation->error_string; ?> \r\n  $this->validation->run() \r\n  $this->validation->set_checkbox(\'mycheck\', \'1\') \r\n  $this->validation->set_error_delimiters(\'&lt;div class=\"error\">\', \'&lt;/div>\') \r\n  $this->validation->set_fields($fields) \r\n  $this->validation->set_message(\'rule\', \'Error Message\') \r\n  $this->validation->set_message(\'username_check\', \'The %s field can not be the word \"test\"\') \r\n  $this->validation->set_radio(\'myradio\', \'1\') \r\n  $this->validation->set_rules($rules) \r\n  $this->validation->set_select(\'myselect\', \'one\') \r\n  $this->validation->set_select(\'myselect\', \'three\') \r\n  $this->validation->set_select(\'myselect\', \'two\') \r\n  $this->xmlrpc->display_error() \r\n  $this->xmlrpc->display_response() \r\n  $this->xmlrpc->method() \r\n  $this->xmlrpc->method(\'Greetings\') \r\n  $this->xmlrpc->method(\'method\') \r\n  $this->xmlrpc->method(\'weblogUpdates.ping\') \r\n  $this->xmlrpc->request() \r\n  $this->xmlrpc->request($request) \r\n  $this->xmlrpc->send_error_message() \r\n  $this->xmlrpc->send_error_message(\'100\',\'InvalidAccess\') \r\n  $this->xmlrpc->send_error_message(\'123\', \'Requested data not available\') \r\n  $this->xmlrpc->send_request() \r\n  $this->xmlrpc->send_response() \r\n  $this->xmlrpc->send_response($response) \r\n  $this->xmlrpc->server() \r\n  $this->xmlrpc->server(\'http://rpc.pingomatic.com/\', 80) \r\n  $this->xmlrpc->server(\'http://www.sometimes.com/pings.php\', 80) \r\n  $this->xmlrpc->server($server_url, 80) \r\n  $this->xmlrpc->set_debug(TRUE) \r\n  $this->xmlrpcs->initialize($config) \r\n  $this->xmlrpcs->serve() \r\n  $this->xmlrpc->timeout() \r\n  $this->xmlrpc->timeout(6) \r\n  $this->zip->add_data() \r\n  $this->zip->add_data($data) \r\n  $this->zip->add_data($name, $data) \r\n  $this->zip->add_dir() \r\n  $this->zip->add_dir(\'myfolder\') \r\n  $this->zip->archive() \r\n  $this->zip->archive(\'/path/to/directory/my_backup.zip\') \r\n  $this->zip->archive(\'/path/to/folder/myarchive.zip\') \r\n  $this->zip->clear_data() \r\n  $this->zip->download() \r\n  $this->zip->download(\'latest_stuff.zip\') \r\n  $this->zip->download(\'my_backup.zip\') \r\n  $this->zip->download(\'myphotos.zip\') \r\n  $this->zip->get_zip() \r\n  $this->zip->read_dir() \r\n  $this->zip->read_dir($path) \r\n  $this->zip->read_dir($path, FALSE) \r\n  $this->zip->read_dir(\'/path/to/directory\', FALSE) \r\n  $this->zip->read_file() \r\n  $this->zip->read_file($path); \r\n  $this->zip->read_file(\"/path/to/photo.jpg\"); // 读取文件内容<br /> \r\n  $this->zip->read_file($path, TRUE);\n','// 请阅读下方的备注<br /> \r'),(16,'nginx','user  nginx;\r\nworker_processes 4;\r\n\r\nerror_log  /var/log/nginx/error.log warn;\r\n#error_log  /var/log/nginx/nginx_error.log debug;\r\n\r\npid        /var/run/nginx.pid;\r\n\r\n#Specifies the value for maximum file descriptors that can be opened by this process. \r\nworker_rlimit_nofile 65535;\r\n\r\nevents \r\n{\r\n  use epoll;\r\n  worker_connections 65535;\r\n}\r\n\r\nhttp \r\n{\r\n  include       /etc/nginx/mime.types;\r\n  default_type  application/octet-stream;\r\n\r\n  log_format  main  \'$remote_addr - $remote_user [$time_local] \"$request\" \'\r\n                      \'$status $body_bytes_sent \"$http_referer\" \'\r\n                      \'\"$http_user_agent\" \"$http_x_forwarded_for\"\';\r\n\r\n  access_log  /var/log/nginx/access.log  main;\r\n  #docs attack\r\n  #limit_zone one  $binary_remote_addr  10m;\r\n  #limit_req_zone  $binary_remote_addr  zone=req_one:10m rate=1r/s;\r\n  #docs attack\r\n\r\n  #charset  gb2312;\r\n  charset  utf-8;\r\n      \r\n  server_names_hash_bucket_size 128;\r\n  client_header_buffer_size 32k;\r\n  large_client_header_buffers 4 32k;\r\n  client_max_body_size 8m;\r\n      \r\n  sendfile on;\r\n  tcp_nopush     on;\r\n\r\n  keepalive_timeout 60;\r\n\r\n  tcp_nodelay on;\r\n\r\n  fastcgi_connect_timeout 400;\r\n  fastcgi_send_timeout 400;\r\n  fastcgi_read_timeout 400;\r\n  fastcgi_buffer_size 128k;\r\n  fastcgi_buffers 2 256k;\r\n  fastcgi_busy_buffers_size 256k;\r\n  fastcgi_temp_file_write_size 256k;\r\n\r\n  gzip on;\r\n  gzip_min_length  1k;\r\n  gzip_buffers     4 16k;\r\n  gzip_http_version 1.0;\r\n  gzip_comp_level 2;\r\n  gzip_types       text/plain application/x-javascript text/css application/xml;\r\n  gzip_vary on;\r\n\r\n  #limit_zone  crawler  $binary_remote_addr  10m;\r\n \r\n   include /etc/nginx/conf.d/*.conf;\r\n  \r\n}\r\n\r\n\r\n',''),(24,'python','\npython 例用简介\r\n1 序言 \r\n      思路:用shell编程.(Linux通常是bash而Windows是批处理脚本).例如,在Windows上用ping ip 的命令依次测试各个机器并得到控制台输出.由于ping通的时候控制台文本通常是\"Reply from ... \" 而不通的时候文本是\"time out ... \" ,所以,在结果中进行字符串查找,即可知道该机器是否连通.  \r\n   \r\n      实现:Java代码如下: \r\n  String cmd=\"cmd.exe ping \"; \r\n  String ipprefix=\"192.168.10.\"; \r\n  int begin=101; \r\n  int end=200; \r\n  Process p=null; \r\n   \r\n  for(int i=begin;i<end;i++){ \r\n       p= Runtime.getRuntime().exec(cmd+i); \r\n       String line = null; \r\n       BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream())); \r\n       while((line = reader.readLine()) != null) \r\n       { \r\n           \n       } \r\n      reader.close(); \r\n      p.destroy(); \r\n  } \r\n   \r\n      这段代码运行得很好,问题是为了运行这段代码,你还需要做一些额外的工作.这些额外的工作包括: \r\n  编写一个类文件 \r\n  编写一个main方法 \r\n  将之编译成字节代码 \r\n  由于字节代码不能直接运行,你需要再写个小小的bat或者bash脚本来运行.  \r\n      当然,用C/C++同样能完成这项工作.但C/C++不是跨平台语言.在这个足够简单的例子中也许看不出C/C++和Java实现的区别,但在一些更为复杂的场景,比如要将连通与否的信息记录到网络数据库.由于Linux和Windows的网络接口实现方式不同,你不得不写两个函数的版本.用Java就没有这样的顾虑.  \r\n   \r\n      同样的工作用Python实现如下: \r\n   \r\n   \r\n  import subprocess \r\n   \r\n  cmd=\"cmd.exe\" \r\n  begin=101 \r\n  end=200 \r\n  while begin<end: \r\n      \r\n      p=subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE, \r\n                     stdin=subprocess.PIPE, \r\n                     stderr=subprocess.PIPE) \r\n      p.stdin.write(\"ping 192.168.1.\"+str(begin)+\"\r\n\") \r\n   \r\n      p.stdin.close() \r\n      p.wait() \r\n      \r\n      print \"execution result: %s\"%p.stdout.read() \r\n   \r\n      对比Java,Python的实现更为简洁,你编写的时间更快.你不需要写main函数,并且这个程序保存之后可以直接运行.另外,和Java一样,Python也是跨平台的.  \r\n   \r\n      有经验的C/Java程序员可能会争论说用C/Java写会比Python写得快.这个观点见仁见智.我的想法是当你同时掌握Java和Python之后,你会发现用Python写这类程序的速度会比Java快上许多.例如操作本地文件时你仅需要一行代码而不需要Java的许多流包装类.各种语言有其天然的适合的应用范围.用Python处理一些简短程序类似与操作系统的交互编程工作最省时省力.  \r\n   \r\n  Python应用场合 \r\n   \r\n      足够简单的任务,例如一些shell编程.如果你喜欢用Python设计大型商业网站或者设计复杂的游戏,悉听尊便.  \r\n   \r\n  2 快速入门 \r\n  2.1 Hello world \r\n   \r\n      安装完Python之后(我本机的版本是2.5.4),打开IDLE(Python GUI) , 该程序是Python语言解释器,你写的语句能够立即运行.我们写下一句著名的程序语句: \r\n   \r\n  print \"Hello,world!\" \r\n   \r\n      并按回车.你就能看到这句被K&R引入到程序世界的名言.  \r\n   \r\n      在解释器中选择\"File\"--\"New Window\" 或快捷键 Ctrl+N , 打开一个新的编辑器.写下如下语句: \r\n  print \"Hello,world!\" \r\n  raw_input(\"Press enter key to close this window\"); \r\n   \r\n      保存为a.py文件.按F5,你就可以看到程序的运行结果了.这是Python的第二种运行方式.  \r\n   \r\n      找到你保存的a.py文件,双击.也可以看到程序结果.Python的程序能够直接运行,对比Java,这是一个优势.  \r\n   \r\n  2.2 国际化支持 \r\n   \r\n      我们换一种方式来问候世界.新建一个编辑器并写如下代码: \r\n  print \"欢迎来到奥运中国!\" \r\n  raw_input(\"Press enter key to close this window\"); \r\n   \r\n      在你保存代码的时候,Python会提示你是否改变文件的字符集,结果如下: \r\n  # -*- coding: cp936 -*- \r\n   \r\n  print \"欢迎来到奥运中国!\" \r\n  raw_input(\"Press enter key to close this window\"); \r\n   \r\n      将该字符集改为我们更熟悉的形式: \r\n  # -*- coding: GBK -*- \r\n   \r\n  print \"欢迎来到奥运中国!\" # 使用中文的例子 \r\n  raw_input(\"Press enter key to close this window\"); \r\n   \r\n      程序一样运行良好.  \r\n  2.3 方便易用的计算器 \r\n   \r\n      用微软附带的计算器来计数实在太麻烦了.打开Python解释器,直接进行计算: \r\n  a=100.0 \r\n  b=201.1 \r\n  c=2343 \r\n  print (a+b+c)/c \r\n   \r\n  2.4 字符串,ASCII和UNICODE \r\n   \r\n   \r\n      可以如下打印出预定义输出格式的字符串: \r\n  print \"\"\" \r\n  Usage: thingy [OPTIONS] \r\n       -h                        Display this usage message \r\n       -H hostname               Hostname to connect to \r\n  \"\"\" \r\n   \r\n      字符串是怎么访问的?请看这个例子: \r\n  word=\"abcdefg\" \r\n  a=word[2] \r\n  print \"a is: \"+a \r\n  b=word[1:3] \r\n  print \"b is: \"+b # index 1 and 2 elements of word.  \r\n  c=word[:2] \r\n  print \"c is: \"+c # index 0 and 1 elements of word.  \r\n  d=word[0:] \r\n  print \"d is: \"+d # All elements of word.  \r\n  e=word[:2]+word[2:] \r\n  print \"e is: \"+e # All elements of word.  \r\n  f=word[-1] \r\n  print \"f is: \"+f # The last elements of word.  \r\n  g=word[-4:-2] \r\n  print \"g is: \"+g # index 3 and 4 elements of word.  \r\n  h=word[-2:] \r\n  print \"h is: \"+h # The last two elements.  \r\n  i=word[:-2] \r\n  print \"i is: \"+i # Everything except the last two characters \r\n  l=len(word) \r\n  print \"Length of word is: \"+ str(l) \r\n   \r\n      请注意ASCII和UNICODE字符串的区别: \r\n  print \"Input your Chinese name:\" \r\n  s=raw_input(\"Press enter to be continued\"); \r\n  print \"Your name is  : \" +s; \r\n  l=len(s) \r\n  print \"Length of your Chinese name in asc codes is:\"+str(l); \r\n  a=unicode(s,\"GBK\") \r\n  l=len(a) \r\n  print \"I\'m sorry we should use unicode char!Characters number of your Chinese \\ \r\n  name in unicode is:\"+str(l); \r\n   \r\n  2.5 使用List \r\n   \r\n      类似Java里的List,这是一种方便易用的数据类型: \r\n   \r\n  word=[\'a\',\'b\',\'c\',\'d\',\'e\',\'f\',\'g\'] \r\n  a=word[2] \r\n  print \"a is: \"+a \r\n  b=word[1:3] \r\n  print \"b is: \" \r\n  print b # index 1 and 2 elements of word.  \r\n  c=word[:2] \r\n  print \"c is: \" \r\n  print c # index 0 and 1 elements of word.  \r\n  d=word[0:] \r\n  print \"d is: \" \r\n  print d # All elements of word.  \r\n  e=word[:2]+word[2:] \r\n  print \"e is: \" \r\n  print e # All elements of word.  \r\n  f=word[-1] \r\n  print \"f is: \" \r\n  print f # The last elements of word.  \r\n  g=word[-4:-2] \r\n  print \"g is: \" \r\n  print g # index 3 and 4 elements of word.  \r\n  h=word[-2:] \r\n  print \"h is: \" \r\n  print h # The last two elements.  \r\n  i=word[:-2] \r\n  print \"i is: \" \r\n  print i # Everything except the last two characters \r\n  l=len(word) \r\n  print \"Length of word is: \"+ str(l) \r\n  print \"Adds new element\" \r\n  word.append(\'h\') \r\n  print word \r\n   \r\n  2.6 条件和循环语句 \r\n   \r\n  # Multi-way decision \r\n  x=int(raw_input(\"Please enter an integer:\")) \r\n  if x<0: \r\n      x=0 \r\n      print \"Negative changed to zero\" \r\n   \r\n  elif x==0: \r\n      print \"Zero\" \r\n   \r\n  else: \r\n      print \"More\" \r\n   \r\n   \r\n  # Loops List \r\n  a = [\'cat\', \'window\', \'defenestrate\'] \r\n  for x in a: \r\n      print x, len(x) \r\n   \r\n  2.7 如何定义函数 \r\n   \r\n  # Define and invoke function.  \r\n  def sum(a,b): \r\n      return a+b \r\n   \r\n   \r\n  func = sum \r\n  r = func(5,6) \r\n  print r \r\n   \r\n  # Defines function with default argument \r\n  def add(a,b=2): \r\n      return a+b \r\n  r=add(1) \r\n  print r \r\n  r=add(1,5) \r\n  print r \r\n   \r\n      并且,介绍一个方便好用的函数: \r\n  # The range() function \r\n  a =range(5,10) \r\n  print a \r\n  a = range(-2,-7) \r\n  print a \r\n  a = range(-7,-2) \r\n  print a \r\n  a = range(-2,-11,-3) # The 3rd parameter stands for step \r\n  print a \r\n   \r\n  2.8 文件I/O \r\n   \r\n  spath=\"D:/download/baa.txt\" \r\n  f=open(spath,\"w\") # Opens file for writing.Creates this file doesn\'t exist.  \r\n  f.write(\"First line 1.\r\n\") \r\n  f.writelines(\"First line 2.\") \r\n   \r\n  f.close() \r\n   \r\n  f=open(spath,\"r\") # Opens file for reading \r\n   \r\n  for line in f: \r\n      print line \r\n   \r\n  f.close() \r\n   \r\n  2.9 异常处理 \r\n   \r\n   \r\n  s=raw_input(\"Input your age:\") \r\n  if s ==\"\": \r\n      raise Exception(\"Input must no be empty.\") \r\n   \r\n  try: \r\n      i=int(s) \r\n  except ValueError: \r\n      print \"Could not convert data to an integer.\" \r\n  except: \r\n      print \"Unknown exception!\" \r\n  else: # It is useful for code that must be executed if the try clause does not raise an exception \r\n      print \"You are %d\" % i,\" years old\" \r\n  finally: # Clean up action \r\n      print \"Goodbye!\" \r\n   \r\n   \r\n  2.10 类和继承 \r\n   \r\n  class Base: \r\n      def __init__(self): \r\n          self.data = [] \r\n      def add(self, x): \r\n          self.data.append(x) \r\n      def addtwice(self, x): \r\n          self.add(x) \r\n          self.add(x) \r\n   \r\n  # Child extends Base \r\n  class Child(Base): \r\n      def plus(self,a,b): \r\n          return a+b \r\n   \r\n  oChild =Child() \r\n  oChild.add(\"str1\") \r\n  print oChild.data \r\n  print oChild.plus(2,3) \r\n   \r\n   \r\n  2.11 包机制 \r\n   \r\n      每一个.py文件称为一个module,module之间可以互相导入.请参看以下例子: \r\n  # a.py \r\n  def add_func(a,b): \r\n      return a+b \r\n   \r\n  # b.py \r\n  from a import add_func # Also can be : import a \r\n   \r\n  print \"Import add_func from module a\" \r\n  print \"Result of 1 plus 2 is: \" \r\n  print add_func(1,2)    # If using \"import a\" , then here should be \"a.add_func\" \r\n   \r\n   \r\n      module可以定义在包里面.Python定义包的方式稍微有点古怪,假设我们有一个parent文件夹,该文件夹有一个child子文件夹.child中有一个module a.py . 如何让Python知道这个文件层次结构?很简单,每个目录都放一个名为_init_.py 的文件.该文件内容可以为空.这个层次结构如下所示: \r\n  parent \r\n    --__init_.py \r\n    --child \r\n      -- __init_.py \r\n      --a.py \r\n   \r\n  b.py \r\n   \r\n      那么Python如何找到我们定义的module?在标准包sys中,path属性记录了Python的包路径.你可以将之打印出来: \r\n  import sys \r\n   \r\n  print sys.path \r\n   \r\n      通常我们可以将module的包路径放到环境变量PYTHONPATH中,该环境变量会自动添加到sys.path属性.另一种方便的方法是编程中直接指定我们的module路径到sys.path 中: \r\n  import sys \r\n  sys.path.append(\'D:\\\\download\') \r\n   \r\n  from parent.child.a import add_func \r\n   \r\n   \r\n  print sys.path \r\n   \r\n  print \"Import add_func from module a\" \r\n  print \"Result of 1 plus 2 is: \" \r\n  print add_func(1,2) \r\n   \r\n   \r\n  总结 \r\n      你会发现这个教程相当的简单.许多Python特性在代码中以隐含方式提出,这些特性包括:Python不需要显式声明数据类型,关键字说明,字符串函数的解释等等.我认为一个熟练的程序员应该对这些概念相当了解,这样在你挤出宝贵的一小时阅读这篇短短的教程之后,你能够通过已有知识的迁移类比尽快熟悉Python,然后尽快能用它开始编程.  \r\n   \r\n      当然,1小时学会Python颇有哗众取宠之嫌.确切的说,编程语言包括语法和标准库.语法相当于武术招式,而标准库应用实践经验则类似于内功,需要长期锻炼.Python学习了Java的长处,提供了大量极方便易用的标准库供程序员\"拿来主义\".(这也是Python成功的原因),在开篇我们看到了Python如何调用Windows cmd的例子,以后我会尽量写上各标准库的用法和一些应用技巧,让大家真正掌握Python.  \r\n   \r\n      但不管怎样,至少你现在会用Python代替繁琐的批处理写程序了.希望那些真的能在一小时内读完本文并开始使用Python的程序员会喜欢这篇小文章,谢谢!\npythonmodule python模块 \r\n  1）  python运行时服务 \r\n   \r\n    * copy： copy模块提供了对复合（compound）对象（list，tuple，dict，custom class）进行浅拷贝和深拷贝的功能。 \r\n   \r\n    * pickle： pickle模块被用来序列化python的对象到bytes流，从而适合存储到文件，网络传输，或数据库存储。（pickle的过程也被称serializing,marshalling或者flattening，pickle同时可以用来将bytes流反序列化为python的对象）。 \r\n   \r\n    * sys：sys模块包含了跟python解析器和环境相关的变量和函数。 \r\n   \r\n    * 其他： atexit，gc，inspect，marshal，traceback，types，warnings，weakref。 \r\n   \r\n     \r\n   \r\n  2）  数学 \r\n   \r\n    * decimal：python中的float使用双精度的二进制浮点编码来表示的，这种编码导致了小数不能被精确的表示，例如0.1实际上内存中为0.100000000000000001，还有3*0.1 == 0.3 为False. decimal就是为了解决类似的问题的，拥有更高的精确度，能表示更大范围的数字，更精确地四舍五入。 \r\n   \r\n    * math：math模块定义了标准的数学方法，例如cos(x),sin(x)等。 \r\n   \r\n    * random：random模块提供了各种方法用来产生随机数。 \r\n   \r\n    * 其他：fractions，numbers。 \r\n   \r\n     \r\n   \r\n  3）  数据结构，算法和代码简化 \r\n   \r\n    * array： array代表数组，类似与list，与list不同的是只能存储相同类型的对象。 \r\n   \r\n    * bisect： bisect是一个有序的list，其中内部使用二分法（bitsection）来实现大部分操作。 \r\n   \r\n    * collections：collections模块包含了一些有用的容器的高性能实现，各种容器的抽象基类，和创建name-tuple对象的函数。例如包含了容器deque，defaultdict，namedtuple等。 \r\n   \r\n    * heapq：heapq是一个使用heap实现的带有优先级的queue。 \r\n   \r\n    * itertools：itertools包含了函数用来创建有效的iterators。所有的函数都返回iterators或者函数包含iterators（例如generators 和generators expression）。 \r\n   \r\n    * operator： operator提供了访问python内置的操作和解析器提供的特殊方法，例如 x+y 为 add（x，y），x+=y为iadd（x，y），a % b 为mod（a，b）等等。 \r\n   \r\n    * 其他：abc，contextlib，functools。 \r\n   \r\n     \r\n   \r\n  4  ) string 和 text 处理 \r\n   \r\n    *codecs：codecs模块被用来处理不同的字符编码与unicode text io的转化。 \r\n   \r\n    * re：re模块用来对字符串进行正则表达式的匹配和替换。 \r\n   \r\n    * string：string模块包含大量有用的常量和函数用来处理字符串。也包含了新字符串格式的类。 \r\n   \r\n    * struct：struct模块被用来在python和二进制结构间实现转化。 \r\n   \r\n    * unicodedata：unicodedata模块提供访问unicode字符数据库 \r\n   \r\n   \r\n  5  ) python数据库访问 \r\n   \r\n    * 关系型数据库拥有共同的规范Python Database API Specification V2.0，MySQL，Oracle等都实现了此规范，然后增加自己的扩展。 \r\n   \r\n    * sqlite3: sqlite3 模块提供了SQLite数据库访问的接口。SQLite数据库是以一个文件或内存的形式存在的自包含的关系型数据库。 \r\n   \r\n    * DBM-style 数据库模块：python提供了打了的modules来支持UNIX DBM-style数据库文件。dbm模块用来读取标准的UNIX-dbm数据库文件，gdbm用来读取GNU dbm数据库文件，dbhash用来读取Berkeley DB数据库文件。所有的这些模块提供了一个对象实现了基于字符串的持久化的字典，他与字典dict非常相似，但是他的keys和values都必须是字符串。 \r\n   \r\n    * shelve：shelve模块使用特殊的“shelf”对象来支持持久化对象。这个对象的行为与dict相似，但是所有的他存储的对象都使用基于hashtable的数据库（dbhash，dbm，gdbm）存储在硬盘。与dbm模块的区别是所存储的对象不仅是字符串，而且可以是任意的与pickle兼容的对象。 \r\n   \r\n     \r\n   \r\n  6）  文件和目录处理 \r\n   \r\n    * bz2：bz2模块用来处理以bzip2压缩算法压缩的文件。 \r\n   \r\n    * filecmp：filecmp模块提供了函数来比较文件和目录。 \r\n   \r\n    * fnmatch：fnmatch模块提供了使用UNIX shell-style的通配符来匹配文件名。这个模块只是用来匹配，使用glob可以获得匹配的文件列表。 \r\n   \r\n    * glob：glob模块返回了某个目录下与指定的UNIX shell通配符匹配的所有文件。 \r\n   \r\n    * gzip：gzip模块提供了类GzipFile，用来执行与GNUgzip程序兼容的文件的读写。 \r\n   \r\n    * shutil： shutil模块用来执行更高级别的文件操作，例如拷贝，删除，改名。shutil操作之针对一般的文件，不支持pipes，block devices等文件类型。 \r\n   \r\n    * tarfile： tarfile模块用来维护tar存档文件。tar没有压缩的功能。 \r\n   \r\n    * tempfile：tempfile模块用来产生临时文件和文件名。 \r\n   \r\n    * zipfile： zipfile模块用来处理zip格式的文件。 \r\n   \r\n    * zlib，zlib模块提供了对zlib库的压缩功能的访问。 \r\n   \r\n     \r\n   \r\n  7）  操作系统的服务 \r\n   \r\n    * cmmands： commands模块被用来执行简单的系统命令，命令以字符串的形式传入，且同时以字符串的形式返回命令的输出。但是此模块只在UNIX系统上可用。 \r\n   \r\n    * configParser，configParser模块用来读写windows的ini格式的配置文件。 \r\n   \r\n    * datetime，datetime模块提供了各种类型来表示和处理日期和时间。 \r\n   \r\n    * errno， 定义了所有的errorcode对应的符号名字。 \r\n   \r\n    * io，io模块实现了各种IO形式和内置的open()函数。 \r\n   \r\n    * logging， logging模块灵活方便地对应用程序记录events，errors，warnings，和debuging 信息。这些log信息可以被收集，过滤，写到文件或系统log，甚至通过网络发送到远程的机器上。 \r\n   \r\n    *mmap，mmap模块提供了内存映射文件对象的支持，使用内存映射文件与使用一般的文件或byte字符串相似。 \r\n   \r\n    *msvcrt，mscrt只可以在windows系统使用，用来访问Visual C运行时库的很多有用的功能。 \r\n   \r\n    *optparse，optparse模块更高级别来处理UNIX style的命令行选项sys.argv。 \r\n   \r\n    * os，os模块对通用的操作系统服务提供了可移植的（portable）的接口。os可以认为是nt和posix的抽象。nt提供windows的服务接口，posix提供UNIX（linux，mac）的服务接口。 \r\n   \r\n    * os.path，os.path模块以可移植的方式来处理路径相关的操作。 \r\n   \r\n    * signal，signal模块用来实现信号（signal）处理，往往跟同步有关。 \r\n   \r\n    * subprocess，subprocess模块包含了函数和对象来统一创建新进程，控制新进程的输入输出流，处理进程的返回。 \r\n   \r\n    * time，time模块提供了各种时间相关的函数。常用的time.sleep().  \r\n   \r\n    * winreg, winreg模块用来操作windows注册表。 \r\n   \r\n    * 其他：fcntl。 \r\n   \r\n     \r\n   \r\n  8）  线程和并行 \r\n   \r\n    * multiprocessing，multiprocessing模块提供通过subprocess来加载多个任务，通信，共享数据，执行各种同步操作。 \r\n   \r\n    * threading，threading模块提供了thread类很很多的同步方法来实现多线程编程。 \r\n   \r\n    * queue，queue模块实现了各种多生产者，多消费者队列，被用来实现多线程程序的信息安全交换。 \r\n   \r\n    * 其他：Coroutines and Microthreading。 \r\n   \r\n     \r\n   \r\n  9）  网络编程和套接字（sockets） \r\n   \r\n    * asynchat，asynchat模块通过封装asyncore来简化了应用程序的网络异步处理。 \r\n   \r\n    * ssl，ssl模块被用来使用secure sockets layer（SSL）包装socket对象，从而使得实现数据加密和终端认证。python使用openssl来实现此模块。 \r\n   \r\n    * socketserver，socketserver模块提供了类型简化了TCP，UDP和UNIX领域的socket server的实现。 \r\n   \r\n    * 其他：asyncore，select。 \r\n   \r\n     \r\n   \r\n  10）internet应用程序编程 \r\n   \r\n    * ftplib，ftplib模块实现了ftp的client端协议。此模块很少使用，因为urllib提供了更高级的接口。 \r\n   \r\n    * http包，包含了http client和server的实现和cookies管理的模块。 \r\n   \r\n    * smtplib，smtplib包含了smtp client的底层接口，用来使用smtp协议发送邮件。 \r\n   \r\n    * urllib，urllib包提供了高级的接口来实现与http server，ftp server和本地文件交互的client。 \r\n   \r\n    * xmlrpc，xmlrpc模块被用类实现XML-RPC client。 \r\n   \r\n     \r\n   \r\n  11）  web 编程 \r\n   \r\n    * cgi，cgi模块用来实现cgi脚本，cgi程序一般地被webserver执行，用来处理用户在form中的输入，或生成一些动态的内容。当与cgi脚本有管的request被提交，webserver将cgi作为子进程执行，cgi程序通过sys.stdin或环境变量来获得输入，通过sys.stdout来输出。 \r\n   \r\n    * webbrowser，webbrowser模块提供了平台独立的工具函数来使用web browser打开文档。 \r\n   \r\n    * 其他：wsgiref/WSGI (Python Web Server Gateway Interface).  \r\n      \r\n   \r\n  12  ) internet 数据处理和编码 \r\n   \r\n    * base64，base64模块提供了base64，base32，base16编码方式，用来实现二进制与文本间的编码和解码。base64通常用来对编码二进制数据，从而嵌入到邮件或http协议中。 \r\n   \r\n    * binascii，binascii模块提供了低级的接口来实现二进制和各种ASCII编码的转化。 \r\n   \r\n    * csv，csv模块用来读写comma-separated values（CSV）文件。 \r\n   \r\n    * email，email包提供了大量的函数和对象来使用MIME标准来表示，解析和维护email消息。 \r\n   \r\n    * hashlib，hashlib模块实现了各种secure hash和message digest algorithms，例如MD5和SHA1。 \r\n   \r\n    * htmlparser（html.parser），此模块定义了HTMLParser来解析HTML和XHTML文档。使用此类，需要定义自己的类且继承于HTMLParser。 \r\n   \r\n    * json，json模块被用类序列化或饭序列化Javascript object notation（JSON）对象。 \r\n   \r\n    * xml,xml包提供了各种处理xml的方法。\npythonfunction python函数 \r\n  1.常用内置函数：(不用import就可以直接使用)  \r\n      help(obj) 在线帮助, obj可是任何类型 \r\n      callable(obj) 查看一个obj是不是可以像函数一样调用 \r\n      repr(obj) 得到obj的表示字符串，可以利用这个字符串eval重建该对象的一个拷贝 \r\n      eval_r(str) 表示合法的python表达式，返回这个表达式 \r\n      dir(obj) 查看obj的name space中可见的name \r\n      hasattr(obj,name) 查看一个obj的name space中是否有name \r\n      getattr(obj,name) 得到一个obj的name space中的一个name \r\n      setattr(obj,name,value) 为一个obj的name space中的一个name指向vale这个object \r\n      delattr(obj,name) 从obj的name space中删除一个name \r\n      vars(obj) 返回一个object的name space。用dictionary表示 \r\n      locals() 返回一个局部name space,用dictionary表示 \r\n      globals() 返回一个全局name space,用dictionary表示 \r\n      type(obj) 查看一个obj的类型 \r\n      isinstance(obj,cls) 查看obj是不是cls的instance \r\n      issubclass(subcls,supcls) 查看subcls是不是supcls的子类 \r\n      \r\n    类型转换函数 \r\n      chr(i) 把一个ASCII数值,变成字符 \r\n      ord(i) 把一个字符或者unicode字符,变成ASCII数值 \r\n      oct(x) 把整数x变成八进制表示的字符串 \r\n      hex(x) 把整数x变成十六进制表示的字符串 \r\n      str(obj) 得到obj的字符串描述 \r\n      list(seq) 把一个sequence转换成一个list \r\n      tuple(seq) 把一个sequence转换成一个tuple \r\n      dict(),dict(list) 转换成一个dictionary \r\n      int(x) 转换成一个integer \r\n      long(x) 转换成一个long interger \r\n      float(x) 转换成一个浮点数 \r\n      complex(x) 转换成复数 \r\n      max(...) 求最大值 \r\n      min(...) 求最小值 \r\n    用于执行程序的内置函数 \r\n      complie 如果一段代码经常要使用,那么先编译,再运行会更快。 \r\n      \r\n  2.和操作系统相关的调用 \r\n    系统相关的信息模块 import sys \r\n      sys.argv是一个list,包含所有的命令行参数.  \r\n      sys.stdout sys.stdin sys.stderr 分别表示标准输入输出,错误输出的文件对象.  \r\n      sys.stdin.readline() 从标准输入读一行 sys.stdout.write(\"a\") 屏幕输出a \r\n      sys.exit(exit_code) 退出程序 \r\n      sys.modules 是一个dictionary，表示系统中所有可用的module \r\n      sys.platform 得到运行的操作系统环境 \r\n      sys.path 是一个list,指明所有查找module，package的路径.  \r\n      \r\n    操作系统相关的调用和操作 import os \r\n      os.environ 一个dictionary 包含环境变量的映射关系 os.environ[\"HOME\"] 可以得到环境变量HOME的值 \r\n      os.chdir(dir) 改变当前目录 os.chdir(\'d:\\\\outlook\') 注意windows下用到转义 \r\n      os.getcwd() 得到当前目录 \r\n      os.getegid() 得到有效组id  os.getgid() 得到组id \r\n      os.getuid() 得到用户id  os.geteuid() 得到有效用户id \r\n      os.setegid os.setegid() os.seteuid() os.setuid() \r\n      os.getgruops() 得到用户组名称列表 \r\n      os.getlogin() 得到用户登录名称 \r\n      os.getenv 得到环境变量 \r\n      os.putenv 设置环境变量 \r\n      os.umask 设置umask \r\n      os.system(cmd) 利用系统调用，运行cmd命令 \r\n      操作举例： \r\n        os.mkdir(\'/tmp/xx\') os.system(\"echo \'hello\' > /tmp/xx/a.txt\") os.listdir(\'/tmp/xx\') \r\n        os.rename(\'/tmp/xx/a.txt\',\'/tmp/xx/b.txt\') os.remove(\'/tmp/xx/b.txt\') os.rmdir(\'/tmp/xx\') \r\n        用python编写一个简单的shell \r\n          #!/usr/bin/python \r\n          import os, sys \r\n          cmd = sys.stdin.readline() \r\n          while cmd: \r\n              os.system(cmd) \r\n              cmd = sys.stdin.readline() \r\n              \r\n    用os.path编写平台无关的程序 \r\n      os.path.abspath(\"1.txt\") == os.path.join(os.getcwd(), \"1.txt\") \r\n      os.path.split(os.getcwd()) 用于分开一个目录名称中的目录部分和文件名称部分。 \r\n      os.path.join(os.getcwd(), os.pardir, \'a\', \'a.doc\') 全成路径名称.  \r\n        os.pardir 表示当前平台下上一级目录的字符 ..  \r\n      os.path.getctime(\"/root/1.txt\")  返回1.txt的ctime(创建时间)时间戳 \r\n      os.path.exists(os.getcwd()) 判断文件是否存在 \r\n      os.path.expanduser(\'~/dir\') 把~扩展成用户根目录 \r\n      os.path.expandvars(\'$PATH\') 扩展环境变量PATH \r\n      os.path.isfile(os.getcwd()) 判断是否是文件名，1是0否 \r\n      os.path.isdir(\'c:\\Python26  emp\') 判断是否是目录,1是0否 \r\n      os.path.islink(\'/home/huaying/111.sql\') 是否是符号连接 windows下不可用 \r\n      os.path.ismout(os.getcwd()) 是否是文件系统安装点 windows下不可用 \r\n      os.path.samefile(os.getcwd(), \'/home/huaying\') 看看两个文件名是不是指的是同一个文件 \r\n      os.path.walk(\'/home/huaying\', test_fun, \"a.c\")  \r\n        遍历/home/huaying下所有子目录包括本目录,对于每个目录都会调用函数test_fun.  \r\n        例：在某个目录中，和他所有的子目录中查找名称是a.c的文件或目录。 \r\n          def test_fun(filename, dirname, names): //filename即是walk中的a.c dirname是访问的目录名称 \r\n              if filename in names: //names是一个list,包含dirname目录下的所有内容 \r\n                  print os.path.join(dirname, filename) \r\n          os.path.walk(\'/home/huaying\', test_fun, \"a.c\") \r\n          \r\n    文件操作 \r\n      打开文件 \r\n        f = open(\"filename\", \"r\") r只读 w写 rw读写 rb读二进制 wb写二进制 w+写追加 \r\n      读写文件 \r\n        f.write(\"a\") f.write(str) 写一字符串 f.writeline() f.readlines() 与下read类同 \r\n        f.read() 全读出来 f.read(size) 表示从文件中读取size个字符 \r\n        f.readline() 读一行,到文件结尾,返回空串. f.readlines() 读取全部，返回一个list. list每个元素表示一行，包含\"\r\n\"\\ \r\n        f.tell() 返回当前文件读取位置 \r\n        f.seek(off, where) 定位文件读写位置. off表示偏移量，正数向文件尾移动，负数表示向开头移动。 \r\n          where为0表示从开始算起,1表示从当前位置算,2表示从结尾算.  \r\n        f.flush() 刷新缓存 \r\n      关闭文件 \r\n        f.close() \r\n        \r\n  正则表达式 import re \r\n      简单的regexp \r\n        p = re.compile(\"abc\") if p.match(\"abc\") : print \"match\" \r\n        上例中首先生成一个pattern(模式),如果和某个字符串匹配，就返回一个match object \r\n        除某些特殊字符metacharacter元字符，大多数字符都和自身匹配。 \r\n        这些特殊字符是 。^ $ * + ? { [ ] \\ | ( ) \r\n      字符集合(用[]表示) \r\n        列出字符,如[abc]表示匹配a或b或c,大多数metacharacter在[]中只表示和本身匹配。例： \r\n          a = \".^$*+?{\\\\|()\"  大多数metachar在[]中都和本身匹配，但\"^[]\\\"不同 \r\n          p = re.compile(\"[\"+a+\"]\") \r\n          for i in a: \r\n              if p.match(i): \r\n                  print \"[%s] is match\" %i \r\n              else: \r\n                  print \"[%s] is not match\" %i \r\n          在[]中包含[]本身，表示\"[\"或者\"]\"匹配.用\\[和\\]表示.  \r\n          ^出现在[]的开头,表示取反.[^abc]表示除了a,b,c之外的所有字符。^没有出现在开头，即于身身匹配。 \r\n          -可表示范围.[a-zA-Z]匹配任何一个英文字母。[0-9]匹配任何数字。 \r\n          \\在[]中的妙用。 \r\n            \\d [0-9] \r\n            \\D [^0-9] \r\n            \\s [   \r\n\\r\\f\\v] \r\n            \\S [^   \r\n\\r\\f\\v] \r\n            \\w [a-zA-Z0-9_] \r\n            \\W [^a-zA-Z0-9_] \r\n               表示和tab匹配, 其他的都和字符串的表示法一致 \r\n            \\x20 表示和十六进制ascii 0x20匹配 \r\n            有了\\，可以在[]中表示任何字符。注：单独的一个\".\"如果没有出现[]中，表示出了换行\r\n以外的匹配任何字符,类似[^\r\n].  \r\n        regexp的重复          \r\n          {m,n}表示出现m个以上(含m个),n个以下(含n个).  如ab{1,3}c和abc,abbc,abbbc匹配，不会与ac,abbbc匹配。 \r\n          m是下界，n是上界。m省略表下界是0,n省略，表上界无限大。 \r\n          *表示{,} +表示{1,} ?表示{0,1} \r\n          最大匹配和最小匹配 python都是最大匹配，如果要最小匹配，在*,+,?,{m,n}后面加一个?.  \r\n          match object的end可以得到匹配的最后一个字符的位置。 \r\n            re.compile(\"a*\").match(\'aaaa\').end()     4  最大匹配 \r\n            re.compile(\"a*?\").match(\'aaaa\').end()    0  最小匹配 \r\n        使用原始字符串 \r\n          字符串表示方法中用\\\\表示字符\\.大量使用影响可读性。 \r\n          解决方法：在字符串前面加一个r表示raw格式。 \r\n          a = r\"\\a\" print a 结果是\\a \r\n          a = r\"\\\"a\" print a 结果是\\\"a \r\n        使用re模块 \r\n          先用re.compile得到一个RegexObject 表示一个regexp \r\n          后用pattern的match,search的方法,得到MatchObject \r\n          再用match object得到匹配的位置,匹配的字符串等信息 \r\n          RegxObject常用函数: \r\n            >>> re.compile(\"a\").match(\"abab\") 如果abab的开头和re.compile(\"a\")匹配，得到MatchObject \r\n            <_sre.SRE_Match object at 0x81d43c8> \r\n            >>> print re.compile(\"a\").match(\"bbab\") \r\n            None 注：从str的开头开始匹配          \r\n            >>> re.compile(\"a\").search(\"abab\") 在abab中搜索第一个和re_obj匹配的部分 \r\n            <_sre.SRE_Match object at 0x81d43c8> \r\n            >>> print re.compile(\"a\").search(\"bbab\") \r\n            <_sre.SRE_Match object at 0x8184e18> 和match()不同,不必从开头匹配          \r\n            re_obj.findall(str) 返回str中搜索所有和re_obj匹配的部分.  \r\n              返回一个tuple,其中元素是匹配的字符串.  \r\n          MatchObject的常用函数 \r\n            m.start() 返回起始位置,m.end()返回结束位置(不包含该位置的字符).  \r\n            m.span() 返回一个tuple表示(m.start(), m.end()) \r\n            m.pos(), m.endpos(), m.re(), m.string() \r\n              m.re().search(m.string(), m.pos(), m.endpos()) 会得到m本身 \r\n            m.finditer()可以返回一个iterator,用来遍历所有找到的MatchObject.  \r\n              for m in re.compile(\"[ab]\").finditer(\"tatbxaxb\"): \r\n              print m.span() \r\n        高级regexp \r\n          | 表示联合多个regexp. A B两个regexp，A|B表示和A匹配或者跟B匹配.  \r\n          ^ 表示只匹配一行的开始行首,^只有在开头才有此特殊意义。 \r\n          $ 表示只匹配一行的结尾 \r\n          \\A 表示只匹配第一行字符串的开头 ^匹配每一行的行首 \r\n          \\Z 表示只匹配行一行字符串的结尾 $匹配第一行的行尾 \r\n          \\b 只匹配词的边界 例：\\binfo\\b 只会匹配\"info\" 不会匹配information \r\n          \\B 表示匹配非单词边界 \r\n          示例如下： \r\n            >>> print re.compile(r\"\\binfo\\b\").match(\"info \") #使用raw格式 \\b表示单词边界 \r\n            <_sre.SRE_Match object at 0x817aa98> \r\n            >>> print re.compile(\"\\binfo\\b\").match(\"info \") #没有使用raw \\b表示退格符号 \r\n            None \r\n            >>> print re.compile(\"\\binfo\\b\").match(\"\\binfo\\b \") \r\n            <_sre.SRE_Match object at 0x8174948> \r\n        分组(Group) 示例：re.compile(\"(a(b)c)d\").match(\"abcd\").groups()   (\'abc\', \'b\')        \r\n          #!/usr/local/bin/python        \r\n          import re        \r\n          x = \"\"\" \r\n          name: Charles \r\n          Address: BUPT \r\n          \r\n          name: Ann \r\n          Address: BUPT \r\n          \"\"\"        \r\n          #p = re.compile(r\"^name:(.*)\r\n^Address:(.*)\r\n\", re.M) \r\n          p = re.compile(r\"^name:(?P.*)\r\n^Address:(?P.*)\r\n\", re.M) \r\n          for m in p.finditer(x): \r\n                  print m.span() \r\n                  print \"here is your friends list\" \r\n                  print \"%s, %s\"%m.groups() \r\n        Compile Flag \r\n          用re.compile得到RegxObject时，可以有一些flag用来调整RegxObject的详细特征.  \r\n            DOTALL, S 让.匹配任意字符,包括换行符\r\n \r\n            IGNORECASE, I 忽略大小写 \r\n            LOCALES, L 让\\w \\W \\b \\B和当前的locale一致 \r\n            MULTILINE, M 多行模式，只影响^和$(参见上例) \r\n            VERBOSE, X verbose模式\npythondatetime 日期函数 \r\n   \r\n  Time模块： \r\n  －－－－－－－－－－－－－－－－－－－－－－－－－－ \r\n  time() #以浮点形式返回自Linux新世纪以来经过的秒数。在linux中，00:00:00 UTC, \r\n   \r\n  January 1, 1970是新**49**的开始。 \r\n  >>> time.time() \r\n  1150269086.6630149 \r\n  >>> time.ctime(1150269086.6630149) \r\n  >>> \'Wed Jun 14 15:11:26 2006\' \r\n   \r\n  time.ctime([sec])#把秒数转换成日期格式，如果不带参数，则显示当前的时间。 \r\n   \r\n  >>> import time \r\n  >>> time.ctime() \r\n  >>> \'Wed Jun 14 15:02:50 2006\' \r\n  >>> time.ctime(1138068452427683) \r\n  \'Sat Dec 14 04:51:44 1901\' \r\n  >>> time.ctime(os.path.getmtime(\'E:\\\\untitleds.bmp\')) \r\n  \'Fri Sep 19 16:35:37 2008\' \r\n   \r\n  >>> time.gmtime(os.path.getmtime(\'E:\\\\untitleds.bmp\')) \r\n  time.struct_time(tm_year=2008, tm_mon=9, tm_mday=19, tm_hour=8, tm_min=35, \r\n   \r\n  tm_sec=37, tm_wday=4, tm_yday=263, tm_isdst=0) \r\n   \r\n  将一个文件的修改时间转换为日期格式（秒 转 日期） \r\n  >>> time.strftime(\'%Y-%m-%d %X\',time.localtime(os.path.getmtime \r\n   \r\n  (\'E:\\\\untitleds.bmp\'))) \r\n  \'2008-09-19 16:35:37\' \r\n   \r\n  #定时3秒。 \r\n  >>> time.sleep(3) \r\n   \r\n  TIME模块参考： \r\n  －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ \r\n  #取一个文件的修改时间 \r\n  >>> os.path.getmtime(\'E:\\\\untitleds.bmp\') \r\n  1221813337.7626641 \r\n   \r\n  变量 \r\n  timezone 通用协调时间和本地标准时间的差值，以秒为单位。 \r\n  altzone 通用协调时间和本地夏令时的差值 \r\n  daylight 标志，本地时间是否反映夏令时。 \r\n  tzname (标准时区名，夏令时时区名) \r\n   \r\n  函数 \r\n  time() 以浮点数返回纪元至今以来的秒数。 \r\n  clock() 以浮点数返回CPU开始这个process的时间，(或者至上次调用这个函数的时间) \r\n  sleep() 延迟一段以浮点数表示的秒数。 \r\n  gmtime() 把以秒表示的时间转换为通用协调时序列 \r\n  localtime() 把秒时转换为本地时序列 \r\n  asctime() 将时间序列转换成文本描述 \r\n  ctime() 将秒时转换成文本描述 \r\n  mktime() 将本地时序列转换成秒时 \r\n  strftime() 以指定格式将序列时转为文本描述 \r\n  strptime() 以指定格式从文本描述中解析出时间序列 \r\n  tzset() 改变当地时区值 \r\n   \r\n  strptime(date_string, format)函数time模块中用来将日期字符串date_string按指定的格式format进行转换，format是要以date_string对应的。如果转换失败将触发一个异常。 \r\n  format转义符对应意义如下 \r\n  %a 本地简化星期名称 \r\n  %A 本地完整星期名称 \r\n  %b 本地简化的月份名称 \r\n  %B 本地完整的月份名称 \r\n  %c 本地相应的日期表示和时间表示 \r\n  %d 月内中的一天（0-31） \r\n  %H 24小时制小时数（0-23） \r\n  %I 12小时制小时数（01-12） \r\n  %j 年内的一天（001-366）#hi.baidu.com/muinlive \r\n  %m 月份（01-12） \r\n  %M 分钟数（00=59） \r\n  %p 本地A.M.或P.M.的等价符 \r\n  %S 秒（00-59） \r\n  %U 一年中的星期数（00-53）星期天为星期的开始 \r\n  %w 星期（0-6），星期天为星期的开始 \r\n  %W 一年中的星期数（00-53）星期一为星期的开始 \r\n  %x 本地相应的日期表示 \r\n  %X 本地相应的时间表示 \r\n  %y 两位数的年份表示（00-99） \r\n  %Y 四位数的年份表示（000-9999） \r\n  %Z 当前时区的名称 \r\n  %% %号本身 \r\n  #hi.baidu.com/muinlive \r\n  示例结果 \r\n  >>> d1=time.strptime(\'2007/4/15\',\'%Y/%m/%d\') \r\n  >>> d1 \r\n  (2007, 4, 15, 0, 0, 0, 6, 105, -1) \r\n   \r\n  你可以利用 time 模块里的 strptime（）和 strftime（）。 \r\n   \r\n  strftime（）则根据你指定的格式控制字符串输出日期。 \r\n   \r\n  比如，把 “12-Jan-06 10:06” 格式转换成 “2006-01-12 10:06:00” 格式： \r\n   \r\n  >>> from time import strptime, strftime \r\n  >>> \r\n  >>> myDate = \'12-Jan-06 10:06\' \r\n  >>> parsed = strptime( myDate, \'%d-%b-%y %H:%M\' ) \r\n  >>> converted = strftime( \'%Y-%m-%d %H:%M:00\', parsed ) \r\n  >>> \r\n  >>> converted \r\n  \'2006-01-12 10:06:00\' \r\n   \r\n  http://blog.csdn.net/moxien/archive/2008/06/04/2512343.aspx \r\n   \r\n   \r\n   \r\n  DateTime模块 \r\n  －－－－－－－－－－－－－－－－－－－－－－－－－－－－ \r\n  datetime 将日期转化为秒 \r\n  ------------------------------------- \r\n  >>> import datetime,time \r\n  >>> time.mktime(datetime.datetime(2009,1,1).timetuple()) \r\n  1230739200.0 \r\n   \r\n  >>> cc=[2000,11,3,12,43,33] #Attributes: year, month, day, hour, minute, \r\n   \r\n  second \r\n  >>> time.mktime(datetime.datetime(cc[0],cc[1],cc[2],cc[3],cc[4],cc \r\n   \r\n  [5]).timetuple()) \r\n  973226613.0 \r\n   \r\n  将秒转换为日期格式 \r\n  >>> cc = time.localtime(os.path.getmtime(\'E:\\\\untitleds.bmp\')) \r\n  >>> print cc[0:3] \r\n  (2008, 9, 19) \r\n   \r\n  DateTime示例 \r\n  －－－－－－－－－－－－－－－－－ \r\n  演示计算两个日期相差天数的计算 \r\n  >>> import datetime \r\n  >>> d1 = datetime.datetime(2005, 2, 16) \r\n  >>> d2 = datetime.datetime(2004, 12, 31) \r\n  >>> (d1 - d2).days \r\n  47 \r\n   \r\n  演示计算运行时间的例子，以秒进行显示 \r\n  import datetime \r\n  starttime = datetime.datetime.now() \r\n  #long running \r\n  endtime = datetime.datetime.now() \r\n  print (endtime - starttime).seconds \r\n   \r\n  演示计算当前时间向后10小时的时间。 \r\n  >>> d1 = datetime.datetime.now() \r\n  >>> d3 = d1 + datetime.timedelta(hours=10) \r\n  >>> d3.ctime() \r\n   \r\n  其本上常用的类有：datetime和timedelta两个。它们之间可以相互加减。每个类都有一 \r\n   \r\n  些方法和属性可以查看具体的值 \r\n   \r\n  3)glob \r\n  可以使用简单的方法匹配某个目录下的所有子目录或文件，用法也很简单。 \r\n  3.1 glob.glob(regression) 返回一个列表 \r\n  3.2 glob.iglob(regression) 返回一个遍历器 \r\n  这个模块简单好用，强力推荐。\n','//Handling line , may logs it.  \r'),(25,'tcpdump','\ntcpdump tcp port 80 show all HTTP traffic\ntcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap \r\n  (1)tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型 \r\n  (2)-i eth1 : 只抓经过接口eth1的包 \r\n  (3)-t : 不显示时间戳 \r\n  (4)-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包 \r\n  (5)-c 100 : 只抓取100个数据包 \r\n  (6)dst port ! 22 : 不抓取目标端口是22的数据包 \r\n  (7)src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24 \r\n  (8)-w ./target.cap : 保存成cap文件，方便用ethereal(即wireshark)分析\ntcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\)  \r\n  (1)截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信\ntcpdump 使用文档\r\n \r\n  一、监视指定主机的数据包 \r\n   \r\n    打印所有进入或离开sundown的数据包.  \r\n   \r\n    tcpdump host sundown \r\n   \r\n    也可以指定ip,例如截获所有210.27.48.1 的主机收到的和发出的所有的数据包 \r\n   \r\n    tcpdump host 210.27.48.1 \r\n   \r\n    打印helios 与 hot 或者与 ace 之间通信的数据包 \r\n   \r\n    tcpdump host helios and \\( hot or ace \\) \r\n   \r\n    截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信 \r\n   \r\n    tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\) \r\n   \r\n    打印ace与任何其他主机之间通信的IP 数据包, 但不包括与helios之间的数据包.  \r\n   \r\n    tcpdump ip host ace and not helios \r\n   \r\n    如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令： \r\n   \r\n    tcpdump ip host 210.27.48.1 and ! 210.27.48.2 \r\n   \r\n    截获主机hostname发送的所有数据 \r\n   \r\n    tcpdump -i eth0 src host hostname \r\n   \r\n    监视所有送到主机hostname的数据包 \r\n   \r\n    tcpdump -i eth0 dst host hostname \r\n   \r\n   \r\n   \r\n  二、监视指定主机和端口的数据包 \r\n   \r\n    如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令 \r\n   \r\n    tcpdump tcp port 23 host 210.27.48.1 \r\n   \r\n    对本机的udp 123 端口进行监视 123 为ntp的服务端口 \r\n   \r\n    tcpdump udp port 123 \r\n   \r\n   \r\n   \r\n  三、监视指定网络的数据包 \r\n   \r\n    打印本地主机与Berkeley网络上的主机之间的所有通信数据包(nt: ucb-ether, 此处可理解为\'Berkeley网络\'的网络地址,此表达式最原始的含义可表达为: 打印网络地址为ucb-ether的所有数据包) \r\n   \r\n    tcpdump net ucb-ether \r\n   \r\n    打印所有通过网关snup的ftp数据包(注意, 表达式被单引号括起来了, 这可以防止shell对其中的括号进行错误解析) \r\n   \r\n    tcpdump \'gateway snup and (port ftp or ftp-data)\' \r\n   \r\n    打印所有源地址或目标地址是本地主机的IP数据包 \r\n   \r\n    (如果本地网络通过网关连到了另一网络, 则另一网络并不能算作本地网络.(nt: 此句翻译曲折,需补充).localnet 实际使用时要真正替换成本地网络的名字) \r\n   \r\n    tcpdump ip and not net localnet \r\n   \r\n   \r\n   \r\n  四、监视指定协议的数据包 \r\n   \r\n    打印TCP会话中的的开始和结束数据包, 并且数据包的源或目的不是本地网络上的主机.(nt: localnet, 实际使用时要真正替换成本地网络的名字)) \r\n   \r\n    tcpdump \'tcp[tcpflags] & (tcp-syn|tcp-fin) != 0 and not src and dst net localnet\' \r\n   \r\n    打印所有源或目的端口是80, 网络层协议为IPv4, 并且含有数据,而不是SYN,FIN以及ACK-only等不含数据的数据包.(ipv6的版本的表达式可做练习) \r\n   \r\n    tcpdump \'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)\' \r\n   \r\n    (nt: 可理解为, ip[2:2]表示整个ip数据包的长度, (ip[0]&0xf)<<2)表示ip数据包包头的长度(ip[0]&0xf代表包中的IHL域, 而此域的单位为32bit, 要换算 \r\n   \r\n    成字节数需要乘以4,　即左移2.　(tcp[12]&0xf0)>>4 表示tcp头的长度, 此域的单位也是32bit,　换算成比特数为 ((tcp[12]&0xf0) >> 4)　<<　２,　 \r\n    即 ((tcp[12]&0xf0)>>2).　((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0　表示: 整个ip数据包的长度减去ip头的长度,再减去 \r\n    tcp头的长度不为0, 这就意味着, ip数据包中确实是有数据.对于ipv6版本只需考虑ipv6头中的\'Payload Length\' 与 \'tcp头的长度\'的差值, 并且其中表达方式\'ip[]\'需换成\'ip6[]\'.) \r\n   \r\n    打印长度超过576字节, 并且网关地址是snup的IP数据包 \r\n   \r\n    tcpdump \'gateway snup and ip[2:2] > 576\' \r\n   \r\n    打印所有IP层广播或多播的数据包， 但不是物理以太网层的广播或多播数据报 \r\n   \r\n    tcpdump \'ether[0] & 1 = 0 and ip[16] >= 224\' \r\n   \r\n    打印除\'echo request\'或者\'echo reply\'类型以外的ICMP数据包( 比如,需要打印所有非ping 程序产生的数据包时可用到此表达式 .  \r\n    (nt: \'echo reuqest\' 与 \'echo reply\' 这两种类型的ICMP数据包通常由ping程序产生)) \r\n   \r\n    tcpdump \'icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply\' \r\n  \n',''),(26,'php','\nphpfunction 函数大全 \r\n  usleep() 延迟代码执行若干微秒。 \r\n  unpack() 从二进制字符串对数据进行解包。 \r\n  uniqid() 基于以微秒计的当前时间，生成一个唯一的 ID。 \r\n  time_sleep_until() 延迟代码执行直到指定的时间。 \r\n  time_nanosleep() 延迟代码执行若干秒和纳秒。 \r\n  sleep() 延迟代码执行若干秒。 \r\n  show_source() 对文件进行语法高亮显示。 \r\n  strip_whitespace() 返回已删除 PHP 注释以及空白字符的源代码文件。 \r\n  pack() 把数据装入一个二进制字符串。 \r\n  ignore_user_abort() 设置与客户机断开是否会终止脚本的执行。 \r\n  highlight_string() 对字符串进行语法高亮显示。 \r\n  highlight_file() 对文件进行语法高亮显示。 \r\n  get_browser() 返回用户浏览器的性能。 \r\n  exit() 输出一条消息，并退出当前脚本。 \r\n  eval() 把字符串按照 PHP 代码来计算。 \r\n  die() 输出一条消息，并退出当前脚本。 \r\n  defined() 检查某常量是否存在。 \r\n  define() 定义一个常量。 \r\n  constant() 返回常量的值。 \r\n  connection_status() 返回当前的连接状态。 \r\n  connection_aborted() 检查是否断开客户机。 \r\n  zip_read() 读取打开的 zip 档案中的下一个文件。 \r\n  zip_open() 打开 ZIP 文件以供读取。 \r\n  zip_entry_read() 从打开的 zip 档案项目中获取内容。 \r\n  zip_entry_open() 打开一个 ZIP 档案项目以供读取。 \r\n  zip_entry_name() 返回 zip 档案项目的名称。 \r\n  zip_entry_filesize() 返回 zip 档案项目的原始大小（在压缩之前）。 \r\n  zip_entry_compressionmethod() 返回 zip 档案项目的压缩方法。 \r\n  zip_entry_compressedsize() 返回 zip 档案项目的压缩文件尺寸。 \r\n  zip_entry_close() 关闭由 zip_entry_open() 函数打开的 zip 档案文件。 \r\n  zip_close() 关闭由 zip_open() 函数打开的 zip 档案文件。 \r\n  xml_set_unparsed_entity_decl_handler() 规定在遇到无法解析的实体名称（NDATA）声明时被调用的函数。 \r\n  xml_set_processing_instruction_handler() 规定当解析器在 XML 文档中找到处理指令时所调用的函数。 \r\n  xml_set_object() 允许在对象中使用 XML 解析器。 \r\n  xml_set_notation_decl_handler() 规定当解析器在 XML 文档中找到符号声明时被调用的函数。 \r\n  xml_set_external_entity_ref_handler() 规定当解析器在 XML 文档中找到外部实体时被调用的函数。 \r\n  xml_set_element_handler() 建立起始和终止元素处理器。 \r\n  xml_set_default_handler() 为 XML 解析器建立默认的数据处理器。 \r\n  xml_set_character_data_handler() 建立字符数据处理器。 \r\n  xml_parser_set_option() 为 XML 解析器进行选项设置。 \r\n  xml_parser_get_option() 从 XML 解析器获取选项设置信息。 \r\n  xml_parser_free() 释放 XML 解析器。 \r\n  xml_parser_create() 创建 XML 解析器。 \r\n  xml_parser_create_ns() 创建带有命名空间支持的 XML 解析器。 \r\n  xml_parse_into_struct() 把 XML 数据解析到数组中。 \r\n  xml_parse() 解析 XML 文档。 \r\n  xml_get_error_code() 获取 XML 解析器错误代码。 \r\n  xml_get_current_line_number() 获取 XML 解析器的当前行号。 \r\n  xml_get_current_column_number() 获取 XML 解析器的当前列号。 \r\n  xml_get_current_byte_index() 获取 XML 解析器的当前字节索引。 \r\n  xml_error_string() 获取 XML 解析器的错误描述。 \r\n  utf7_encode() 把 ISO-8859-1 字符串编码为 UTF-8。 \r\n  utf8_decode() 把 UTF-8 字符串解码为 ISO-8859-1。 \r\n  wordwrap() 按照指定长度对字符串进行折行处理。 \r\n  vsprintf() 把格式化字符串写入变量中。 \r\n  vprintf() 输出格式化的字符串。 \r\n  vfprintf() 把格式化的字符串写到指定的输出流。 \r\n  ucwords() 把字符串中每个单词的首字符转换为大写。 \r\n  ucfirst() 把字符串中的首字符转换为大写。 \r\n  trim() 从字符串的两端删除空白字符和其他预定义字符。 \r\n  substr_replace() 把字符串的一部分替换为另一个字符串。 \r\n  substr_count() 计算子串在字符串中出现的次数。 \r\n  substr_compare() 从指定的开始长度比较两个字符串。 \r\n  substr() 返回字符串的一部分。 \r\n  strtr() 转换字符串中特定的字符。 \r\n  strtoupper() 把字符串转换为大写。 \r\n  strtolower() 把字符串转换为小写。 \r\n  strtok() 把字符串分割为更小的字符串。 \r\n  strstr() 搜索一个字符串在另一个字符串中的第一次出现。 \r\n  strspn() 返回在字符串中包含的特定字符的数目。 \r\n  strrpos() 查找字符串在另一个字符串中最后一次出现的位置。 \r\n  strripos() 查找字符串在另一个字符串中最后一次出现的位置。 \r\n  strrev() 反转字符串。 \r\n  strrchr() 查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。 \r\n  strpos() 返回字符串在另一个字符串中第一次出现的位置。 \r\n  strpbrk() 在字符串中搜索指定字符中的任意一个。 \r\n  strncmp() 比较两个字符串。 \r\n  strncasecmp() 比较两个字符串。 \r\n  strnatcmp() 使用一种“自然”算法来比较两个字符串。 \r\n  strnatcasecmp() 使用一种“自然”算法来比较两个字符串。 \r\n  strlen() 返回字符串的长度。 \r\n  stristr() 查找字符串在另一个字符串中第一次出现的位置。 \r\n  stripos() 返回字符串在另一个字符串中第一次出现的位置。 \r\n  stripslashes() 删除由 addslashes()函数添加的反斜杠。 \r\n  stripcslashes() 删除由addcslashes()函数添加的反斜杠。 \r\n  strip_tags() 剥去 HTML、XML 以及 PHP 的标签。 \r\n  strcspn() 返回在找到任何指定的字符之前，在字符串查找的字符数。 \r\n  strcoll() 比较两个字符串。 \r\n  strcmp() 比较两个字符串。 \r\n  strchr() 搜索一个字符串在另一个字符串中的第一次出现。 \r\n  strcasecmp() 比较两个字符串。 \r\n  str_word_count() 计算字符串中的单词数。 \r\n  str_split() 把字符串分割到数组中。 \r\n  str_shuffle() 随机地打乱字符串中的所有字符。 \r\n  str_rot13() 对字符串执行 ROT13 编码。 \r\n  str_replace() 使用一个字符串替换字符串中的另一些字符。 \r\n  str_repeat() 把字符串重复指定的次数。 \r\n  str_pad() 把字符串填充为指定的长度。 \r\n  str_ireplace() 使用一个字符串替换字符串中的另一些字符。 \r\n  sscanf() 根据指定的格式解析来自一个字符串的输入。 \r\n  sprintf() 把格式化的字符串写写入一个变量中。 \r\n  soundex() 计算字符串的 soundex 键。 \r\n  similar_text() 计算两个字符串的匹配字符的数目。 \r\n  sha1_file() 计算文件的 SHA-1 散列。 \r\n  sha1() 计算字符串的 SHA-1 散列。 \r\n  setlocale() 设置地区信息（地域信息）。 \r\n  rtrim() P rtrim() 函数 \r\n  quotemeta() 在字符串中某些预定义的字符前添加反斜杠。 \r\n  quoted_printable_decode() 对经过 quoted-printable 编码后的字符串进行解码，返回 8 位的字符串。 \r\n  printf() 输出格式化的字符串。 \r\n  print() 输出一个或多个字符串。 \r\n  parse_str() 把查询字符串解析到变量中。 \r\n  ord() 返回字符串第一个字符的 ASCII 值。 \r\n  number_format() 通过千位分组来格式化数字。 \r\n  nl2br() 在字符串中的每个新行 (\r\n) 之前插入 HTML 换行符 (<br />)。 \r\n  nl_langinfo() 返回指定的本地信息。 \r\n  money_format() 把字符串格式化为货币字符串。 \r\n  metaphone() 计算字符串的 metaphone 键。 \r\n  md5_file() 计算文件的 MD5 散列。 \r\n  md5() 计算字符串的 MD5 散列。 \r\n  ltrim() 从字符串左侧删除空格或其他预定义字符。 \r\n  localeconv() 返回包含本地数字及货币信息格式的数组。 \r\n  levenshtein() 返回两个字符串之间的 Levenshtein 距离。 \r\n  join() 把数组元素组合为一个字符串。 \r\n  implode() 把数组元素组合为一个字符串。 \r\n  htmlspecialchars() 把一些预定义的字符转换为 HTML 实体。 \r\n  html_entity_decode() chars_decode() 函数 \r\n  htmlentities() 把字符转换为 HTML 实体。 \r\n  html_entity_decode() 把 HTML 实体转换为字符。 \r\n  hebrevc() 把希伯来文本从右至左的流转换为左至右的流。它也会把新行 (\r\n) 转换为 <br />。 \r\n  hebrev() 把希伯来文本从右至左的流转换为左至右的流。 \r\n  get_html_translation_table() 返回被htmlentities()和htmlspecialchars()函数使用的翻译表。 \r\n  fprintf() 把格式化的字符串写到指定的输出流（例如：文件或数据库）。 \r\n  explode() 把字符串分割为数组。 \r\n  echo() 输出一个或多个字符串。 \r\n  crypt() 返回使用 DES、Blowfish 或 MD5 加密的字符串。 \r\n  crc32() 计算一个字符串的 crc32 多项式。 \r\n  count_chars() 返回字符串所用字符的信息。 \r\n  convert_uuencode() 使用 uuencode 算法对字符串进行编码。 \r\n  convert_uudecode() 对 uuencode 编码的字符串进行解码。 \r\n  convert_cyr_string() 把字符由一种 Cyrillic 字符转换成另一种。 \r\n  chunk_split() 把字符串分割为一连串更小的部分。 \r\n  chr() 从指定的 ASCII 值返回字符。 \r\n  chop() 从字符串的末端开始删除空白字符或其他预定义字符。 \r\n  bin2hex() 把 ASCII 字符的字符串转换为十六进制值。 \r\n  addslashes() 在指定的预定义字符前添加反斜杠。 \r\n  addcslashes() 在指定的字符前添加反斜杠。 \r\n  xpath() 运行对 XML 文档的 XPath 查询。 \r\n  simplexml_load_string() 把 XML 字符串载入对象中。 \r\n  simplexml_load_file() 把 XML 文档载入对象中。 \r\n  simplexml_import_dom() 把 DOM 节点转换为 SimpleXMLElement 对象。 \r\n  registerXPathNamespace() 为下一次 XPath 查询创建命名空间语境。 \r\n  getNamespace() 获取在 XML 文档中使用的命名空间。 \r\n  getName() 从 SimpleXMLElement 对象获取 XML 元素的名称。 \r\n  getDocNamespaces() 从 SimpleXMLElement 对象返回在 XML 文档中声明的命名空间。 \r\n  children() 获取指定节点的子节点。 \r\n  attributes() 获取 SimpleXML 元素的属性。 \r\n  asXML() 以字符串的形式从 SimpleXMLElement 对象返回 XML 文档。 \r\n  addChild() 向指定的 XML 节点添加一个子节点。 \r\n  addAttribute() 给 SimpleXML 元素添加一个属性。 \r\n  __construct() 创建一个新的 SimpleXMLElement 对象。 \r\n  mysql_unbuffered_query() 向 MySQL 发送一条 SQL 查询（不获取 / 缓存结果）。 \r\n  mysql_thread_id() 返回当前线程的 ID。 \r\n  mysql_stat() 返回 MySQL 服务器的当前系统状态。 \r\n  mysql_select_db() 设置活动的 MySQL 数据库。 \r\n  mysql_result() 返回结果集中一个字段的值。 \r\n  mysql_real_escape_string() 转义 SQL 语句中使用的字符串中的特殊字符。 \r\n  mysql_query() 执行一条 MySQL 查询。 \r\n  mysql_ping() Ping 一个服务器连接，如果没有连接则重新连接。 \r\n  mysql_pconnect() 打开一个到 MySQL 服务器的持久连接。 \r\n  mysql_num_rows() 返回结果集中行的数目。 \r\n  mysql_num_fields() 返回结果集中字段的数。 \r\n  mysql_list_processes() 列出 MySQL 进程。 \r\n  mysql_list_dbs() 列出 MySQL 服务器中所有的数据库。 \r\n  mysql_insert_id() 返回上一步 INSERT 操作产生的 ID。 \r\n  mysql_info() 返回最近一条查询的信息。 \r\n  mysql_get_server_info() 返回 MySQL 服务器的信息。 \r\n  mysql_get_proto_info() 返回 MySQL 协议的信息。 \r\n  mysql_get_host_info() 返回 MySQL 主机的信息。 \r\n  mysql_get_client_info() 返回 MySQL 客户端信息。 \r\n  mysql_free_result() 释放结果内存。 \r\n  mysql_field_type() 返回结果集中指定字段的类型。 \r\n  mysql_field_table() 返回指定字段所在的表名。 \r\n  mysql_field_seek() 将结果集中的指针设定为指定的字段偏移量。 \r\n  mysql_field_name() 取得结果中指定字段的字段名。 \r\n  mysql_field_len() 返回指定字段的长度。 \r\n  mysql_field_flags() 从结果中取得和指定字段关联的标志。 \r\n  mysql_fetch_row() 从结果集中取得一行作为数字数组。 \r\n  mysql_fetch_object() 从结果集（记录集）中取得一行作为对象。 \r\n  mysql_fetch_lengths() 取得一行中每个字段的内容的长度。 \r\n  mysql_fetch_field() 从结果集中取得列信息并作为对象返回。 \r\n  mysql_fetch_assoc() 从结果集中取得一行作为关联数组。 \r\n  mysql_fetch_array() 从结果集中取得一行作为关联数组，或数字数组，或二者兼有 \r\n  mysql_error() 返回上一个 MySQL 操作产生的文本错误信息。 \r\n  mysql_errno() 返回上一个 MySQL 操作中的错误信息的数字编码。 \r\n  mysql_db_name() 取得 mysql_list_dbs() 调用所返回的数据库名。 \r\n  mysql_data_seek() 移动内部结果的指针。 \r\n  mysql_connect() 打开非持久的 MySQL 连接。 \r\n  mysql_close() 关闭非持久的 MySQL 连接。 \r\n  mysql_client_encoding() 返回当前连接的字符集的名称。 \r\n  mysql_affected_rows() 返回前一次 MySQL 操作所影响的记录行数。 \r\n  tanh() 返回双曲正切。 \r\n  tan() 返回正切。 \r\n  srand() 播下随机数发生器种子。 \r\n  sqrt() 返回一个数的平方根。 \r\n  sinh() 返回一个数的双曲正弦。 \r\n  sin() 返回一个数的正弦。 \r\n  round() 对浮点数进行四舍五入。 \r\n  rand() 返回随机整数。 \r\n  rad2deg() 把弧度数转换为角度数。 \r\n  pow() 返回 x 的 y 次方。 \r\n  pi() 返回圆周率的值。 \r\n  octdec() 把八进制转换为十进制。 \r\n  mt_srand() 播种 Mersenne Twister 随机数生成器。 \r\n  mt_rand() 使用 Mersenne Twister 算法返回随机整数。 \r\n  mt_getrandmax() 显示随机数的最大可能值。 \r\n  min() 返回最小值。 \r\n  max() 返回最大值。 \r\n  log1p() 以返回 log(1 + x)，甚至当 x 的值接近零也能计算出准确结果。 \r\n  log10() 以 10 为底的对数。 \r\n  log() 返回自然对数。 \r\n  lcg_value() 组合线性同余发生器。 \r\n  is_nan() 判断是否为合法数值。 \r\n  is_infinite() 判断是否为无限值。 \r\n  is_finite() 判断是否为有限值。 \r\n  hypot() 计算一直角三角形的斜边长度。 \r\n  hexdec() 把十六进制转换为十进制。 \r\n  fmod() 显示随机数最大的可能值。 \r\n  fmod() 返回除法的浮点数余数。 \r\n  floor() 向下舍入为最接近的整数。 \r\n  expm1() 返回 exp(x) - 1，甚至当 number 的值接近零也能计算出准确结果。 \r\n  exp() 计算 e 的指数。 \r\n  deg2rad() 将角度转换为弧度。 \r\n  decoct() 把十进制转换为八进制。 \r\n  dechex() 把十进制转换为十六进制。 \r\n  decbin() 把十进制转换为二进制。 \r\n  cosh() 返回一个数的双曲余弦。 \r\n  cos() 返回一个数的余弦。 \r\n  ceil() 向上舍入为最接近的整数。 \r\n  bindec() 把二进制转换为十进制。 \r\n  base_convert() 在任意进制之间转换数字。 \r\n  atanh() 返回一个角度的反双曲正切。 \r\n  atan() 和 atan2() 和 atan2() 函数 \r\n  atan() 和 atan2() 和 atan2() 函数 \r\n  asinh() 返回一个数的反双曲正弦。 \r\n  asin() 返回不同数值的反正弦，返回的结果是介于 -PI/2 与 PI/2 之间的弧度值。 \r\n  acosh() 返回一个数的反双曲余弦。 \r\n  acos() 返回一个数的反余弦。 \r\n  abs() 返回一个数的绝对值。 \r\n  mail() 允许您从脚本中直接发送电子邮件。 \r\n  libxml_use_internal_errors() 禁用标准的 libxml 错误，并启用用户错误处理。 \r\n  libxml_get_last_error() 从 libxml 错误缓冲中获取最后一个错误。 \r\n  libxml_get_errors() 从 libxml 错误缓冲中获取错误。 \r\n  libxml_clear_errors() 清空 libxml 错误缓冲。 \r\n  setrawcookie() 不对 cookie 值进行 URL 编码，发送一个 HTTP cookie。 \r\n  setcookie() 向客户端发送一个 HTTP cookie。 \r\n  headers_sent() 检查 HTTP 报头是否发送/已发送到何处。 \r\n  headers_list() 返回已发送的（或待发送的）响应头部的一个列表。 \r\n  header() 向客户端发送原始的 HTTP 报头。 \r\n  ftp_systype() 返回远程 FTP 服务器的系统类型标识符。 \r\n  ftp_ssl_connect() 打开一个安全的 SSL-FTP 连接。 \r\n  ftp_size() 返回指定文件的大小。 \r\n  ftp_site() 向服务器发送 SITE 命令。 \r\n  ftp_set_option() 设置各种 FTP 运行时选项。 \r\n  ftp_rmdir() 删除一个目录。 \r\n  ftp_rename() 更改 FTP 服务器上的文件或目录名。 \r\n  ftp_rawlist() 返回指定目录中文件的详细列表。 \r\n  ftp_raw() 向 FTP 服务器发送一个 raw 命令。 \r\n  ftp_quit() 关闭 FTP 连接。 \r\n  ftp_pwd() 返回当前目录名。 \r\n  ftp_put() 把文件上传到服务器。 \r\n  ftp_pasv() 把被动模式设置为打开或关闭。 \r\n  ftp_nlist() 返回指定目录的文件列表。 \r\n  ftp_nb_put() 把文件上传到服务器 (non-blocking)。 \r\n  ftp_nb_get() 从 FTP 服务器上获取文件并写入本地文件 (non-blocking)。 \r\n  ftp_nb_fput() 上传一个已打开的文件，并在 FTP 服务器上把它保存为文件 (non-blocking)。 \r\n  ftp_nb_fget() 从 FTP 服务器上下载一个文件并保存到本地已经打开的一个文件中 (non-blocking)。 \r\n  ftp_nb_continue() 连续获取 / 发送文件。 \r\n  ftp_mkdir() 在 FTP 服务器上建立新目录。 \r\n  ftp_mdtm() 返回指定文件的最后修改时间。 \r\n  ftp_login() 登录 FTP 服务器。 \r\n  ftp_get() 从 FTP 服务器上下载一个文件。 \r\n  ftp_get_option() 返回当前 FTP 连接的各种不同的选项设置。 \r\n  ftp_fput() 上传一个已经打开的文件到 FTP 服务器。 \r\n  ftp_fget() 从 FTP 服务器上下载一个文件并保存到本地一个已经打开的文件中。 \r\n  ftp_exec() 请求在 FTP 服务器上执行一个程序或命令。 \r\n  ftp_delete() 删除 FTP 服务器上的一个文件。 \r\n  ftp_connect() 建立一个新的 FTP 连接。 \r\n  ftp_close() 关闭 FTP 连接。 \r\n  ftp_chmod() 设置 FTP 服务器上指定文件的权限。 \r\n  ftp_chdir() 改变 FTP 服务器上的当前目录。 \r\n  ftp_cdup() 把当前目录改变为 FTP 服务器上的父目录。 \r\n  ftp_alloc() 为要上传到 FTP 服务器的文件分配空间。 \r\n  filter_var() 通过指定的过滤器过滤变量。 \r\n  filter_var_array() 获取多项变量，并进行过滤。 \r\n  filter_list() 返回包含所有得到支持的过滤器的一个数组。 \r\n  filter_input_array() 从脚本外部获取多项输入，并进行过滤。 \r\n  filter_input() 从脚本外部获取输入，并进行过滤。 \r\n  filter_id() 返回指定过滤器的 ID 号。 \r\n  filter_has_var() 检查是否存在指定输入类型的变量。 \r\n  unlink() 删除文件。 \r\n  umask() 改变当前的 umask。 \r\n  touch() 设置指定文件的访问和修改时间。 \r\n  tmpfile() 以读写（w+）模式建立一个具有唯一文件名的临时文件。 \r\n  tempnam() 创建一个具有唯一文件名的临时文件。 \r\n  symlink() 创建符号连接。 \r\n  stat() 返回关于文件的信息。 \r\n  set_file_buffer() 设置打开文件的缓冲大小。 \r\n  rmdir() 删除空的目录。 \r\n  rewind() 将文件指针的位置倒回文件的开头。 \r\n  rename() 重命名文件或目录。 \r\n  realpath() 返回绝对路径。 \r\n  readlink() 返回符号连接指向的目标。 \r\n  readfile() 输出一个文件。 \r\n  popen() 打开进程文件指针。 \r\n  pclose() 关闭由 popen() 打开的管道。 \r\n  pathinfo() 以数组的形式返回文件路径的信息。 \r\n  parse_ini_file() 解析一个配置文件，并以数组的形式返回其中的设置。 \r\n  move_uploaded_file() 将上传的文件移动到新位置。 \r\n  mkdir() 创建目录。 \r\n  lstat() 返回关于文件或符号连接的信息。 \r\n  linkinfo() 返回连接的信息。 \r\n  link() 建立一个硬连接。 \r\n  is_writeable() 判断指定的文件是否可写。 \r\n  is_writable() 判断指定的文件是否可写。 \r\n  is_uploaded_file() 判断指定的文件是否是通过 HTTP POST 上传的。 \r\n  is_readable() 判断指定文件名是否可读。 \r\n  is_link() 判断指定文件名是否为一个符号连接。 \r\n  is_file() 检查指定的文件名是否是正常的文件。 \r\n  is_executable() 检查指定的文件是否可执行。 \r\n  is_dir() 检查指定的文件是否是目录。 \r\n  glob() 返回匹配指定模式的文件名或目录。 \r\n  fwrite() 写入文件（可安全用于二进制文件）。 \r\n  ftruncate() 把文件截断到指定的长度。 \r\n  ftell() 在打开文件中的当前位置。 \r\n  fstat() 返回关于打开文件的信息。 \r\n  fseek() 在打开的文件中定位。 \r\n  fscanf() 根据指定的格式对来自打开的文件的输入进行解析。 \r\n  fread() 读取文件（可安全用于二进制文件）。 \r\n  fputs() 写入文件（可安全用于二进制文件）。 \r\n  fputcsv() 将行格式化为 CSV 并写入一个打开的文件。 \r\n  fpassthru() 输出文件指针处的所有剩余数据。 \r\n  fopen() 打开文件或者 URL。 \r\n  fnmatch() 根据指定的模式来匹配文件名或字符串。 \r\n  flock() 锁定或释放文件。 \r\n  filetype() 返回指定文件或目录的类型。 \r\n  filesize() 返回指定文件的大小。 \r\n  fileperms() 返回文件或目录的权限。 \r\n  fileowner() 返回文件的所有者。 \r\n  filemtime() 返回文件内容上次的修改时间。 \r\n  fileinode() 返回文件的 inode 编号。 \r\n  filegroup() 返回指定文件的组 ID。 \r\n  filectime() 返回指定文件的上次 inode 修改时间。 \r\n  fileatime() 返回指定文件的上次访问时间。 \r\n  file_put_contents() 把一个字符串写入文件中。 \r\n  file_get_contents() 把整个文件读入一个字符串中。 \r\n  file_exists() 检查文件或目录是否存在。 \r\n  file() 把整个文件读入一个数组中。 \r\n  fgetss() 从打开的文件中读取一行并过滤掉 HTML 和 PHP 标记。 \r\n  fgets() 从文件指针中读取一行。 \r\n  fgetcsv() 从文件指针中读入一行并解析 CSV 字段。 \r\n  fgetc() 从文件指针中读取一个字符。 \r\n  fflush() 将缓冲内容输出到文件。 \r\n  feof() 检测是否已到达文件末尾 (eof)。 \r\n  fclose() 关闭一个打开文件。 \r\n  diskfreespace() 返回目录中的可用空间。该函数是disk_free_space()函数的别名。 \r\n  disk_total_space() 返回指定目录的磁盘总大小。 \r\n  disk_free_space() 返回目录中的可用空间 \r\n  dirname() 返回路径中的目录部分。 \r\n  clearstatcache() 拷贝文件。 \r\n  clearstatcache() 清除文件状态缓存。 \r\n  chown() 改变指定文件的所有者。 \r\n  chmod() 改变文件模式。 \r\n  chgrp() 改变文件所属的组。 \r\n  basename() 返回路径中的文件名部分。 \r\n  set_exception_handler() handler() 函数 \r\n  set_exception_handler() 设置用户自定义的异常处理函数。 \r\n  set_error_handler() 设置用户自定义的错误处理函数。 \r\n  restore_exception_handler() 恢复之前的异常处理程序，该程序是由 set_exception_handler() 函数改变的。 \r\n  restore_error_handler() 恢复之前的错误处理程序，该程序是由 set_error_handler() 函数改变的。 \r\n  error_reporting() 设置 PHP 的报错级别并返回当前级别。 \r\n  error_log() 向服务器错误记录、文件或远程目标发送一个错误。 \r\n  error_get_last() 获取最后发生的错误。 \r\n  debug_print_backtrace() 输出 backtrace。 \r\n  debug_backtrace() cktrace() 函数 \r\n  scandir() 返回一个数组，其中包含指定路径中的文件和目录。 \r\n  rewinddir() 重置由 opendir() 打开的目录句柄。 \r\n  readdir() 返回由 opendir() 打开的目录句柄中的条目。 \r\n  opendir() 打开一个目录句柄，可由 closedir()，readdir() 和 rewinddir() 使用。 \r\n  getcwd() 返回当前目录。 \r\n  closedir() 关闭由 opendir() 函数打开的目录句柄。 \r\n  dir() 打开一个目录句柄，并返回一个对象。这个对象包含三个方法：read() , rewind() 以及 close()。 \r\n  chroot() 把当前进程的根目录改变为指定的目录。 \r\n  chdir() 把当前的目录改变为指定的目录。 \r\n  time() 返回当前时间的 Unix 时间戳。 \r\n  strtotime() 将任何英文文本的日期时间描述解析为 Unix 时间戳。 \r\n  strptime() 解析由strftime()生成的日期／时间。 \r\n  strftime() 根据区域设置格式化本地时间／日期。 \r\n  mktime() 返回一个日期的 Unix 时间戳。 \r\n  microtime() 返回当前 Unix 时间戳和微秒数。 \r\n  localtime() 返回本地时间（一个数组）。 \r\n  idate() 将本地时间/日期格式化为整数。 \r\n  gmstrftime() 根据本地区域设置格式化 GMT/UTC 时间／日期。 \r\n  gmmktime() 取得 GMT 日期的 UNIX 时间戳。 \r\n  gmdate() 格式化 GMT/UTC 日期/时间。 \r\n  gettimeofday() 返回一个包含当前时间信息的数组。 \r\n  getdate() 取得日期／时间信息。 \r\n  date() 格式化一个本地时间／日期。 \r\n  date_sunset() 返回指定的日期与地点的日落时间。 \r\n  date_sunrise() 返回指定的日期与地点的日出时间。 \r\n  date_default_timezone_set() 设置用在脚本中所有日期/时间函数的默认时区。 \r\n  date_default_timezone_get() 返回脚本中所有日期时间函数所使用的默认时区。 \r\n  checkdate() 验证一个格里高里日期。 \r\n  UnixToJD() 把 Unix 时间戳转换为儒略日计数。 \r\n  JulianToJD() 把儒略历转换为儒略日计数。 \r\n  JewishToJD() 把犹太历法转换为儒略日计数。 \r\n  JDToUnix() 把儒略日计数转换为 Unix 时间戳。 \r\n  JDToGregorian() lian() 函数 \r\n  JDToGregorian() wish() 函数 \r\n  JDToGregorian() 把儒略日计数转换为格利高里历法。 \r\n  JDToFrench() 把儒略日计数转换为法国共和国历法。 \r\n  JDMonthName() 返回指定历法的月份字符串。 \r\n  JDDayOfWeek() 返回日期在周几。 \r\n  GregorianToJD() 将格利高里历法转换成为儒略日计数。 \r\n  FrenchToJD() 将法国共和历法转换成为儒略日计数。 \r\n  easter_days() 返回指定年份的复活节与 3 月 21 日之间的天数。 \r\n  easter_date() 返回指定年份的复活节午夜的 Unix 时间戳。 \r\n  cal_to_jd() 把指定的日期转换为儒略日计数。 \r\n  cal_info() 返回一个数组，其中包含了关于给定历法的信息。 \r\n  cal_from_jd() 把儒略日计数转换为指定历法的日期。 \r\n  cal_days_in_month() 针对指定的年份和日历，返回一个月中的天数。 \r\n  usort() 使用用户自定义的函数对数组排序。 \r\n  uksort() 使用用户自定义的比较函数按照键名对数组排序，并保持索引关系。 \r\n  uasort() 使用用户自定义的比较函数对数组排序，并保持索引关联（不为元素分配新的键）。 \r\n  sort() 按升序对给定数组的值排序。 \r\n  sizeof() 计算数组中的单元数目或对象中的属性个数。 \r\n  shuffle() 把数组中的元素按随机顺序重新排列。 \r\n  rsort() 对数组的元素按照键值进行逆向排序。与arsort()的功能基本相同。 \r\n  reset() 把数组的内部指针指向第一个元素，并返回这个元素的值。 \r\n  range() 创建并返回一个包含指定范围的元素的数组。 \r\n  prev() HP prev() 函数 \r\n  pos() 是current() 函数的别名。它可返回数组中当前元素的值。 \r\n  next() 把指向当前元素的指针移动到下一个元素的位置，并返回当前元素的值。 \r\n  natsort() 用自然顺序算法对给定数组中的元素排序。 \r\n  natcasesort() 用不区分大小写的自然顺序算法对给定数组中的元素排序。 \r\n  list() 用数组中的元素为一组变量赋值。 \r\n  ksort() 按照键名对数组排序，为数组值保留原来的键。 \r\n  krsort() 将数组按照键逆向排序，为数组值保留原来的键。 \r\n  key() 返回数组内部指针当前指向元素的键名。 \r\n  in_array() 在数组中搜索给定的值。 \r\n  extract() extract() 函数 \r\n  end() 将数组内部指针指向最后一个元素，并返回该元素的值（如果成功）。 \r\n  each() 生成一个由数组当前内部指针所指向的元素的键名和键值组成的数组，并把内部指针向前移动。 \r\n  current() 返回数组中的当前元素（单元）。 \r\n  count() 计算数组中的单元数目或对象中的属性个数。 \r\n  compact() 创建一个由参数所带变量组成的数组。如果参数中存在数组，该数组中变量的值也会被获取。 \r\n  asort() 对数组进行排序并保持索引关系。主要用于对那些单元顺序很重要的结合数组进行排序。 \r\n  arsort() 对数组进行逆向排序并保持索引关系。主要用于对那些单元顺序很重要的结合数组进行排序。 \r\n  array_walk_recursive() cursive() 函数 \r\n  array_walk() 对数组中的每个元素应用回调函数。如果成功则返回 TRUE，否则返回 FALSE。 \r\n  array_values() 返回一个包含给定数组中所有键值的数组，但不保留键名。 \r\n  array_unshift() 在数组开头插入一个或多个元素。 \r\n  array_unique() 移除数组中的重复的值，并返回结果数组。 \r\n  array_uintersect_assoc() 带索引检查计算数组的交集，用回调函数比较数据。 \r\n  array_uintersect() 计算数组的交集，用回调函数比较数据。 \r\n  array_udiff_uassoc() 返回 array1 数组中存在但其它数组中都不存在的部分。返回的数组中键名保持不变。 \r\n  array_udiff_assoc() 返回 array1 中存在但其它数组中都不存在的部分。 \r\n  array_udiff() 返回一个数组，该数组包括了所有在被比较数组中，但是不在任何其它参数数组中的值，键名保留不变。 \r\n  array_sum() 返回数组中所有值的总和。 \r\n  array_splice() 与 array_slice() 函数类似，选择数组中的一系列元素，但不返回，而是删除它们并用其它值代替。 \r\n  array_slice() 在数组中根据条件取出一段值，并返回。 \r\n  array_shift() 删除数组中的第一个元素，并返回被删除元素的值。 \r\n  array_search() 与in_array()一样，在数组中查找一个键值。如果找到了该值，匹配元素的键名会被返回。如果没找到，则返回 false。 \r\n  array_reverse() 将原数组中的元素顺序翻转，创建新的数组并返回。如果第二个参数指定为 true，则元素的键名保持不变，否则键名将丢失。 \r\n  array_reduce() 用回调函数迭代地将数组简化为单一的值。如果指定第三个参数，则该参数将被当成是数组中的第一个值来处理，或者如果数组为空的话就作为最终返回值。 \r\n  array_rand() 从数组中随机选出一个或多个元素，并返回。 \r\n  array_push() 向第一个参数的数组尾部添加一个或多个元素（入栈），然后返回新数组的长度。 \r\n  array_product() 计算并返回数组中所有值的乘积。 \r\n  array_pad() 向一个数组插入带有指定值的指定数量的元素。 \r\n  array_merge() 把两个或多个数组合并为一个数组。 \r\n  array_map() 返回用户自定义函数作用后的数组。回调函数接受的参数数目应该和传递给 array_map() 函数的数组数目一致。 \r\n  array_keys() 返回包含数组中所有键名的一个新数组。 \r\n  array_key_exists() 判断某个数组中是否存在指定的 key，如果该 key 存在，则返回 true，否则返回 false。 \r\n  array_intersect_ukey() 用回调函数比较键名来计算数组的交集。 \r\n  array_intersect_uassoc() 使用用户自定义的回调函数计算数组的交集，用回调函数比较索引。 \r\n  array_intersect_key() 使用键名比较计算数组的交集。 \r\n  array_intersect_assoc() 返回两个或多个数组的交集数组。 \r\n  array_intersect() 返回两个或多个数组的交集数组。 \r\n  array_flip() 返回一个反转后的数组，如果同一值出现了多次，则最后一个键名将作为它的值，所有其他的键名都将丢失。 \r\n  array_filter() 用回调函数过滤数组中的元素，如果自定义过滤函数返回 true，则被操作的数组的当前值就会被包含在返回的结果数组中， 并将结果组成一个新的数组。如果原数组是一个关联数组，键名保持不变。 \r\n  array_fill() 用给定的值填充数组，返回的数组有 number 个元素，值为 value。返回的数组使用数字索引，从 start 位置开始并递增。如果 number 为 0 或小于 0，就会出错。 \r\n  array_diff_ukey() 返回一个数组，该数组包括了所有出现在 array1 中但是未出现在任何其它参数数组中的键名的值。注意关联关系保留不变。与 array_diff() 不同的是，比较是根据键名而不是值来进行的。 \r\n  array_diff_uassoc() 使用用户自定义的回调函数 (callback) 做索引检查来计算两个或多个数组的差集。返回一个数组，该数组包括了在 array1 中但是不在任何其他参数数组中的值。 \r\n  array_diff_key() 返回一个数组，该数组包括了所有在被比较的数组中，但是不在任何其他参数数组中的键。 \r\n  array_diff_assoc() 返回两个数组的差集数组。该数组包括了所有在被比较的数组中，但是不在任何其他参数数组中的键和值。 \r\n  array_diff() 返回两个数组的差集数组。该数组包括了所有在被比较的数组中，但是不在任何其他参数数组中的键值。 \r\n  array_count_values() 用于统计数组中所有值出现的次数。 \r\n  array_combine() 通过合并两个数组来创建一个新数组，其中的一个数组是键名，另一个数组的值为键值。 \r\n  array_chunk() 把一个数组分割为新的数组块。 \r\n  array_change_key_case() 将数组的所有的 KEY 都转换为大写或小写。 \r\n  array() 创建数组，带有键和值。如果在规定数组时省略了键，则生成一个整数键，这个 key 从 0 开始，然后以 1 进行递增。 \r\n  \n',''),(40,'rsync','rsync rsync -rogpav --delete /home /tmp 同步两边的目录\nrsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync\nrsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录\nrsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录\n',''),(41,'yum','yum YUM 软件包升级器 - （Fedora, RedHat及类似系统）\nyum install package_name 下载并安装一个rpm包\nyum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系\nyum update package_name.rpm 更新当前系统中所有安装的rpm包\nyum update package_name 更新一个rpm包\nyum remove package_name 删除一个rpm包\nyum list 列出当前系统中安装的所有包\nyum search package_name 在rpm仓库中搜寻软件包\nyum clean packages 清理rpm缓存删除下载的包\nyum clean headers 删除所有头文件\nyum clean all 删除所有缓存的包和头文件\n',''),(30,'dd','\ndd bs=1M if=/dev/hda | gzip | ssh user@ip_addr \'dd of=hda.gz\' 通过ssh在远程主机上执行一次备份本地磁盘的操作\ndd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件\ndd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作\ndd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容\ndd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD\n',''),(31,'sed','sed sed 使用说明书 \r\n  是一个很好的文件处理工具，本身是一个管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作，下面先了解一下sed的用法 \r\n  sed命令行格式为： \r\n           sed [-nefri] ‘command’ 输入文本        \r\n   \r\n  常用选项： \r\n          -n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。 \r\n          -e∶直接在指令列模式上进行 sed 的动作编辑； \r\n          -f∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作； \r\n          -r∶sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法) \r\n          -i∶直接修改读取的档案内容，而不是由萤幕输出。       \r\n   \r\n  常用命令： \r\n          a   ∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～ \r\n          c   ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ \r\n          d   ∶删除，因为是删除啊，所以 d 后面通常不接任何咚咚； \r\n           i   ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； \r\n           p  ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～ \r\n           s  ∶取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ \r\n   \r\n  举例：（假设我们有一文件名为ab） \r\n       删除某行 \r\n       [root@localhost ruby] # sed \'1d\' ab              #删除第一行 \r\n       [root@localhost ruby] # sed \'$d\' ab              #删除最后一行 \r\n       [root@localhost ruby] # sed \'1,2d\' ab           #删除第一行到第二行 \r\n       [root@localhost ruby] # sed \'2,$d\' ab           #删除第二行到最后一行 \r\n   \r\n  　　显示某行 \r\n  .    [root@localhost ruby] # sed -n \'1p\' ab           #显示第一行 \r\n       [root@localhost ruby] # sed -n \'$p\' ab           #显示最后一行 \r\n       [root@localhost ruby] # sed -n \'1,2p\' ab        #显示第一行到第二行 \r\n       [root@localhost ruby] # sed -n \'2,$p\' ab        #显示第二行到最后一行 \r\n   \r\n  　　使用模式进行查询 \r\n       [root@localhost ruby] # sed -n \'/ruby/p\' ab    #查询包括关键字ruby所在所有行 \r\n       [root@localhost ruby] # sed -n \'/\\$/p\' ab        #查询包括关键字$所在所有行，使用反斜线\\屏蔽特殊含义 \r\n   \r\n  　　增加一行或多行字符串 \r\n       [root@localhost ruby]# cat ab \r\n       Hello!  \r\n       ruby is me,welcome to my blog.  \r\n       end \r\n       [root@localhost ruby] # sed \'1a drink tea\' ab  #第一行后增加字符串\"drink tea\" \r\n       Hello!  \r\n       drink tea \r\n       ruby is me,welcome to my blog.  \r\n       end \r\n       [root@localhost ruby] # sed \'1,3a drink tea\' ab #第一行到第三行后增加字符串\"drink tea\" \r\n       Hello!  \r\n       drink tea \r\n       ruby is me,welcome to my blog.  \r\n       drink tea \r\n       end \r\n       drink tea \r\n       [root@localhost ruby] # sed \'1a drink tea\r\nor coffee\' ab   #第一行后增加多行，使用换行符\r\n \r\n       Hello!  \r\n       drink tea \r\n       or coffee \r\n       ruby is me,welcome to my blog.  \r\n       end \r\n   \r\n  　　代替一行或多行 \r\n       [root@localhost ruby] # sed \'1c Hi\' ab                #第一行代替为Hi \r\n       Hi \r\n       ruby is me,welcome to my blog.  \r\n       end \r\n       [root@localhost ruby] # sed \'1,2c Hi\' ab             #第一行到第二行代替为Hi \r\n       Hi \r\n       end \r\n   \r\n  　　替换一行中的某部分 \r\n  　　格式：sed \'s/要替换的字符串/新的字符串/g\'   （要替换的字符串可以用正则表达式） \r\n       [root@localhost ruby] # sed -n \'/ruby/p\' ab | sed \'s/ruby/bird/g\'    #替换ruby为bird \r\n  　  [root@localhost ruby] # sed -n \'/ruby/p\' ab | sed \'s/ruby\n   \r\n       插入 \r\n       [root@localhost ruby] # sed -i \'$a bye\' ab         #在文件ab中最后一行直接输入\"bye\" \r\n       [root@localhost ruby]# cat ab \r\n       Hello!  \r\n       ruby is me,welcome to my blog.  \r\n       end \r\n       bye\nsed \'s/stringa1/stringa2/g\' example.txt 将example.txt文件中的 \"string1\" 替换成 \"string2\"\nsed \'/^$/d\' example.txt 从example.txt文件中删除所有空白行\nsed \'/ *#/d; /^$/d\' example.txt 从example.txt文件中删除所有注释和空白行\nsed -e \'1d\' result.txt 从文件example.txt 中排除第一行\nsed -n \'/stringa1/p\' 查看只包含词汇 \"string1\"的行\nsed -e \'s/ *$//\' example.txt 删除每一行最后的空白字符\nsed -e \'s/stringa1//g\' example.txt 从文档中只删除词汇 \"string1\" 并保留剩余全部\nsed -n \'1,5p;5q\' example.txt 查看从第一行到第5行内容\nsed -n \'5p;5q\' example.txt 查看第5行\nsed -e \'s/00*/0/g\' example.txt 用单个零替换多个零\n','//g\'        #删除ruby \r'),(32,'awk','awk awk 使用说明书\r\n \r\n  变量名 含义 \r\n  ARGC 命令行变元个数 \r\n  ARGV 命令行变元数组 \r\n  FILENAME当前输入文件名 \r\n  FNR 当前文件中的记录号 \r\n  fSum 输入域分隔符，默认为一个空格 \r\n  RS 输入记录分隔符 \r\n  NF 当前记录里域个数 \r\n  NR 到目前为止记录数 \r\n  OFS 输出域分隔符 \r\n  ORS 输出记录分隔符 \r\n   \r\n  1、awk \'/101/\'               file 显示文件file中包含101的匹配行。 \r\n     awk \'/101/,/105/\'         file \r\n     awk \'$1 == 5\'             file \r\n     awk \'$1 == \"CT\"\'          file 注意必须带双引号 \r\n     awk \'$1 * $2 >100 \'       file  \r\n     awk \'$2 >5 && $2<=15\'     file \r\n   \r\n   \r\n  2、awk \'{print NR,NF,$1,$NF,}\' file 显示文件file的当前记录号、域数和每一行的第一个和最后一个域。 \r\n     awk \'/101/ {print $1,$2 + 10}\' file 显示文件file的匹配行的第一、二个域加10。 \r\n     awk \'/101/ {print $1$2}\'  file \r\n     awk \'/101/ {print $1 $2}\' file 显示文件file的匹配行的第一、二个域，但显示时域中间没有分隔符。 \r\n   \r\n   \r\n  3、df | awk \'$4>1000000 \'         通过管道符获得输入，如：显示第4个域满足条件的行。 \r\n   \r\n   \r\n  4、awk -F \"|\" \'{print $1}\'   file 按照新的分隔符“|”进行操作。 \r\n     awk  \'BEGIN { FS=\"[:   |]\" } \r\n     {print $1,$2,$3}\'         file 通过设置输入分隔符（FS=\"[:   |]\"）修改输入分隔符。 \r\n   \r\n     Sep=\"|\" \r\n     awk -F $Sep \'{print $1}\'  file 按照环境变量Sep的值做为分隔符。    \r\n     awk -F \'[ :  |]\' \'{print $1}\' file 按照正则表达式的值做为分隔符，这里代表空格、:、TAB、|同时做为分隔符。 \r\n     awk -F \'[][]\'    \'{print $1}\' file 按照正则表达式的值做为分隔符，这里代表[、] \r\n   \r\n   \r\n  5、awk -f awkfile        file 通过文件awkfile的内容依次进行控制。 \r\n     cat awkfile \r\n  /101/{print \"\\047 Hello! \\047\"} --遇到匹配行以后打印 \' Hello! \'.\\047代表单引号。 \r\n  {print $1,$2}                   --因为没有模式控制，打印每一行的前两个域。 \r\n   \r\n   \r\n  6、awk \'$1 ~ /101/ {print $1}\' file 显示文件中第一个域匹配101的行（记录）。 \r\n   \r\n   \r\n  7、awk   \'BEGIN { OFS=\"%\"} \r\n     {print $1,$2}\'           file 通过设置输出分隔符（OFS=\"%\"）修改输出格式。 \r\n   \r\n   \r\n  8、awk   \'BEGIN { max=100 ;print \"max=\" max}             BEGIN 表示在处理任意行之前进行的操作。 \r\n     {max=($1 >max ?$1:max); print $1,\"Now max is \"max}\' file 取得文件第一个域的最大值。 \r\n     （表达式1?表达式2:表达式3 相当于： \r\n     if (表达式1) \r\n         表达式2 \r\n     else \r\n         表达式3 \r\n     awk \'{print ($1>4 ? \"high \"$1: \"low \"$1)}\' file \r\n   \r\n   \r\n  9、awk \'$1 * $2 >100 {print $1}\' file 显示文件中第一个域匹配101的行（记录）。 \r\n   \r\n   \r\n  10、awk \'{$1 == \'Chi\' {$3 = \'China\'; print}\' file 找到匹配行后先将第3个域替换后再显示该行（记录）。 \r\n      awk \'{$7 %= 3; print $7}\'  file 将第7域被3除，并将余数赋给第7域再打印。 \r\n   \r\n   \r\n  11、awk \'/tom/ {wage=$2+$3; printf wage}\' file 找到匹配行后为变量wage赋值并打印该变量。 \r\n   \r\n   \r\n  12、awk \'/tom/ {count++;}  \r\n           END {print \"tom was found \"count\" times\"}\' file END表示在所有输入行处理完后进行处理。 \r\n   \r\n   \r\n  13、awk \'gsub(/\\$/,\"\");gsub(/,/,\"\"); cost+=$4; \r\n           END {print \"The total is $\" cost>\"filename\"}\'    file gsub函数用空串替换$和,再将结果输出到filename中。 \r\n      1 2 3 $1,200.00 \r\n      1 2 3 $2,300.00 \r\n      1 2 3 $4,000.00 \r\n   \r\n      awk \'{gsub(/\\$/,\"\");gsub(/,/,\"\"); \r\n      if ($4>1000&&$4<2000) c1+=$4; \r\n      else if ($4>2000&&$4<3000) c2+=$4; \r\n      else if ($4>3000&&$4<4000) c3+=$4; \r\n      else c4+=$4; } \r\n      END {printf  \"c1=[%d];c2=[%d];c3=[%d];c4=[%d]\r\n\",c1,c2,c3,c4}\"\' file \r\n      通过if和else if完成条件语句 \r\n   \r\n      awk \'{gsub(/\\$/,\"\");gsub(/,/,\"\"); \r\n      if ($4>3000&&$4<4000) exit; \r\n      else c4+=$4; } \r\n      END {printf  \"c1=[%d];c2=[%d];c3=[%d];c4=[%d]\r\n\",c1,c2,c3,c4}\"\' file \r\n      通过exit在某条件时退出，但是仍执行END操作。 \r\n      awk \'{gsub(/\\$/,\"\");gsub(/,/,\"\"); \r\n      if ($4>3000) next; \r\n      else c4+=$4; } \r\n      END {printf  \"c4=[%d]\r\n\",c4}\"\' file \r\n      通过next在某条件时跳过该行，对下一行执行操作。 \r\n   \r\n   \r\n  14、awk \'{ print FILENAME,$0 }\' file1 file2 file3>fileall 把file1、file2、file3的文件内容全部写到fileall中，格式为 \r\n      打印文件并前置文件名。 \r\n   \r\n   \r\n  15、awk \' $1!=previous { close(previous); previous=$1 }    \r\n      {print substr($0,index($0,\" \") +1)>$1}\' fileall 把合并后的文件重新分拆为3个文件。并与原文件一致。 \r\n   \r\n   \r\n  16、awk \'BEGIN {\"date\"|getline d; print d}\'         通过管道把date的执行结果送给getline，并赋给变量d，然后打印。 \r\n   \r\n   \r\n  17、awk \'BEGIN {system(\"echo \\\"Input your name:\\\\c\\\"\"); getline d;print \"\r\nYour name is\",d,\"\\b!\r\n\"}\' \r\n      通过getline命令交互输入name，并显示出来。 \r\n      awk \'BEGIN {FS=\":\"; while(getline< \"/etc/passwd\" >0) { if($1~\"050[0-9]_\") print $1}}\' \r\n      打印/etc/passwd文件中用户名包含050x_的用户名。 \r\n   \r\n  18、awk \'{ i=1;while(i<NF) {print NF,$i;i++}}\' file 通过while语句实现循环。 \r\n      awk \'{ for(i=1;i<NF;i++) {print NF,$i}}\'   file 通过for语句实现循环。     \r\n      type file|awk -F \"/\" \' \r\n      { for(i=1;i<NF;i++) \r\n      { if(i==NF-1) { printf \"%s\",$i } \r\n      else { printf \"%s/\",$i } }}\'               显示一个文件的全路径。 \r\n      用for和if显示日期 \r\n      awk  \'BEGIN { \r\n  for(j=1;j<=12;j++) \r\n  { flag=0; \r\n    printf \"\r\n%d月份\r\n\",j; \r\n          for(i=1;i<=31;i++) \r\n          { \r\n          if (j==2&&i>28) flag=1; \r\n          if ((j==4||j==6||j==9||j==11)&&i>30) flag=1; \r\n          if (flag==0) {printf \"%02d%02d \",j,i} \r\n          } \r\n  } \r\n  }\' \r\n   \r\n   \r\n  19、在awk中调用系统变量必须用单引号，如果是双引号，则表示字符串 \r\n  Flag=abcd \r\n  awk \'{print \'$Flag\'}\'   结果为abcd \r\n  awk \'{print  \"$Flag\"}\'   结果为$Flag\nawk \'/^(no|so)/\' test-----打印所有以模式no或so开头的行。\nawk \'/^[ns]/{print $1}\' test-----如果记录以n或s开头，就打印这个记录。\nawk \'$1 ~/[0-9][0-9]$/(print $1}\' test-----如果第一个域以两个数字结束就打印这个记录。\nawk \'$1 == 100 || $2 < 50\' test-----如果第一个或等于100或者第二个域小于50，则打印该行。\nawk \'$1 != 10\' test-----如果第一个域不等于10就打印该行。\nawk \'/test/{print $1 + 10}\' test-----如果记录包含正则表达式test，则第一个域加10并打印出来。\nawk \'{print ($1 > 5 ? \"ok \"$1: \"error\"$1)}\' test-----如果第一个域大于5则打印问号后面的表达式值，否则打印冒号后面的表达式值。\nawk \'/^root/,/^mysql/\' test----打印以正则表达式root开头的记录到以正则表达式mysql开头的记录范围内的所有记录。如果找到一个新的正则表达式root开头的记 录，则继续打印直到下一个以正则表达式mysql开头的记录为止，或到文件末尾。\nawk \'BEGIN{total=0}{total+=$4}END{print total}\' a.txt   -----对a.txt文件的第四个域进行求和！\nawk 函数说明 \r\n  一、算术函数: \r\n   \r\n  以下算术函数执行与 C 语言中名称相同的子例程相同的操作： \r\n  函数名  说明 \r\n  atan2( y, x )   返回 y/x 的反正切。 \r\n  cos( x )    返回 x 的余弦；x 是弧度。 \r\n  sin( x )    返回 x 的正弦；x 是弧度。 \r\n  exp( x )    返回 x 幂函数。 \r\n  log( x )    返回 x 的自然对数。 \r\n  sqrt( x )   返回 x 平方根。 \r\n  int( x )    返回 x 的截断至整数的值。 \r\n  rand( )     返回任意数字 n，其中 0 <= n < 1。 \r\n  srand( [Expr] )     将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。 \r\n      举例说明： \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{OFMT=\"%.3f\";fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;}\' \r\n      0.841 22026.466 2.303 3 \r\n   \r\n   \r\n      OFMT 设置输出数据格式是保留3位小数 \r\n   \r\n      获得随机数： \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{srand();fr=int(100*rand());print fr;}\' \r\n      78 \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{srand();fr=int(100*rand());print fr;}\' \r\n      31 \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{srand();fr=int(100*rand());print fr;}\' \r\n   \r\n      41 \r\n   \r\n  二、字符串函数是： \r\n  函数    说明 \r\n  gsub( Ere, Repl, [ In ] )   除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行，。 \r\n  sub( Ere, Repl, [ In ] )    用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。 \r\n  index( String1, String2 )   在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。 \r\n  length [(String)]   返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 \r\n  blength [(String)]  返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 \r\n  substr( String, M, [ N ] )  返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。 \r\n  match( String, Ere )    在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。 \r\n  split( String, A, [Ere] )   将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。 \r\n  tolower( String )   返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 \r\n  toupper( String )   返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 \r\n  sprintf(Format, Expr, Expr, . . . )     根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。 \r\n  Ere都可以是正则表达式 \r\n   \r\n      gsub,sub使用 \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{info=\"this is a test2010test!\";gsub(/[0-9]+/,\"!\",info);print info}\'  \r\n      this is a test!test!  \r\n   \r\n       \r\n   \r\n      在 info中查找满足正则表达式，/[0-9]+/ 用””替换，并且替换后的值，赋值给info 未给info值，默认是$0 \r\n   \r\n       \r\n   \r\n      查找字符串（index使用） \r\n   \r\n      [wangsl@centos5 ~]$ awk \'BEGIN{info=\"this is a test2010test!\";print index(info,\"test\")?\"ok\":\"no found\";}\'   \r\n      ok \r\n   \r\n      未找到，返回0 \r\n   \r\n       \r\n   \r\n      正则表达式匹配查找(match使用） \r\n   \r\n      [wangsl@centos5 ~]$ awk \'BEGIN{info=\"this is a test2010test!\";print match(info,/[0-9]+/)?\"ok\":\"no found\";}\'          \r\n      ok \r\n   \r\n       \r\n   \r\n      截取字符串(substr使用） \r\n   \r\n      [wangsl@centos5 ~]$ awk \'BEGIN{info=\"this is a test2010test!\";print substr(info,4,10);}\'                        \r\n      s is a tes \r\n   \r\n      从第 4个 字符开始，截取10个长度字符串 \r\n   \r\n       \r\n   \r\n      字符串分割（split使用） \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{info=\"this is a test\";split(info,tA,\" \");print length(tA);for(k in tA){print k,tA[k];}}\' \r\n      4 \r\n      4 test \r\n      1 this \r\n      2 is \r\n      3 a \r\n   \r\n       \r\n   \r\n      分割info,动态创建数组tA,这里比较有意思，awk for …in 循环，是一个无序的循环。 并不是从数组下标1…n ，因此使用时候需要注意。 \r\n   \r\n       \r\n   \r\n      格式化字符串输出（sprintf使用） \r\n   \r\n      格式化字符串格式： \r\n   \r\n      其中格式化字符串包括两部分内容: 一部分是正常字符, 这些字符将按原样输出; 另一部分是格式化规定字符, 以\"%\"开始, 后跟一个或几个规定字符,用来确定输出内容格式。 \r\n   \r\n       \r\n      格式符  说明 \r\n      %d  十进制有符号整数 \r\n      %u  十进制无符号整数 \r\n      %f  浮点数 \r\n      %s  字符串 \r\n      %c  单个字符 \r\n      %p  指针的值 \r\n      %e  指数形式的浮点数 \r\n      %x  %X 无符号以十六进制表示的整数 \r\n      %o  无符号以八进制表示的整数 \r\n      %g  自动选择合适的表示法 \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{n1=124.113;n2=-1.224;n3=1.2345; printf(\"%.2f,%.2u,%.2g,%X,%o\r\n\",n1,n2,n3,n1,n1);}\' \r\n      124.11,18446744073709551615,1.2,7C,174 \r\n   \r\n       \r\n   \r\n  三、一般函数是： \r\n  函数    说明 \r\n  close( Expression )     用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的。 \r\n  system(Command )    执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程。 \r\n  Expression | getline [ Variable ]   从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。 \r\n  getline [ Variable ] < Expression   从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。 \r\n  getline [ Variable ]    将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量。 \r\n   \r\n   \r\n   \r\n      打开外部文件（close用法） \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{while(\"cat /etc/passwd\"|getline){print $0;};close(\"/etc/passwd\");}\' \r\n      root:x:0:0:root:/root:/bin/bash \r\n      bin:x:1:1:bin:/bin:/sbin/nologin \r\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin \r\n   \r\n       \r\n   \r\n      逐行读取外部文件(getline使用方法） \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{while(getline < \"/etc/passwd\"){print $0;};close(\"/etc/passwd\");}\' \r\n      root:x:0:0:root:/root:/bin/bash \r\n      bin:x:1:1:bin:/bin:/sbin/nologin \r\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin \r\n   \r\n       \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{print \"Enter your name:\";getline name;print name;}\' \r\n      Enter your name: \r\n      chengmo \r\n      chengmo \r\n   \r\n        \r\n   \r\n      调用外部应用程序(system使用方法） \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{b=system(\"ls -al\");print b;}\' \r\n      total 42092 \r\n      drwxr-xr-x 14 chengmo chengmo     4096 09-30 17:47 .  \r\n      drwxr-xr-x 95 root   root       4096 10-08 14:01 ..  \r\n   \r\n       \r\n   \r\n      b返回值，是执行结果。 \r\n   \r\n   \r\n   \r\n   \r\n   \r\n   \r\n   \r\n  四、时间函数 \r\n   \r\n   \r\n  函数名  说明 \r\n  mktime( YYYY MM DD HH MM SS[ DST])  生成时间格式 \r\n  strftime([format [, timestamp]])    格式化时间输出，将时间戳转为时间字符串 \r\n  具体格式，见下表.  \r\n  systime()   得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数 \r\n   \r\n   \r\n   \r\n      创建指定时间(mktime使用） \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{tstamp=mktime(\"2001 01 01 12 12 12\");print strftime(\"%c\",tstamp);}\' \r\n      2001年01月01日 星期一 12时12分12秒 \r\n   \r\n       \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{tstamp1=mktime(\"2001 01 01 12 12 12\");tstamp2=mktime(\"2001 02 01 0 0 0\");print tstamp2-tstamp1;}\' \r\n      2634468 \r\n   \r\n      求2个时间段中间时间差,介绍了strftime使用方法 \r\n   \r\n       \r\n   \r\n      [chengmo@centos5 ~]$ awk \'BEGIN{tstamp1=mktime(\"2001 01 01 12 12 12\");tstamp2=systime();print tstamp2-tstamp1;}\' \r\n      308201392 \r\n   \r\n       \r\n   \r\n      strftime日期和时间格式说明符 \r\n      格式化时间输出描述 \r\n      %a  星期几的缩写(Sun) \r\n      %A  星期几的完整写法(Sunday) \r\n      %b  月名的缩写(Oct) \r\n      %B  月名的完整写法(October) \r\n      %c  本地日期和时间 \r\n      %d  十进制日期 \r\n      %D  日期 08/20/99 \r\n      %e  日期，如果只有一位会补上一个空格 \r\n      %H  用十进制表示24小时格式的小时 \r\n      %I  用十进制表示12小时格式的小时 \r\n      %j  从1月1日起一年中的第几天 \r\n      %m  十进制表示的月份 \r\n      %M  十进制表示的分钟 \r\n      %p  12小时表示法(AM/PM) \r\n      %S  十进制表示的秒 \r\n      %U  十进制表示的一年中的第几个星期(星期天作为一个星期的开始) \r\n      %w  十进制表示的星期几(星期天是0) \r\n      %W  十进制表示的一年中的第几个星期(星期一作为一个星期的开始) \r\n      %x  重新设置本地日期(08/20/99) \r\n      %X  重新设置本地时间(12：00：00) \r\n      %y  两位数字表示的年(99) \r\n      %Y  当前月份 \r\n      %Z  时区(PDT) \r\n      %%  百分号(%)\nawk 中使用shell中的变量 \r\n   \r\n  一: \"\'$var\'\" \r\n   \r\n  这种写法大家无需改变用\'括起awk程序的习惯,是老外常用的写法.如: \r\n   \r\n  var=\"test\" \r\n  awk \'BEGIN{print \"\'$var\'\"}\' \r\n   \r\n  这种写法其实际是双括号变为单 括号的常量,传递给了awk.  \r\n   \r\n  如果var中含空格,为了shell不把空格作为分格符,便应该如下使用: \r\n   \r\n  var=\"this is a test\" \r\n  awk \'BEGIN{print \"\'\"$var\"\'\"}\' \r\n  二: \'\"$var\"\' \r\n   \r\n  这种写法与上一种类似.如果变量含空格,则变为\'\"\"$var\"\"\'较为可靠.  \r\n  三: export变量,使用ENVIRON[\"var\"]形式,获取环境变量的值 \r\n   \r\n  例如: \r\n  var=\"this is a test\"; export var; \r\n   \r\n  awk \'BEGIN{print ENVIRON[\"var\"]}\' \r\n  四:可以使用awk的-v选项 （如果变量个数不多，个人偏 向于这种写法） \r\n   \r\n  例如: \r\n  var=\"this is a test\" \r\n  awk -v awk_var=\"$var\" \'BEGIN {print awk_var}\' \r\n   \r\n  这样便把系统变量var传递给了awk变量awk_var.  \r\n   \r\n   \r\n   \r\n   awk向shell变量传递值 \r\n   \r\n  “由awk向shell传递变量”，其思想无非是用awk(sed/perl等也是一样)输出若干条shell命令，然后再用shell去执行这些命令。 \r\n   \r\n  eval $(awk \'BEGIN{print \"var1=\'str1\';var2=\'str2\'\"}\') \r\n   \r\n  或者eval $(awk \'{printf(\"var1=%s; var2=%s; var3=%s;\",$1,$2,$3)}\' abc.txt) \r\n   \r\n  之后可以在当前shell中使用var1,var2等变量了。 \r\n   \r\n  echo \"var1=$var1 ----- var2=$var2\"\n',''),(33,'iptables','iptables iptables 使用说明书 \r\n \r\n  一：前言 \r\n   \r\n  防火墙，其实说白了讲，就是用于实现Linux下访问控制的功能的，它分为硬件的或者软件的防火墙两种。无论是在哪个网络中，防火墙工作的地方一定是在网络的边缘。而我们的任务就是需要去定义到底防火墙如何工作，这就是防火墙的策略，规则，以达到让它对出入网络的IP、数据进行检测。 \r\n   \r\n  目前市面上比较常见的有3、4层的防火墙，叫网络层的防火墙，还有7层的防火墙，其实是代理层的网关。 \r\n   \r\n  对于TCP/IP的七层模型来讲，我们知道第三层是网络层，三层的防火墙会在这层对源地址和目标地址进行检测。但是对于七层的防火墙，不管你源端口或者目标端口，源地址或者目标地址是什么，都将对你所有的东西进行检查。所以，对于设计原理来讲，七层防火墙更加安全，但是这却带来了效率更低。所以市面上通常的防火墙方案，都是两者结合的。而又由于我们都需要从防火墙所控制的这个口来访问，所以防火墙的工作效率就成了用户能够访问数据多少的一个最重要的控制，配置的不好甚至有可能成为流量的瓶颈。 \r\n   \r\n  二：iptables 的历史以及工作原理 \r\n   \r\n  1.iptables的发展: \r\n   \r\n  1iptables的前身叫ipfirewall （内核1.x时代）,这是一个作者从freeBSD上移植过来的，能够工作在内核当中的，对数据包进行检测的一款简易访问控制工具。但是ipfirewall工作功能极其有限(它需要将所有的规则都放进内核当中，这样规则才能够运行起来，而放进内核，这个做法一般是极其困难的)。当内核发展到2.x系列的时候，软件更名为ipchains，它可以定义多条规则，将他们串起来，共同发挥作用，而现在，它叫做iptables，可以将规则组成一个列表，实现绝对详细的访问控制功能。 \r\n   \r\n  1iptables他们都是工作在用户空间中，定义规则的工具，本身并不算是防火墙。它们定义的规则，可以让在内核空间当中的netfilter来读取，并且实现让防火墙工作。而放入内核的地方必须要是特定的位置，必须是tcp/ip的协议栈经过的地方。而这个tcp/ip协议栈必须经过的地方，可以实现读取规则的地方就叫做 netfilter.(网络过滤器) \r\n   \r\n      作者一共在内核空间中选择了5个位置， \r\n      1.内核空间中：从一个网络接口进来，到另一个网络接口去的 \r\n      2.数据包从内核流入用户空间的 \r\n      3.数据包从用户空间流出的 \r\n      4.进入/离开本机的外网接口 \r\n      5.进入/离开本机的内网接口 \r\n          \r\n  2.iptables的工作机制 \r\n   \r\n  2从上面的发展我们知道了作者选择了5个位置，来作为控制的地方，但是你有没有发现，其实前三个位置已经基本上能将路径彻底封锁了，但是为什么已经在进出的口设置了关卡之后还要在内部卡呢？ 由于数据包尚未进行路由决策，还不知道数据要走向哪里，所以在进出口是没办法实现数据过滤的。所以要在内核空间里设置转发的关卡，进入用户空间的关卡，从用户空间出去的关卡。那么，既然他们没什么用，那我们为什么还要放置他们呢？因为我们在做NAT和DNAT的时候，目标地址转换必须在路由之前转换。所以我们必须在外网而后内网的接口处进行设置关卡。        \r\n   \r\n  2 这五个位置也被称为五个钩子函数（hook functions）,也叫五个规则链。 \r\n  cp1.PREROUTING (路由前) \r\n  22.INPUT (数据包流入口) \r\n  cp13.FORWARD (转发管卡) \r\n  224.OUTPUT(数据包出口) \r\n  cp135.POSTROUTING（路由后） \r\n          这是NetFilter规定的五个规则链，任何一个数据包，只要经过本机，必将经过这五个链中的其中一个链。       \r\n   \r\n  3.防火墙的策略 \r\n   \r\n  3防火墙策略一般分为两种，一种叫“通”策略，一种叫“堵”策略，通策略，默认门是关着的，必须要定义谁能进。堵策略则是，大门是洞开的，但是你必须有身份认证，否则不能进。所以我们要定义，让进来的进来，让出去的出去，所以通，是要全通，而堵，则是要选择。当我们定义的策略的时候，要分别定义多条功能，其中：定义数据包中允许或者不允许的策略，filter过滤的功能，而定义地址转换的功能的则是nat选项。为了让这些功能交替工作，我们制定出了“表”这个定义，来定义、区分各种不同的工作功能和处理方式。 \r\n   \r\n  3我们现在用的比较多个功能有3个： \r\n  cp1351.filter 定义允许或者不允许的 \r\n  32.nat 定义地址转换的 \r\n                  3.mangle功能:修改报文原数据 \r\n   \r\n  32我们修改报文原数据就是来修改TTL的。能够实现将数据包的元数据拆开，在里面做标记/修改内容的。而防火墙标记，其实就是靠mangle来实现的。 \r\n   \r\n  小扩展: \r\n  对于filter来讲一般只能做在3个链上：INPUT ，FORWARD ，OUTPUT \r\n  对于nat来讲一般也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING \r\n  而mangle则是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING \r\n   \r\n  iptables/netfilter（这款软件）是工作在用户空间的，它可以让规则进行生效的，本身不是一种服务，而且规则是立即生效的。而我们iptables现在被做成了一个服务，可以进行启动，停止的。启动，则将规则直接生效，停止，则将规则撤销。 \r\n  iptablesiptables还支持自己定义链。但是自己定义的链，必须是跟某种特定的链关联起来的。在一个关卡设定，指定当有数据的时候专门去找某个特定的链来处理，当那个链处理完之后，再返回。接着在特定的链中继续检查。 \r\n   \r\n  注意：规则的次序非常关键，谁的规则越严格，应该放的越靠前，而检查规则的时候，是按照从上往下的方式进行检查的。 \r\n   \r\n  三．规则的写法: \r\n   \r\n   iptables定义规则的方式比较复杂: \r\n   格式：iptables [-t table] COMMAND chain CRETIRIA -j ACTION \r\n   -t table ：3个filter nat mangle \r\n   COMMAND：定义如何对规则进行管理 \r\n   chain：指定你接下来的规则到底是在哪个链上操作的，当定义策略的时候，是可以省略的 \r\n   CRETIRIA:指定匹配标准 \r\n   -j ACTION :指定如何进行处理 \r\n   \r\n  able 比如：不允许172.16.0.0/24的进行访问。 \r\n  able iptables -t filter -A INPUT -s 172.16.0.0/16 -p udp --dport 53 -j DROP \r\n  able 当然你如果想拒绝的更彻底： \r\n  able iptables -t filter -R INPUT 1 -s 172.16.0.0/16 -p udp --dport 53 -j REJECT \r\n   \r\n  able iptables -L -n -v2a#查看定义规则的详细信息 \r\n   \r\n  四：详解COMMAND: \r\n   \r\n  1.链管理命令（这都是立即生效的） \r\n  1-P :设置默认策略的（设定默认门是关着的还是开着的） \r\n  默认策略一般只有两种 \r\n  1iptables -P INPUT (DROP|ACCEPT)  默认是关的/默认是开的 \r\n  比如： \r\n  1iptablesiptables -P INPUT DROP 这就把默认规则给拒绝了。并且没有定义哪个动作，所以关于外界连接的所有规则包括Xshell连接之类的，远程连接都被拒绝了。 \r\n          -F: FLASH，清空规则链的(注意每个链的管理权限) \r\n  1iptablesiptables    iptables -t nat -F PREROUTING \r\n  1iptablesiptables    iptables -t nat -F 清空nat表的所有链 \r\n          -N:NEW 支持用户新建一个链 \r\n              iptables -N inbound_tcp_web 表示附在tcp表上用于检查web的。 \r\n          -X: 用于删除用户自定义的空链 \r\n              使用方法跟-N相同，但是在删除之前必须要将里面的链给清空昂了 \r\n          -E：用来Rename chain主要是用来给用户自定义的链重命名 \r\n              -E oldname newname \r\n           -Z：清空链，及链中默认规则的计数器的（有两个计数器，被匹配到多少个数据包，多少个字节） \r\n              iptables -Z :清空 \r\n   \r\n  2.规则管理命令 \r\n           -A：追加，在当前链的最后新增一个规则 \r\n           -I num : 插入，把当前规则插入为第几条。 \r\n              -I 3 :插入为第三条 \r\n           -R num：Replays替换/修改第几条规则 \r\n              格式：iptables -R 3 ………… \r\n           -D num：删除，明确指定删除第几条规则 \r\n          \r\n  3.查看管理命令 “-L” \r\n  3 附加子命令 \r\n  3 -n：以数字的方式显示ip，它会将ip直接显示出来，如果不加-n，则会将ip反向解析成主机名。 \r\n  3 -v：显示详细信息 \r\n  3 -vv \r\n  3 -vvv :越多越详细 \r\n  3 -x：在计数器上显示精确值，不做单位换算 \r\n  3 --line-numbers : 显示规则的行号 \r\n  3 -t nat：显示所有的关卡的信息 \r\n   \r\n  五：详解匹配标准 \r\n   \r\n  1.通用匹配：源地址目标地址的匹配 \r\n  1 -s：指定作为源地址匹配，这里不能指定主机名称，必须是IP \r\n  IP | IP/MASK | 0.0.0.0/0.0.0.0 \r\n  1而且地址可以取反，加一个“!”表示除了哪个IP之外 \r\n  1 -d：表示匹配目标地址 \r\n  1 -p：用于匹配协议的（这里的协议通常有3种，TCP/UDP/ICMP） \r\n\\TCP -i eth0：从这块网卡流入的数据 \r\n  1流入一般用在INPUT和PREROUTING上 \r\n  1 -o eth0：从这块网卡流出的数据 \r\n\\TCP流出一般在OUTPUT和POSTROUTING上 \r\n          \r\n  2.扩展匹配 \r\n  2.1隐含扩展：对协议的扩展 \r\n      -p tcp :TCP协议的扩展。一般有三种扩展 \r\n\\TCP--dport XX-XX：指定目标端口,不能指定多个非连续端口,只能指定单个端口，比如 \r\n\\TCP--dport 21  或者 --dport 21-23 (此时表示21,22,23) \r\n\\TCP--sport：指定源端口 \r\n\\TCP--tcp-fiags：TCP的标志位（SYN,ACK，FIN,PSH，RST,URG） \r\n\\TCP    对于它，一般要跟两个参数： \r\n  cp1.检查的标志位 \r\n\\TCP2.必须为1的标志位 \r\n  cp1--tcpflags syn,ack,fin,rst syn   =    --syn \r\n  cp1表示检查这4个位，这4个位中syn必须为1，其他的必须为0。所以这个意思就是用于检测三次握手的第一次包的。对于这种专门匹配第一包的SYN为1的包，还有一种简写方式，叫做--syn \r\n      -p udp：UDP协议的扩展 \r\n          --dport \r\n          --sport \r\n      -p icmp：icmp数据报文的扩展 \r\n          --icmp-type： \r\n  cp1echo-request(请求回显)，一般用8 来表示 \r\n  ype所以 --icmp-type 8 匹配请求回显数据包 \r\n  cp1echoecho-reply （响应的数据包）一般用0来表示 \r\n                    \r\n  2.2显式扩展（-m） \r\n       扩展各种模块 \r\n        -m multiport：表示启用多端口扩展 \r\n        之后我们就可以启用比如 --dports 21,23,80 \r\n                    \r\n          \r\n  六：详解-j ACTION \r\n   \r\n   常用的ACTION： \r\n   DROP：悄悄丢弃 \r\n  2一般我们多用DROP来隐藏我们的身份，以及隐藏我们的链表 \r\n  2 REJECT：明示拒绝 \r\n  2 ACCEPT：接受 \r\n  custom_chain：转向一个自定义的链 \r\n  custom_chain DNAT \r\n  custom_chain SNAT \r\n  custom_chain MASQUERADE：源地址伪装 \r\n  custom_chain REDIRECT：重定向：主要用于实现端口重定向 \r\n  custom_chain MARK：打防火墙标记的 \r\n  custom_chain RETURN：返回 \r\n  2在自定义链执行完毕后使用返回，来返回原规则链。 \r\n   \r\n  练习题1： \r\n       只要是来自于172.16.0.0/16网段的都允许访问我本机的172.16.100.1的SSHD服务 \r\n       分析：首先肯定是在允许表中定义的。因为不需要做NAT地址转换之类的，然后查看我们SSHD服务，在22号端口上，处理机制是接受，对于这个表，需要有一来一回两个规则，如果我们允许也好，拒绝也好，对于访问本机服务，我们最好是定义在INPUT链上，而OUTPUT再予以定义就好。(会话的初始端先定义)，所以加规则就是： \r\n       定义进来的： iptables -t filter -A INPUT -s 172.16.0.0/16 -d 172.16.100.1 -p tcp --dport 22 -j ACCEPT \r\n       定义出去的： iptables -t filter -A OUTPUT -s 172.16.100.1 -d 172.16.0.0/16 -p tcp --dport 22 -j ACCEPT \r\n       将默认策略改成DROP: \r\n  custom_chain  iptables -P INPUT DROP \r\n  2  iptables -P OUTPUT DROP \r\n    iptables -P FORWARD DROP \r\n          \r\n  七：状态检测： \r\n   \r\n  是一种显式扩展，用于检测会话之间的连接关系的，有了检测我们可以实现会话间功能的扩展 \r\n          什么是状态检测？对于整个TCP协议来讲，它是一个有连接的协议，三次握手中，第一次握手，我们就叫NEW连接，而从第二次握手以后的，ack都为1，这是正常的数据传输，和tcp的第二次第三次握手，叫做已建立的连接（ESTABLISHED）,还有一种状态，比较诡异的，比如：SYN=1 ACK=1 RST=1,对于这种我们无法识别的，我们都称之为INVALID无法识别的。还有第四种，FTP这种古老的拥有的特征，每个端口都是独立的，21号和20号端口都是一去一回，他们之间是有关系的，这种关系我们称之为RELATED。 \r\n  cp所以我们的状态一共有四种： \r\n          NEW \r\n          ESTABLISHED \r\n          RELATED \r\n          INVALID \r\n   \r\n  cp所以我们对于刚才的练习题，可以增加状态检测。比如进来的只允许状态为NEW和ESTABLISHED的进来，出去只允许ESTABLISHED的状态出去，这就可以将比较常见的反弹式木马有很好的控制机制。 \r\n          \r\n  对于练习题的扩展： \r\n  进来的拒绝出去的允许，进来的只允许ESTABLISHED进来，出去只允许ESTABLISHED出去。默认规则都使用拒绝 \r\n  cpiptables -L -n --line-number  ：查看之前的规则位于第几行 \r\n      改写INPUT \r\n          iptables -R INPUT 2 -s 172.16.0.0/16 -d 172.16.100.1 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT \r\n          iptables -R OUTPUT 1 -m state --state ESTABLISHED -j ACCEPT \r\n   \r\n      此时如果想再放行一个80端口如何放行呢？ \r\n          iptables -A INPUT -d 172.16.100.1 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT \r\n   \r\n          iptables -R INPUT 1 -d 172.16.100.1 -p udp --dport 53 -j ACCEPT \r\n   \r\n  练习题2： \r\n  假如我们允许自己ping别人，但是别人ping自己ping不通如何实现呢？ \r\n  分析：对于ping这个协议，进来的为8（ping），出去的为0(响应).我们为了达到目的，需要8出去,允许0进来 \r\n   \r\n  在出去的端口上：iptables -A OUTPUT -p icmp --icmp-type 8 -j ACCEPT \r\n  在进来的端口上：iptables -A INPUT -p icmp --icmp-type 0 -j ACCEPT \r\n   \r\n  小扩展：对于127.0.0.1比较特殊，我们需要明确定义它 \r\n  cpiptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT \r\n  ypeiptables -A OUTPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT \r\n   \r\n  八：SNAT和DNAT的实现 \r\n   \r\n  由于我们现在IP地址十分紧俏，已经分配完了，这就导致我们必须要进行地址转换，来节约我们仅剩的一点IP资源。那么通过iptables如何实现NAT的地址转换呢？ \r\n   \r\n  1.SNAT基于原地址的转换 \r\n  1基于原地址的转换一般用在我们的许多内网用户通过一个外网的口上网的时候，这时我们将我们内网的地址转换为一个外网的IP，我们就可以实现连接其他外网IP的功能。 \r\n  所以我们在iptables中就要定义到底如何转换： \r\n  定义的样式： \r\n  比如我们现在要将所有192.168.10.0网段的IP在经过的时候全都转换成172.16.100.1这个假设出来的外网地址： \r\n  iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -j SNAT --to-source 172.16.100.1 \r\n  o这样，只要是来自本地网络的试图通过网卡访问网络的，都会被统统转换成172.16.100.1这个IP.  \r\n  o那么，如果172.16.100.1不是固定的怎么办？ \r\n  o我们都知道当我们使用联通或者电信上网的时候，一般它都会在每次你开机的时候随机生成一个外网的IP，意思就是外网地址是动态变换的。这时我们就要将外网地址换成 MASQUERADE(动态伪装):它可以实现自动寻找到外网地址，而自动将其改为正确的外网地址。所以，我们就需要这样设置： \r\n           iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -j MASQUERADE \r\n           这里要注意：地址伪装并不适用于所有的地方。 \r\n   \r\n  2.DNAT目标地址转换 \r\n  2对于目标地址转换，数据流向是从外向内的，外面的是客户端，里面的是服务器端通过目标地址转换，我们可以让外面的ip通过我们对外的外网ip来访问我们服务器不同的服务器，而我们的服务却放在内网服务器的不同的服务器上。 \r\n   \r\n      如何做目标地址转换呢？： \r\n  oiptables -t nat -A PREROUTING -d 192.168.10.18 -p tcp --dport 80 -j DNAT --todestination 172.16.100.2 \r\n          目标地址转换要做在到达网卡之前进行转换,所以要做在PREROUTING这个位置上 \r\n   \r\n  九：控制规则的存放以及开启 \r\n   \r\n  注意：你所定义的所有内容，当你重启的时候都会失效，要想我们能够生效，需要使用一个命令将它保存起来 \r\n  1.service iptables save 命令 \r\n  它会保存在/etc/sysconfig/iptables这个文件中 \r\n      2.iptables-save 命令 \r\n  1iptables-save > /etc/sysconfig/iptables \r\n   \r\n      3.iptables-restore 命令 \r\n  1开机的时候，它会自动加载/etc/sysconfig/iptabels \r\n  如果开机不能加载或者没有加载，而你想让一个自己写的配置文件（假设为iptables.2）手动生效的话： \r\n  1iptablesiptables-restore < /etc/sysconfig/iptables.2 \r\n  1则完成了将iptables中定义的规则手动生效 \r\n   \r\n   \r\n  十：总结 \r\n           Iptables是一个非常重要的工具，它是每一个防火墙上几乎必备的设置，也是我们在做大型网络的时候，为了很多原因而必须要设置的。学好Iptables,可以让我们对整个网络的结构有一个比较深刻的了解，同时，我们还能够将内核空间中数据的走向以及linux的安全给掌握的非常透彻。我们在学习的时候，尽量能结合着各种各样的项目，实验来完成，这样对你加深iptables的配置，以及各种技巧有非常大的帮助。\niptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A OUTPUT -p tcp --sport 22 -j ACCEPT \r\n  1、为了能采用远程SSH登陆,我们要开启22端口. (注:这个规则,如果你把OUTPUT 设置成DROP的就要写上这一部,好多人都是望了写这一部规则导致,始终无法SSH.在远程一下,是不是好了.）\niptables -A INPUT -p icmp -j ACCEPT    (INPUT设置成DROP的话)\niptables -A OUTPUT -p icmp -j ACCEPT (OUTPUT设置成DROP的话) \r\n  1、允许icmp包通过,也就是允许ping\niptables -A FORWARD -f -m limit --limit 100/s --limit-burst 100 -j ACCEPT \r\n  处理IP碎片数量,防止攻击,允许每秒100个\niptables -A FORWARD -p icmp -m limit --limit 1/s --limit-burst 10 -j ACCEPT \r\n  设置ICMP包过滤,允许每秒1个包,限制触发条件是10个包.\niptables -A INPUT     -m state --state INVALID -j DROP \r\n   drop非法连接\niptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j MASQUERADE \r\n  将源地址是 192.168.0.0/24 的数据包进行地址伪装\niptables -t nat -A PREROUTING -p tcp --dport 3307 -j DNAT --to 172.16.201.241:3306  （将172.16.201.244 3307的目标地址改为 172.16.201.241的3306 端口上 ）\niptables -t nat -A POSTROUTING -o eth3 -j MASQUERADE \r\n   以上两条实现IP和端口转发\niptables 小结 \r\n     Firewall： \r\n       rules、policy \r\n     防火墙分类： \r\n       工作在三层的网络防火墙、七层防火墙    \r\n      NetFilter： \r\n        hook functions 五个“钩子函数” \r\n         chains \r\n          PREROUTINT 路由前的 \r\n          INPUT  数据包包的流入接口 \r\n          FORWARD 转发 \r\n          OUTPUT 由本机出来的 \r\n          POSTROUTING 路由后的 \r\n        防火墙策略：“通”、“堵” ： 通就全通，堵只需单堵 \r\n        允许/不允许：filter \r\n        地址转换：nat \r\n        修改报文原数据：mangle \r\n        使用表来实现同一个链上的不同规则 \r\n        \r\n        三表五链 \r\n          filter ：INPUT,FORWARD,OUTPUT \r\n          nat    ：PREROUTING OUTPUT POSTROUTING \r\n          mngle  : PREROUTING INPUT FORWARD OUTPUT POSTROUTING \r\n   \r\n   \r\n        iptables定义规则 \r\n        iptables [-t table(默认filter)] COMMAND chain CRETIRIA(匹配规则) -j ACTION \r\n            COMMAND: \r\n               链管理命令： \r\n                  -P ：设置默认策略 \r\n                      # iptables -P INPUT {DROP|ACCEPT} \r\n                  -F : flush 清空规则链的 \r\n                      # iptables -t nat -F PREROUTING \r\n                  -N :new 新建一个链 \r\n                      # iptables -N inbound_tcp_web \r\n                  -X ：删除用户自定义的空链，删除之前清空里面的规则 \r\n                  -E : 给用户自定义的链重命名 \r\n                  -Z ：清空链默认规则及链中规的计数器的 \r\n               规则管理命令： \r\n                  -A ：在当前的链中最后追加 \r\n                  -I num：插入为第num条 \r\n                  -R num：修改规则,替换 \r\n                     # iptables -R -num +新规则 \r\n                  -D num:删除，指定删除第num条                \r\n               查看命令： \r\n                  -L ：list 查看 \r\n                     -n 以数字方式显示，不进行解析 \r\n                     -v 详细信息 \r\n                     -vv \r\n                     -vvv \r\n                     -x 计数器的精确值，不做单位换算 \r\n                     --line-numbers :显示行号   \r\n            匹配标准 \r\n              通用匹配： \r\n                  -s,--source,-src :做原地址匹配源码天空，不能使用主机名，使用ip \r\n                       eg: IP,NETWORK/NETMASK,0.0.0.0/0.0.0.0 \r\n                  -d :匹配目标地址 \r\n                  -p ：匹配协议的｛tcp|udp|icmp｝ \r\n                  -i eth0: inbount流入的 \r\n                  -o eth0：流出的接口 \r\n              扩展匹配： \r\n                隐含扩展： \r\n                  -p tcp \r\n                      --dport ：目标端口 \r\n                      --sport : 源端口 \r\n                      --tcp-flags:tcp的标志位  SYN.ACK.FIN.PSH.RST.URG.  \r\n                         --tcp-flags  检查的标志位 必须为1的标志位 \r\n                          eg:--tcp-flags syn,ack,fin,rst   syn  ==--syn\n                  -p udp \r\n                     --dport \r\n                     --sport \r\n                  -p icmp \r\n                     --icmp-type 8 \r\n                       echo-request ==8  ping出去的数据包 \r\n                       echo-reply ==0  ping的相应 \r\n                显式扩展         \r\n                   使用各种扩展模块 \r\n                     -p tcp -m multiport --drops 21,23,80 \r\n             ACTION \r\n                -j  ACTION  \r\n                    DROP   悄悄拒绝 \r\n                    REJECT 明确拒绝 \r\n                    ACCEPT 接受 \r\n                    custom_chain \r\n                    DNAT 目标nat \r\n                    SNAT 原nat \r\n                    MASQUERADE 地址伪装 \r\n                    REDIRECT重定向 \r\n                    MARK 标记 \r\n                    RETURN    \r\n   state状态 \r\n     NEW \r\n     ESTABLSHED \r\n     RELATED \r\n     INVALID                \r\n                    \r\n  service iptables save 保存 \r\n  默认保存在/etc/sysconfig/iptables \r\n   \r\n  iptable-save > /etc/sysconfig/iptables.2 保存到指定的文件中 \r\n   \r\n  iptables-restore < /etc/sysconfig/iptables.2 启动文件iptables.2里面定义的规则 \r\n   \r\n                     \r\n  iptables实现nat： \r\n   源地址转换 \r\n   iptables -t nat -A  POSTROUTING -s NETWORK/PREFIX  -j SNAT --to-source  Internet_IP              \r\n   如果地址不是固定的，使用MASQUERADE来伪装地址 \r\n    iptables -t nat -A  POSTROUTING -s 192.168.0.0/24 -j  MASQUERADE                  \r\n   目标 地址转换 \r\n     iptables -t nat -A PREROUTING -d INternet_fa  -p tcp --dport 80 -j DNAT --to-destination NEI_IP\n','//实现第一次握手 \r'),(34,'find','find find . -maxdepth 1 -name *.jpg -print -exec convert \"{}\" -resize 80x60 \"thumbs/{}\" \\; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)\nfind / -name file1 从 \'/\' 开始进入根文件系统搜索文件和目录\nfind / -user user1 搜索属于用户 \'user1\' 的文件和目录\nfind /home/user1 -name \\*.bin 在目录 \'/ home/user1\' 中搜索带有\'.bin\' 结尾的文件\nfind /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件\nfind /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件\nfind / -name \\*.rpm -exec chmod 755 \'{}\' \\; 搜索以 \'.rpm\' 结尾的文件并定义其权限\nfind / -xdev -name \\*.rpm 搜索以 \'.rpm\' 结尾的文件，忽略光驱、捷盘等可移动设备\nfind / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件\nfind /home/user1 -name \'*.txt\' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 \'.txt\' 结尾的文件到另一个目录\nfind /var/log -name \'*.log\' | tar cv --files-from=- | bzip2 > log.tar.bz2 查找所有以 \'.log\' 结尾的文件并做成一个bzip包\n',''),(35,'brctl','brctl brctl 网桥使用说明\r\n \r\n    什么是网桥 \r\n   \r\n    网桥是一种在链路层实现中继，对帧进行转发的技术，根据MAC分区块，可隔离碰撞，将网络的多个网段在数据链路层连接起来的网络设备。 \r\n   \r\n    Linux 网桥配置命令：brctl \r\n   \r\n    在Linux中配置网络一般使用 brctl 命令，使用此命令首先要安装：bridge-utils软件包。 \r\n   \r\n    [inbi@debian~]#apt-get install bridge-utils \r\n   \r\n    [inbi@debian~]#modprobe bridge \r\n   \r\n    [inbi@debian~]#echo \"1\">/proc/sys/net/ipv4/ip_forward \r\n   \r\n    #安装bridge-utils软件包，并加载bridge模块和开启内核转发。 \r\n   \r\n    [inbi@debian~]#brctl \r\n   \r\n    #直接输入brctl命令将显示帮助信息！ \r\n   \r\n    Usage: brctl [commands] \r\n   \r\n    commands: \r\n            addbr bridge的名称  #添加bridge； \r\n   \r\n      delbr bridge的名称              #删除bridge； \r\n   \r\n      addif bridge的名称device的名称#添加接口到bridge； \r\n   \r\n      delif bridge的名称device的名称#从bridge中删除接口 \r\n   \r\n      setageing bridge的名称时间     #设置老化时间，即生存周期 \r\n   \r\n      setbridgeprio bridge的名称 优先级#设置bridge的优先级 \r\n   \r\n      setfd bridge的名称时间         #设置bridge转发延迟时间 \r\n   \r\n      sethello bridge的名称时间      #设置hello时间 \r\n   \r\n      setmaxage bridge的名称时间     #设置消息的最大生命周期 \r\n   \r\n      setpathcost bridge的名称 端口 权重#设置路径的权值 \r\n   \r\n      setportprio bridge的名称 端口 优先级#设置端口的优先级 \r\n   \r\n      show     #显示bridge列表 \r\n   \r\n      showmacs bridge的名称  #显示MAC地址 \r\n   \r\n      showstp  bridge的名称           #显示bridge的stp信息 \r\n   \r\n      stp bridge的名称{on|off}       #开/关stp \r\n   \r\n     \r\n   \r\n  一、  增加网桥 \r\n   \r\n   \r\n    [inbi@debian~]#brctl addbr br0 \r\n   \r\n    #增加一个网桥 \r\n   \r\n    [inbi@debian~]#ifconfig eth0 0.0.0.0 promisc \r\n   \r\n    [inbi@debian~]#ifconfig eth1 0.0.0.0 promisc \r\n   \r\n    [inbi@debian~]#brctl addif br0 eth0 eth1 \r\n   \r\n    #将两块已有的网卡添加到网桥，此时这两个网卡工作于混杂模式，所以不需要IP了，因为网桥是工作在链路层的。 \r\n   \r\n    [inbi@debian~]#brctl show \r\n   \r\n    #查看已有网桥 \r\n   \r\n     \r\n   \r\n    你也可以为 br0 设置一个IP，已访问这台机器。 \r\n   \r\n    [inbi@debian~]#ifconfig br0 10.10.1.1 netmask 255.255.0.0 up \r\n   \r\n  二、  删除网桥 \r\n   \r\n    [inbi@debian~]#brctl delif br0 eth0 eth1 \r\n   \r\n    #增加网桥中的接口 \r\n   \r\n    [inbi@debian~]#brctl delbr br0 \r\n   \r\n    #删除网桥 \r\n   \r\n  三、  关闭网桥 \r\n   \r\n     \r\n   \r\n    [inbi@debian~]#brctl stp br0 off \r\n   \r\n    #关闭生成树协议，减少数据包污染，因为我这里只有一个路由器哦！ \r\n   \r\n  四、  配置桥开机激活 \r\n   \r\n     \r\n   \r\n    [inbi@debian~]#echo \"modprobe bridge\">>/etc/rc.local \r\n   \r\n    #开机加载 bridge 模块，或者echo \"bridge\">>/etc/modules \r\n   \r\n    [inbi@debian~]#cp /etc/network/interfaces /etc/network/interfaces.default \r\n   \r\n    #备份下，方便以后使用啊！ \r\n   \r\n    [inbi@debian~]#vim /etc/network/interfaces \r\n   \r\n    auto lo eth0 eth1 br0 \r\n   \r\n    iface lo inet loopback \r\n   \r\n    iface br0 inet static \r\n   \r\n        address 10.10.10.1 \r\n   \r\n        netmask 255.255.0.0 \r\n   \r\n        gateway 10.10.10.254 \r\n   \r\n        pre-up ip link set eth0 promisc on \r\n   \r\n        pre-up ip link set eth1 promisc on \r\n   \r\n        pre-up echo \"1\">/proc/sys/net/ipv4/ip_forward \r\n   \r\n        bridge_ports eth0 eth1 \r\n   \r\n    #配置eth0 eth1 br0开机启动，eth0，eth1未设置IP信息，在启动br0网卡时，开启了eth0，eth1的混杂模式，并桥接了它们。\n',''),(36,'fuser','fuser fuser -km /mnt/hda2 当设备繁忙时强制卸载\n',''),(37,'dpkg','dpkg dpkg-query -W -f=\'${Installed-Size;10}t${Package}n\' | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)\ndpkg -i package.deb 安装/更新一个 deb 包\ndpkg -r package_name 从系统删除一个 deb 包\ndpkg -l 显示系统中所有已经安装的 deb 包\ndpkg -l | grep httpd 显示所有名称中包含 \"httpd\" 字样的deb包\ndpkg -s package_name 获得已经安装在系统中一个特殊包的信息\ndpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表\ndpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表\ndpkg -S /bin/ping 确认所给的文件由哪个deb包提供\n',''),(38,'git','git git 常用命令 \r\n  Git查看、添加、提交、删除、找回，重置修改文件 \r\n   \r\n    git help <command> # 显示command的help \r\n   \r\n    git show # 显示某次提交的内容 git show $id \r\n   \r\n    git co -- <file> # 抛弃工作区修改 \r\n   \r\n    git co . # 抛弃工作区修改 \r\n   \r\n    git add <file> # 将工作文件修改提交到本地暂存区 \r\n   \r\n    git add . # 将所有修改过的工作文件提交暂存区 \r\n   \r\n    git rm <file> # 从版本库中删除文件 \r\n   \r\n    git rm <file> --cached # 从版本库中删除文件，但不删除文件 \r\n   \r\n    git reset <file> # 从暂存区恢复到工作文件 \r\n   \r\n    git reset -- . # 从暂存区恢复到工作文件 \r\n   \r\n    git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 \r\n   \r\n    git ci <file> git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　git ci -am \"some comments\" \r\n   \r\n    git ci --amend # 修改最后一次提交记录 \r\n   \r\n    git revert <$id> # 恢复某次提交的状态，恢复动作本身也创建次提交对象 \r\n   \r\n    git revert HEAD # 恢复最后一次提交的状态 \r\n   \r\n  Git 查看文件diff \r\n   \r\n    git diff <file> # 比较当前文件和暂存区文件差异 git diff \r\n   \r\n    git diff <$id1> <$id2> # 比较两次提交之间的差异 \r\n   \r\n    git diff <branch1>..<branch2> # 在两个分支之间比较 \r\n   \r\n    git diff --staged # 比较暂存区和版本库差异 \r\n   \r\n    git diff --cached # 比较暂存区和版本库差异 \r\n   \r\n    git diff --stat # 仅仅比较统计信息 \r\n   \r\n  Git 查看提交记录 \r\n   \r\n    git log git log <file> # 查看该文件每次提交记录 \r\n   \r\n    git log -p <file> # 查看每次详细修改内容的diff \r\n   \r\n    git log -p -2 # 查看最近两次详细修改内容的diff \r\n   \r\n    git log --stat #查看提交统计信息 \r\n   \r\n    tig Mac上可以使用tig代替diff和log，brew install tig \r\n   \r\n  Git 本地分支管理  查看、切换、创建和删除分支 \r\n   \r\n    git br -r # 查看远程分支 \r\n   \r\n    git br <new_branch> # 创建新的分支 \r\n   \r\n    git br -v # 查看各个分支最后提交信息 \r\n   \r\n    git br --merged # 查看已经被合并到当前分支的分支 \r\n   \r\n    git br --no-merged # 查看尚未被合并到当前分支的分支 \r\n   \r\n    git co <branch> # 切换到某个分支 \r\n   \r\n    git co -b <new_branch> # 创建新的分支，并且切换过去 \r\n   \r\n    git co -b <new_branch> <branch> # 基于branch创建新的new_branch \r\n   \r\n    git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 \r\n   \r\n    git co $id -b <new_branch> # 把某次历史提交记录checkout出来，创建成一个分支 \r\n   \r\n    git br -d <branch> # 删除某个分支 \r\n   \r\n    git br -D <branch> # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) \r\n   \r\n  Git 分支合并和rebase \r\n   \r\n    git merge <branch> # 将branch分支合并到当前分支 \r\n   \r\n    git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交 \r\n   \r\n    git rebase master <branch> # 将master rebase到branch，相当于： git co <branch> && git rebase master && git co master && git merge <branch> \r\n   \r\n     Git补丁管理(方便在多台机器上开发同步时用) \r\n   \r\n    git diff > ../sync.patch # 生成补丁 \r\n   \r\n    git apply ../sync.patch # 打补丁 \r\n   \r\n    git apply --check ../sync.patch #测试补丁能否成功 \r\n   \r\n  Git 暂存管理 \r\n   \r\n    git stash # 暂存 \r\n   \r\n    git stash list # 列所有stash \r\n   \r\n    git stash apply # 恢复暂存的内容 \r\n   \r\n    git stash drop # 删除暂存区 \r\n   Git远程分支管理 \r\n   \r\n    git pull # 抓取远程仓库所有分支更新并合并到本地 \r\n   \r\n    git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 \r\n   \r\n    git fetch origin # 抓取远程仓库更新 \r\n   \r\n    git merge origin/master # 将远程主分支合并到本地当前分支 \r\n   \r\n    git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支 \r\n   \r\n    git co -b <local_branch> origin/<remote_branch> # 基于远程分支创建本地分支，功能同上 \r\n   \r\n    git push # push所有分支 \r\n   \r\n    git push origin master # 将本地主分支推到远程主分支 \r\n   \r\n    git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) \r\n   \r\n    git push origin <local_branch> # 创建远程分支， origin是远程仓库名 \r\n   \r\n    git push origin <local_branch>:<remote_branch> # 创建远程分支 \r\n   \r\n    git push origin :<remote_branch> #先删除本地分支(git br -d <branch>)，然后再push删除远程分支 \r\n   \r\n  Git远程仓库管理 GitHub \r\n   \r\n    git remote -v # 查看远程服务器地址和仓库名称 \r\n   \r\n    git remote show origin # 查看远程服务器仓库状态 \r\n   \r\n    git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 \r\n   \r\n    git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm <repository> # 删除远程仓库 \r\n   \r\n  Git 创建远程仓库 \r\n   \r\n    git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 \r\n   \r\n    scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 \r\n   \r\n    mkdir robbin_site.git && cd robbin_site.git && git --bare init # 在服务器创建纯仓库 \r\n   \r\n    git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 \r\n   \r\n    git push -u origin master # 客户端首次提交 \r\n   \r\n    git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track \r\n   \r\n    git remote set-head origin master # 设置远程仓库的HEAD指向master分支 \r\n   \r\n    也可以命令设置跟踪远程库和本地库 \r\n   \r\n    git branch --set-upstream master origin/master \r\n   \r\n    git branch --set-upstream develop origin/develop\n',''),(42,'zip','zip zip file1.zip file1 创建一个zip格式的压缩包\nzip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包\n',''),(44,'top','top top -H -p pid 查看某进行的线程情况\ntop -n 1 -b 显示所有进程信息后退出\ntop -d 3 每三秒更新一次\ntop -p pid 对某个进程进行监测\ntop -b -n 1 > /tmp/top.txt 这样一来，嘿嘿！就可以将 top 的信息存到 /tmp/top.txt 档案中了。 \r\n  (1) 在top中可以输入 \'?\' 得到帮助\n',''),(45,'mysql','mysql mysqldump 导入导出语句诠释\r\n \r\n  表结构等已经在目标数据库中存在，不想拷贝数据库过去，MySQL的存储过程导出和导入，Mysqldump工具可以实现，具体用法为： \r\n  D:\\> mysqldump -uroot -p -hlocalhost -P3306 -n -d -t -R DBName > procedure_name.sql \r\n  参数说明： \r\n  -n: --no-create-db \r\n  -d: --no-data \r\n  -t: --no-create-info \r\n  -R: --routines Dump stored routines (functions and procedures) \r\n  只导出存储过程和函数。 \r\n   \r\n  导入存储过程 \r\n   \r\n  命令导入数据库中的存储过程 \r\n  D:\\>mysql -uroot -p123 dbname < procedurefile.sql \r\n   \r\n   \r\n  mysqldump备份： \r\n  mysqldump -u用户名 -p密码 -h主机 数据库 a -w \"sql条件\" --lock-all-tables > 路径 \r\n  案例： \r\n  mysqldump -uroot -p1234 -hlocalhost db1 a -w \"id in (select id from b)\" --lock-all-tables > c:\\aa.txt \r\n  mysqldump -c -t z3000_ext VT_UnAnswerDetail -w \' beginTime >= \"2010-06-01 00:00:00\"\' > VT_UnAnswerDetail.sql \r\n  mysqldump还原： \r\n  mysqldump -u用户名 -p密码 -h主机 数据库 < 路径 \r\n  案例： \r\n  mysql -uroot -p1234 db1 < c:\\aa.txt \r\n  mysqldump按条件导出： \r\n  mysqldump -u用户名 -p密码 -h主机 数据库  a --where \"条件语句\" --no-建表> 路径 \r\n  mysqldump -uroot -p1234 dbname a --where \"tag=\'88\'\" --no-create-info> c:\\a.sql \r\n  mysqldump按导入： \r\n  mysqldump -u用户名 -p密码 -h主机 数据库 < 路径 \r\n  案例： \r\n  mysql -uroot -p1234 db1 < c:\\a.txt \r\n   \r\n  mysqldump导出表： \r\n  mysqldump -u用户名 -p密码 -h主机 数据库 表 \r\n  案例： \r\n  mysqldump -uroot -p sqlhk9 a --no-data \r\n  讲一下 mysqldump 的一些主要参数 \r\n   \r\n  --compatible=name \r\n  它告诉 mysqldump，导出的数据将和哪种数据库或哪个旧版本的 MySQL 服务器相兼容。值可以为 ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options 等，要使用几个值，用逗号将它们隔开。当然了，它并不保证能完全兼容，而是尽量兼容。 \r\n  --complete-insert，-c \r\n  导出的数据采用包含字段名的完整 INSERT 方式，也就是把所有的值都写在一行。这么做能提高插入效率，但是可能会受到 max_allowed_packet 参数的影响而导致插入失败。因此，需要谨慎使用该参数，至少我不推荐。 \r\n  --default-character-set=charset \r\n  指定导出数据时采用何种字符集，如果数据表不是采用默认的 latin1 字符集的话，那么导出时必须指定该选项，否则再次导入数据后将产生乱码问题。 \r\n  --disable-keys \r\n  告诉 mysqldump 在 INSERT 语句的开头和结尾增加 ; 和 ; 语句，这能大大提高插入语句的速度，因为它是在插入完所有数据后才重建索引的。该选项只适合 MyISAM 表。 \r\n  --extended-insert = true|false \r\n  默认情况下，mysqldump 开启 --complete-insert 模式，因此不想用它的的话，就使用本选项，设定它的值为 false 即可。 \r\n  --hex-blob \r\n  使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用本选项。影响到的字段类型有 BINARY、VARBINARY、BLOB。 \r\n  --lock-all-tables，-x \r\n  在开始导出之前，提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭 --single-transaction 和 --lock-tables 选项。 \r\n  --lock-tables \r\n  它和 --lock-all-tables 类似，不过是锁定当前导出的数据表，而不是一下子锁定全部库下的表。本选项只适用于 MyISAM 表，如果是 Innodb 表可以用 --single-transaction 选项。 \r\n  --no-create-info，-t \r\n  只导出数据，而不添加 CREATE TABLE 语句。 \r\n  --no-data，-d \r\n  不导出任何数据，只导出数据库表结构。 \r\n  --opt \r\n  这只是一个快捷选项，等同于同时添加 --add-drop-tables --add-locking --create-option --disable-keys --extended-insert --lock-tables --quick --set-charset 选项。本选项能让 mysqldump 很快的导出数据，并且导出的数据能很快导回。该选项默认开启，但可以用 --skip-opt 禁用。注意，如果运行 mysqldump 没有指定 --quick 或 --opt 选项，则会将整个结果集放在内存中。如果导出大数据库的话可能会出现问题。 \r\n  --quick，-q \r\n  该选项在导出大表时很有用，它强制 mysqldump 从服务器查询取得记录直接输出而不是取得所有记录后将它们缓存到内存中。 \r\n  --routines，-R \r\n  导出存储过程以及自定义函数。 \r\n  --single-transaction \r\n  该选项在导出数据之前提交一个 BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于事务表，例如 InnoDB 和 BDB。 \r\n  本选项和 --lock-tables 选项是互斥的，因为 LOCK TABLES 会使任何挂起的事务隐含提交。 \r\n  要想导出大表的话，应结合使用 --quick 选项。 \r\n  --triggers \r\n  同时导出触发器。该选项默认启用，用 --skip-triggers 禁用它。 \r\n  其他参数详情请参考手册，我通常使用以下 SQL 来备份 MyISAM 表： \r\n  /usr/local/mysql/bin/mysqldump -uyejr -pyejr \" \r\n  --default-character-set=utf8 --opt --extended-insert=false \" \r\n  --triggers -R --hex-blob -x db_name > db_name.sql \r\n  使用以下 SQL 来备份 Innodb 表： \r\n  /usr/local/mysql/bin/mysqldump -uyejr -pyejr \" \r\n  --default-character-set=utf8 --opt --extended-insert=false \" \r\n  --triggers -R --hex-blob --single-transaction db_name > db_name.sql \r\n  另外，如果想要实现在线备份，还可以使用 --master-data 参数来实现，如下： \r\n  /usr/local/mysql/bin/mysqldump -uyejr -pyejr \" \r\n  --default-character-set=utf8 --opt --master-data=1 \" \r\n  --single-transaction --flush-logs db_name > db_name.sql \r\n  它只是在一开始的瞬间请求锁表，然后就刷新binlog了，而后在导出的文件中加入CHANGE MASTER 语句来指定当前备份的binlog位置，如果要把这个文件恢复到slave里去，就可以采用这种方法来做。 \r\n  1.2 还原 \r\n  用 mysqldump 备份出来的文件是一个可以直接倒入的 SQL 脚本，有两种方法可以将数据导入。 \r\n  直接用 mysql 客户端 \r\n  例如： \r\n  /usr/local/mysql/bin/mysql -uyejr -pyejr db_name < db_name.sql \r\n  用 SOURCE 语法 （实验不成功！！！） \r\n  其实这不是标准的 SQL 语法，而是 mysql 客户端提供的功能，例如： \r\n  SOURCE /tmp/db_name.sql; \r\n  这里需要指定文件的绝对路径，并且必须是 mysqld 运行用户(例如 nobody)有权限读取的文件。\nmysql 授权\r\n \r\n  GRANT ALL PRIVILEGES ON test.* TO \'mysqluser\'@\'%\' IDENTIFIED BY \'mysqluser\'; \r\n  FLUSH PRIVILEGES;\r\n\r\n \r\n  mysql> grant 权限1,权限2,…权限n on 数据库名称.表名称 to 用户名@用户地址 identified by ‘连接口令’; \r\n   \r\n  权限1,权限2,…权限n代表select,insert,update,delete,create,drop,index,alter,grant,references,reload,shutdown,process,file等14个权限。 \r\n  当权限1,权限2,…权限n被all privileges或者all代替，表示赋予用户全部权限。 \r\n  当数据库名称.表名称被*.*代替，表示赋予用户操作服务器上所有数据库所有表的权限。 \r\n  用户地址可以是localhost，也可以是ip地址、机器名字、域名。也可以用’%\'表示从任何地址连接。 \r\n  ‘连接口令’不能为空，否则创建失败。 \r\n   \r\n  mysql>grant select,insert,update,delete,create,drop on vtdc.employee to joe@10.163.225.87 identified by ‘123′; \r\n  给来自10.163.225.87的用户joe分配可对数据库vtdc的employee表进行select,insert,update,delete,create,drop等操作的权限，并设定口令为123。\nmysql 简单操作语句\r\n\r\n \r\n   \r\n  产生测试数据 \r\n  INSERT INTO test.SCHEDULE_TEST \r\n  ( \r\n  DEAL_COUNT, \r\n  STS, \r\n  OWN_SIGN \r\n  ) \r\n  SELECT \r\n  DEAL_COUNT, \r\n  STS, \r\n  OWN_SIGN \r\n  FROM \r\n  test.SCHEDULE_TEST \r\n  test\r\n  备分表 \r\n  CREATE TABLE bak SELECT * FROM SCHEDULE_TEST \r\n   \r\n   \r\n  复制表结构 \r\n  CREATE TABLE bak SELECT * FROM SCHEDULE_TEST WHERE 1=0 \r\n   \r\n   \r\n  删除表 \r\n  DROP TABLE bak; \r\n   \r\n  清空表 \r\n  TRUNCATE TABLE bak; \r\n   \r\n  mysql关联多表进行update更新操作 \r\n  UPDATE Track \r\n  INNER JOIN MV \r\n  ON Track.trkid=MV.mvid \r\n  SET Track.is_show=MV.is_show \r\n  WHERE trkid<6 \r\n   \r\n  等同于 \r\n   \r\n  UPDATE Track,MV \r\n  SET Track.is_show=MV.is_show \r\n  WHERE Track.trkid=MV.mvid and trkid<6 \r\n   \r\n  \n',''),(46,'postgresql','postgresql postgresql 使用说明 \r\n  1.  \r\n  PostgresSQL 支持标准的 SQL 类型 int，smallint， real，double precision， char(N)， varchar(N)，date， time，timestamp 和 interval \r\n  2.  \r\n  \\c [数据库名]   多个数据库之间的切换 \r\n   \r\n  \\a              在非对齐和对齐的输出模式之间切换 \r\n  \\C [字串]       设置表标题, 如果参数空则取消标题 \r\n  \\cd [目录名]    改变当前的工作目录 \r\n  \\copy ...       执行 SQL COPY, 数据流指向客户端主机 \r\n  \\copyright      显示 PostgreSQL 用法和发布信息 \r\n  \\d [名字]       描述表, 索引, 序列, 或者视图 \r\n                   列出表/索引/序列/视图/系统表 \r\n  \\d{t|i|s|v|S} [模式]     (加 \"+\" 获取更多信息) \r\n                   列出表/索引/序列/视图/系统表 \r\n  \\da [模式]      列出聚集函数 \r\n  \\dd [模式]      显示目标的注释 \r\n  \\dD [模式]      列出域 \r\n  \\df [模式]      列出函数 (加 \"+\" 获取更多的信息) \r\n  \\do [名字]      列出操作符 \r\n  \\dl             列出大对象, 和 \\lo_list 一样 \r\n  \\dp [模式]      列出表访问权限 \r\n  \\dT [模式]      列出数据类型 (加 \"+\" 获取更多的信息) \r\n  \\du [模式]      列出用户 \r\n  \\e [文件名]     用一个外部编辑器编辑当前查询缓冲区或者文件 \r\n  \\echo [字串]    向标准输出写出文本 \r\n  \\encoding [哪种编码]       设置客户端编码(EUC_JP,GBK) \r\n  \\f [字串]       设置域分隔符 \r\n  \\g 文件名       向服务器发送 SQL 命令 (并且把结果写到文件或者 |管道) \r\n  \\h [名字]       SQL 命令的语法帮助, 用 * 可以看所有命令的帮助 \r\n  \\H              在 HTML 输出模式之间切换 (当前是 关闭) \r\n  \\i 文件名       执行来自文件的命令 \r\n  \\l              列出所有数据库 \r\n  \\lo_export, \\lo_import, \\lo_list, \\lo_unlink \r\n                   大对象操作 \r\n  \\o 文件名       向文件或者 |管道 发送所有查询结果 \r\n  \\p              显示当前查询缓冲区的内容 \r\n  \\pset 名字 [值]      设置表的输出选项 (NAME := {foramt|border|expaned| \r\n                   (名字 := {foramt|border|expanded|fieldsep|null|recordsep| \r\n                   tuples_only|title|tableattr|pager}) \r\n  \\q              退出 psql \r\n  \\r              重置 (清理) 查询缓冲区 \r\n  \\s [文件名]     打印历史或者将其保存到文件 \r\n  \\set [名字 [值]]      设置内部变量, 如果没有参数就列出所有 \r\n                  只显示行 (当前是 关闭) \r\n  \\T [字串]       设置 HTML <表>标记属性, 如果没有参数就取消设置 \r\n    iming         查询计时开关切换 (目前是 关闭) \r\n  \\unset 名字     取消(删除)内部变量 \r\n  \\w [文件名]     将当前查询缓冲区写出到文件 \r\n  \\x              在扩展输出之间切换 (目前是 关闭) \r\n  \\z [模式]       列出表访问权限 (和 \\dp 一样) \r\n  \\! [命令]       在 shell 里执行命令或者开始一个交互的 shell \r\n   \r\n  \\echo [string]  输出字符串 \r\n   \r\n  \\qecho [字串]     向查询输出流写出文本 (见 \\o) \r\n   \r\n  3. 将数据库 导出到 文件标识符 \r\n   \r\n   \r\n   \r\n  命令： \r\n   \r\n  \\copy 表名 to 文件名|标准输出 [delimiter  as  ‘分隔符’]  [null  as ‘null表示的字符串’ ] [csv  quote  as ‘引号的类型’] \r\n   \r\n   \r\n   \r\n  解释： \r\n   \r\n  可以将表中的数据输出到 文件或标准输出。 \r\n   \r\n   \r\n  delimiter as ‘分隔符’   ：说明输出设备的文本中表的每个字段用什么字符分割，默认是tab； \r\n   \r\n  null  as ‘null表示的字符串’：说明输出设备的文本中表的NULL值的表示方法，默认为“\\N”； \r\n   \r\n  csv quote as ‘引号类型’ ：说明导出的csv文件中的引号类型是什么， \r\n   \r\n  对于Postgres7.4以前的版本，不支持csv的导入与导出，这时不要使用这个可选项。 \r\n   \r\n  例子： \r\n   \r\n  aa=#\\copy  testtable to data.csv  delimiter as ‘,’ csv quote as ‘”‘ \r\n   \r\n  这条命令将testtable表中的内容作为SQL语句，导出data.csv文件中。 \r\n   \r\n  delimiter as ‘,’   ：说明data.txt文本中表的每个字段用“逗号”分割； \r\n   \r\n  csv quote as ‘”‘ ：说明csv中的引号类型是“双引号”。 \r\n   \r\n  像前面说的：这个例子不适用在Postgres7.4以前的版本。 \r\n   \r\n   \r\n   \r\n  注意文件保存路径默认在： \r\n   \r\n  C:\\Documents and Settings\\zhuyaopeng\\目录下  而且只保存数据，不保存表结构 \r\n   \r\n   \r\n   \r\n  4. 从 文件标识符 导入数据到数据库 \r\n   \r\n   \r\n   \r\n  命令： \r\n   \r\n  \\copy 表名 form 文件名|标准输入 [delimiter  as  ‘分隔符’]  [null  as ‘null表示的字符串’ ]   [csv  quote  as ‘引号的类型’] \r\n  例子： \r\n  aa=#\\copy  testtable from data.csv  delimiter as ‘,’ csv quote as ‘”‘ \r\n   \r\n  这条命令将data.csv文件中的文本，作为sql语句导入到testtable表， \r\n   \r\n  delimiter as ‘,’   ：说明data.txt文本中表的每个字段用“逗号”分割； \r\n   \r\n  csv quote as ‘”‘ ：说明csv中的引号类型是“双引号”。 \r\n   \r\n   \r\n   \r\n  5.如何只选择一个查询结果的头几行？或是随机的一行？ \r\n   \r\n   \r\n   \r\n  如果你只是要提取几行数据，并且你在执行查询中知道确切的行数，你可以使用LIMIT功能。 如果有一个索引与 ORDER BY中的条件匹配，PostgreSQL 可能就只处理要求的头几条记录， （否则将对整个查询进行处理直到生成需要的行）。如果在执行查询功能时不知道确切的记录数， 可使用游标(cursor)和FETCH功能。 \r\n   \r\n  可使用以下方法提取一行随机记录的： \r\n   \r\n    SELECT  cols \r\n    FROM tab \r\n    ORDER BY random() \r\n    LIMIT 1 ;\n',''),(47,'ls','ls lspci -tv 罗列 PCI 设备\nlsusb -tv 显示 USB 设备\nls 查看目录中的文件\nls -F 查看目录中的文件\nls -l 显示文件和目录的详细资料\nls -a 显示隐藏文件\nls *[0-9]* 显示包含数字的文件名和目录名\nlstree 显示文件和目录由根目录开始的树形结构(2)\nls -lSr |more 以尺寸大小排列文件和目录\nls -lh 显示权限\nls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示\nlsattr 显示特殊的属性\n',''),(48,'ln','ln ln -s file1 lnk1 创建一个指向文件或目录的软链接\nln file1 lnk1 创建一个指向文件或目录的物理链接\n',''),(49,'linux','linux linuxcmd linux命令速查手册 \r\n  一. 启动,关机,登入,登出相关命令 \r\n    login 登录 \r\n    logout 登出 \r\n    exit 登出 \r\n    shutdown 停止系统 \r\n    halt 停止系统 \r\n    reboot 重启动 \r\n    poweroff 切断电源 \r\n    sync 把内存里的内容写入磁盘 \r\n    lilo 安装lilo启动管理程序 \r\n    grub 安装lilo启动管理程序 \r\n   \r\n   \r\n  二. Shell相关命令 \r\n    chsh 切换Shell \r\n    history 显示命令履历 \r\n    alias 设置命令别名 \r\n    unalias 取消命令别名 \r\n    which 显示命令所在位置 \r\n    type 查询命令种类 \r\n    echo 显示字符串或者变量内容 \r\n    set 设置/显示Shell变量 \r\n    printenv 显示环境变量 \r\n    export 设置环境变量 \r\n    env 设置临时环境变量 \r\n    unset 释放环境变量 \r\n    setenv 设置环境变量 \r\n    unsetenv 释放环境变量 \r\n    source 执行文件当中的命令 \r\n    man 查询命令手册 \r\n    info 查询超文本命令手册 \r\n    whatis 显示命令简介 \r\n    apropos 通过关键字查询手册 \r\n   \r\n   \r\n  三. 用户管理相关命令 \r\n    su 切换到其他用户 \r\n    useradd 追加用户 \r\n    adduser 追加用户 \r\n    userdel 删除用户 \r\n    usermod 修改用户设置 \r\n    chfn 修改用户私人信息 \r\n    groupadd 追加组 \r\n    groupdel 删除组 \r\n    groupmod 修改组设置 \r\n    passwd 更改密码 \r\n    whoami 显示用户名 \r\n    logname 显示登录用户帐号 \r\n    users 显示所有登录用户信息 \r\n    who 查询登录用户信息 \r\n    w 查询登录用户信息 \r\n    id 显示指定用户的ID信息 \r\n    groups 显示指定用户的所属组 \r\n    finger 显示指定用户的个人信息 \r\n    mesg 开关与他人收发消息 \r\n    write 给其他用户发消息 \r\n    wall 给所有用户发消息 \r\n    talk 和其他用户聊天 \r\n   \r\n   \r\n  四. 系统消息相关命令 \r\n    date 显示/设置当前时间 \r\n    uptime 显示系统运行时间 \r\n    arch 显示机器的核心构架（如i386） \r\n    uname 显示操作系统信息 \r\n    tty 显示终端名 \r\n    last 显示登录/登出在履历 \r\n    lastb 显示非法登录信息 \r\n    dumpkeys 显示当前键盘配置 \r\n    loadkeys 变更键盘配置 \r\n    df 查询磁盘使用信息 \r\n    du 查询磁盘使用信息 \r\n    dmesg 显示系统启动消息 \r\n    script 保存输入输出到文件 \r\n   \r\n   \r\n  五. 文件操作相关命令 \r\n    ls 显示文件列表 \r\n    tree 显示目录树 \r\n    pwd 显示当前路径 \r\n    cd 更改当前路径 \r\n    pushd 追加路径到目录堆栈 \r\n    popd 从目录堆栈删除路径 \r\n    dirs 显示目录堆栈的内容 \r\n    mkdir 创建路径 \r\n    rmdir 删除路径 \r\n    cp 复制文件/目录 \r\n    rm 删除文件/目录 \r\n    mv 移动文件/目录，修改文件名 \r\n    chown 更改文件/目录的所有者 \r\n    chgrp 修改文件/目录的所有组 \r\n    chmod 修改文件/目录的权限 \r\n    touch 更改文件时间 \r\n    ln 建立文件/目录链接 \r\n    find 查找文件 \r\n    whereis 显示文件存在的路径名 \r\n    file 查询文件种类 \r\n    size 查询文件大小 \r\n   \r\n   \r\n  六. 文件编辑相关命令 \r\n    cat 显示文件内容 \r\n    tee 输出到文件和屏幕 \r\n    more 分屏显示文件内容 \r\n    less 分屏显示文件内容 \r\n    head 显示文件头部内容 \r\n    tail 显示文件尾部内容 \r\n    fold 折叠显示长行 \r\n    sort 排列文件的行 \r\n    cmp 比较文件内容 \r\n    diff 显示文件差异 \r\n    nkf 更改日语文件编码 \r\n    dd 变更文件之后复制 \r\n    wc 统计文本单词数，文件大小等 \r\n    split 分割文件 \r\n    paste 以行连接文件 \r\n    join 以字段连接文件 \r\n    grep 查询文字 \r\n    uniq 过滤重复部分显示文件内容 \r\n    tr 替换文字 \r\n    sed 替换文字 \r\n   \r\n   \r\n  七. 压缩/解压缩相关命令 \r\n    ar 压缩/解压缩文件 \r\n    tar 压缩/解压缩文件 \r\n    compress 压缩/解压缩文件 \r\n    uncompress 解压缩 \r\n    gzip 压缩/解压缩文件 \r\n    gunzip 解压缩 \r\n    zcat 显示压缩文件的内容 \r\n    lha 压缩/解压缩文件 \r\n    uuencode 把二进制文件编码为文本文件 \r\n    uudecode 把经过编码的文本文件还原为二进制文件 \r\n   \r\n   \r\n  八. MS-DOS工具集[mtools]命令 \r\n    mdir 显示文件列表 \r\n    mcd 改变当前目录 \r\n    mmd 新建目录 \r\n    mrd 删除目录 \r\n    mdeltree 删除目录树 \r\n    mcopy 复制文件 \r\n    mdel 删除文件 \r\n    mmove 移动文件 \r\n    mren 更改文件或目录名 \r\n    mattrib 修改文件属性 \r\n    mtype 显示文件内容 \r\n    mdu 查询文件或目录大小 \r\n    minfo 显示磁盘信息 \r\n    mformat 以MS-DOS方式格式化磁盘 \r\n    mlabel 设置磁盘标签 \r\n   \r\n   \r\n  九. 控制外部设备相关命令 \r\n    mount mount上设备 \r\n    umount 解除已经mount上的设备 \r\n    eject 弹出（CD/DVD等） \r\n    fdformat 格式化软盘 \r\n    fdisk 配置/显示硬盘分区 \r\n    mkfs 格式化磁盘分区 \r\n    fsck 检查/修复磁盘错误 \r\n    lpr 打印到打印机 \r\n    lprm 中断打印任务 \r\n    lpq 显示打印任务的状态 \r\n    lpc 管理/控制打印任务 \r\n    ifconfig 显示/设定NIC配置 \r\n   \r\n   \r\n  十. 进程及任务管理相关命令 \r\n    ps 显示正在运行的进程 \r\n    jobs 显示后台运行任务 \r\n    fg 把任务切换到前台 \r\n    bg 把任务切换到后台 \r\n    kill 中止进程或任务 \r\n    killall 中止进程或任务 \r\n    wait 等待进程或任务的结束 \r\n    at 设置定时执行任务 \r\n    atq 显示尚未执行的任务 \r\n    atrm 删除定时执行任务 \r\n    batch 在系统负荷减轻的时候执行任务 \r\n    nice 改变优先度并执行任务 \r\n    nohup 在后台执行任务，Logout之后也不退出 \r\n    sleep 休眠一定的时间 \r\n   \r\n   \r\n  十一. 网络管理相关命令 \r\n    ip ip设置,路由,网关等 \r\n    ifconfig 查看ip信息 \r\n    dig 查看路由信息 \r\n    netstat 显示当前网络连接状况 \r\n    route 显示/设置路由 \r\n    host 显示网络主机情况 \r\n    hostname 显示/设置当前主机的名字 \r\n    ping 确认和远程机器的连接情况 \r\n    traceroute 显示路由信息 \r\n    rwho 查询网上机器的登陆用户 \r\n    ruptime 查询网上机器的系统运行时间 \r\n    rlogin 登陆到远程机器 \r\n    telnet 用telnet登陆到远程机器 \r\n    rsh 给远程机器发送命令 \r\n    rcp 在远程机器之间复制文件 \r\n    mail 收取邮件 \r\n    sendmail 发送邮件 \r\n    mailq 确认邮件队列 \r\n    ftp 用ftp传输文件 \r\n   \r\n   \r\n  十一. 其他命令 \r\n    cal 显示日历 \r\n    clear 清屏 \r\n    gcc 编译C语言代码 \r\n    as 汇编 \r\n    bc 计算 \r\n    rpm Redhat的包管理 \r\n    dpkg Debian的包管理 \r\n    installpkg Slackware的包安装（删除命令则是removepkg） \r\n    XF86Setup,turboxfg,Xconfigurator 配置 X 服务器 \r\n    startx 启动 X-Window 系统 \r\n    附：组合命令 \r\n    重定向，如 \r\n    $ ls -l /bin  ls-output \r\n    $ more ls-output \r\n    管道命令，如 \r\n    $ cat file1 file2 | sort | uniq \r\n    经常被用于管道的命令 \r\n    awk, fold, grep, head, nnkf, pr, sed, sort, tail, tee, tr, uniq, wc\n',''),(50,'openvswitch','openvswitch openvswitch 使用说明\r\n \r\n  一、  网桥管理 \r\n    添加名为br0的网桥 \r\n    ovs-vsctl add-br br0 \r\n    删除名为br0的网桥 \r\n    ovs-vsctl del-br br0 \r\n    列出所有网桥 \r\n    ovs-vsctl list-br \r\n    判断网桥br0是否存在 \r\n    ovs-vsctl br-exists br0 \r\n    列出挂接到网桥br0上的所有网络接口 \r\n    ovs-vsctl list-ports br0 \r\n    将网络接口eth0挂接到网桥br0上 \r\n    ovs-vsctl add-port br0 eth0 \r\n    删除网桥br0上挂接的eth0网络接口 \r\n    ovs-vsctl del-port br0 eth0 \r\n    列出已挂接eth0网络接口的网桥 \r\n    ovs-vsctl port-to-br eth0 \r\n   \r\n  二、  网桥管理（ovsdb数据库操作） \r\n    ovsdb是一个非常轻量级的数据库，与其说它是一个数据库，不如说它是一个提供增删查改等功能的临时配置缓存，之所以这么说，是因为ovsdb数据库的根本就未使用多少数据库技术，如SQL语言查询、存储过程等等。ovsdb 数据库通过模式文件“openvswitch-1.1.0pre2/vswitchd/vswitch.ovsschema”，如要定制ovsdb数据库，可通过更改 vswitch.ovsschema 文件实现，不过以下姑且仍以数据库称之。 \r\n   \r\n    数据库操作的一般格式为： \r\n    ovs-vsctl list/set/get/add/remove/clear/destroy table record column [value] \r\n    默认情况下ovsdb中有以下数据表： \r\n    bridge, controller,interface,mirror,netflow,open_vswitch,port,qos,queue,ssl,sflow \r\n    即table可为上面的任一个。record为数据表中name字段的值，column为数据表任一个字段的字段名，value字段值。 \r\n    基本操作： \r\n    查看bridge数据表中的所有记录 \r\n   \r\n    获得bridge数据表_uuid字段的值 \r\n   \r\n    设置bridge数据表datapath_type字段的值 \r\n   \r\n    清除bridge数据表flood_vlans字段的值 \r\n    ovs-vsctl remove bridge xenbr0 flood_vlans 23 \r\n    或者 \r\n    ovs-vsctl clear bridge xenbr0 flood_vlans \r\n    删除uuid为69ee0c09-9e52-4236-8af6-037a98ca704d的qos记录 \r\n    ovs-vsctl destroy qos 69ee0c09-9e52-4236-8af6-037a98ca704d \r\n  三、  应用场景设置： \r\n    \r\n    1)QoS设置 \r\n   \r\n    针对网络接口的设置：设置网络接口vif0.0的带宽为1000±100kbps \r\n    ovs-vsctl set interface vif0.0 ingress_policing_rate=1000 \r\n    ovs-vsctl set interface vif0.0 ingress_policing_burst=100 \r\n    (ingress_policing_rate:最大发送速率（单位均为kbps） \r\n    ingress_policing_burst:超过ingress_policing_rate的最大浮动值) \r\n    针对交换机端口的设置：创建在vif0.0端口上的linux-htb QoS，linux-htb QoS可以针对具有指定特征的数据包流设置最大最小带宽，且在最大带宽范围内，某一特征的数据包流可以借用其他特征数据包流未用完的带宽。 \r\n    ovs-vsctl -- set port vif0.0 qos=@newqos \r\n    -- --id=@newqos create qos type=linux-htb other-config: \r\n    max-rate=100000000 queues=0=@q0,1=@q1 \r\n    -- --id=@q0 create queue other-config:min-rate=100000000 other-config:max-rate=100000000 \r\n    -- --id=@q1 create queue other-config:min-rate=500000000 \r\n    将带宽限制加于某特征数据包流上 \r\n    (假设vif0.0的接在交换机1号端口上，ovs-ofctl命令的使用见2.2.3) \r\n    ovs-ofctl add-flow xenbr0 \"in_port=2,idle_timeout=0,actions=enqueue:1:0\" \r\n    \r\n    2)端口映射 \r\n   \r\n    将发往eth0端口和从eth1端口发出的数据包全部定向到eth2端口 \r\n    （假设eth0、eth1、eth2端口的uuid分别为： \r\n    69ee0c09-9e52-4236-8af6-037a98ca704d \r\n    69ee0c09-9e52-4236-8af6-037a98ca704e \r\n    69ee0c09-9e52-4236-8af6-037a98ca704f \r\n    端口的uuid可以通过ovs-vsctl list port命令查看） \r\n    ovs-vsctl -- set bridge xenbr0 mirrors=@m \r\n    -- --id=@m create mirror name=mymirror \r\n    select-dst-port=69ee0c09-9e52-4236-8af6-037a98ca704d \r\n    select-src-port=69ee0c09-9e52-4236-8af6-037a98ca704e \r\n    output-port=69ee0c09-9e52-4236-8af6-037a98ca704f \r\n    \r\n    3)流规则管理 流规则组成 \r\n   \r\n    每条流规则由一系列字段组成，分为基本字段、条件字段和动作字段三部分： \r\n    基本字段包括生效时间duration_sec、所属表项table_id、优先级priority、处理的数据包数n_packets，空闲超时时间idle_timeout等，空闲超时时间idle_timeout以秒为单位，超过设置的空闲超时时间后该流规则将被自动删除，空闲超时时间设置为0表示该流规则永不过期，idle_timeout将不包含于ovs-ofctl dump-flows brname的输出中。 \r\n   \r\n    条件字段包括输入端口号in_port、源目的mac地址dl_src/dl_dst、源目的ip地址nw_src/nw_dst、数据包类型dl_type、网络层协议类型nw_proto等，可以为这些字段的任意组合，但在网络分层结构中底层的字段未给出确定值时上层的字段不允许给确定值，即一条流规则中允许底层协议字段指定为确定值，高层协议字段指定为通配符(不指定即为匹配任何值)，而不允许高层协议字段指定为确定值，而底层协议字段却为通配符(不指定即为匹配任何值)，否则，ovs-vswitchd 中的流规则将全部丢失，网络无法连接。 \r\n   \r\n    动作字段包括正常转发normal、定向到某交换机端口output：port、丢弃drop、更改源目的mac地址mod_dl_src/mod_dl_dst等，一条流规则可有多个动作，动作执行按指定的先后顺序依次完成。 \r\n    基本操作 \r\n    查看虚拟交换机xenbr0的信息 \r\n   \r\n    显示的xenbr0信息中网络接口名称前的数字为该网络接口挂接到Open vSwitch上的端口号，如1(vif0.0): 中的1为网络接口vif0.0对应的端口号，在添加包含in_port字段的流规则时可通过该命令查看网络接口对应的端口号。 \r\n    查看xenbr0上各交换机端口的状态 \r\n   \r\n    输出的结果中包含了各网络接口上收到的数据包数，字节数，丢包数，错误数据包数等信息 \r\n    查看xenbr0上的所有流规则 \r\n   \r\n    输出结果中共有两条流规则，第一条为默认的流规则，即对所有数据包进行正常转发，为普通二层交换机完成的功能，优先级为0，最低，永不超时。 \r\n    第二条为手动添加的流规则，基本字段中不包含idle_timeout字段，表示永不超时，优先级为32768，Open vSwitch将先根据该条流规则处理收到的数据包，如从数据包中提取出的特征与条件字段不符，则该用第一条流规则处理收到的所有数据包。 \r\n    添加一条流规则：丢弃从2号端口发来的所有数据包 \r\n   \r\n    删除一条流规则：删除条件字段中包含in_port=2的所有流规则 \r\n   \r\n   \r\n    流规则中可包含通配符和简写形式，任何字段都可等于*或ANY，如： \r\n    丢弃所有收到的数据包 \r\n    ovs-ofctl add-flow xenbr0 dl_type=*,nw_src=ANY,actions=drop \r\n    简写形式为将字段组简写为协议名，目前支持的简写有ip，arp，icmp，tcp，udp，与流规则条件字段的对应关系如下: \r\n    dl_type=0x0800 <=>ip \r\n    dl_type=0x0806 <=>arp \r\n    dl_type=0x0800，nw_proto=1 <=> icmp \r\n    dl_type=0x0800，nw_proto=6 <=> tcp \r\n    dl_type=0x0800，nw_proto=17 <=> udp \r\n   \r\n   \r\n    （1.1.0 即以后版本支持） \r\n    dl_type=0x86dd. <=> ipv6 \r\n    dl_type=0x86dd,nw_proto=6. <=> tcp6 \r\n    dl_type=0x86dd,nw_proto=17. <=> udp6 \r\n    dl_type=0x86dd,nw_proto=58. <=> icmp6 \r\n   \r\n    \r\n    4)应用场景设置 网站屏蔽 \r\n   \r\n    屏蔽由Open vSwitch管理的任何主机对主机119.75.213.50的访问，但只屏蔽ip数据包(由dl_type=0x0800指定)，即所有主机将无法访问该主机上所有基于IP协议的服务，如万维网服务、FTP访问等 \r\n    ovs-ofctl add-flow xenbr0 idle_timeout=0,dl_type=0x0800,nw_src=119.75.213.50,actions=drop \r\n    数据包重定向 \r\n    将交换机中所有的icmp协议包（有dl_type=0x0800,nw_proto=1指定）全部转发到4号端口，包括4号端口自己发出的icmp包，该流规则将导致由Open vSwitch管理的主机间以及与外部网络间都将访问ping通，但可以使用万维网、FTP等服务。 \r\n    ovs-ofctl add-flow xenbr0 idle_timeout=0,dl_type=0x0800,nw_proto=1,actions=output:4 \r\n    去除VLAN tag \r\n    去除从3号端口发来的所有VLAN数据包中的tag，然后转发 \r\n    ovs-ofctl add-flow xenbr0 idle_timeout=0,in_port=3,actions=strip_vlan,normal \r\n    更改数据包源IP地址后转发 \r\n    将从3号端口收到的所有IP包的源IP字段更改为211.68.52.32 \r\n    ovs-ofctl add-flow xenbr0 idle_timeout=0,in_port=3,actions=mod_nw_src:211.68.52.32,normal \r\n    内核模块中flow操作 \r\n    查看内核模块flow \r\n    ovs-dpctl dump-flows xenbr0 \r\n   \r\n    \r\n    5)后台模块控制，如日志系统、后台模块退出 \r\n   \r\n    查看后台模块支持的appctl命令 \r\n    查看ovsdb-server支持的appctl命令，ovs-appctl必须在后台模块运行后才能针对后台模块使用，默认情况下，所有运行的后台模块都会在/usr/local/var/run/openvswitch/目录下创建一个与ovs-appctl通信的socket文件 \r\n   \r\n    更改Open vSwitch各后台的模块的日志级别 \r\n    更改ovs-vswitchd模块的日志级别info，“ANY:ANY:info”中的前一个“ANY”代表ovs-vswitchd中的任何模块组件，“ovs-appctl --target=/usr/local/var/run/openvswitch/ \r\n    ovs-vswitchd.29384.ctl vlog/list”命令输出的第一列将为ovs-vswitchd包含的所有模块组件。“ANY:ANY:info”中的后一个“ANY”代表日志的任何方式的输出，日志的输出方式有三种，分别为：console，syslog，file，分别代表将日志输出到控制台、写入到系统日志系统和写入到ovs-vswitchd启动时由—log-file参数指定的文件。“ANY:ANY:info”中的“info”表示日志级别，共有emer、err、warn、info、dbg五个日志级别，dbg为最低级别，指定为dbg时，所有的日志信息都将输出，但此时可能导致日志系统迅速膨胀，而占用越来越多的硬盘存储空间。 \r\n    ovs-appctl --target=/usr/local/var/run/openvswitch/ovs-vswitchd.29384.ctl vlog/set \r\n    ANY:ANY:info \r\n    退出后台模块 \r\n    让ovs-vswitchd停止运行 \r\n    ovs-appctl --target=/usr/local/var/run/openvswitch/ovs-vswitchd.29384.ctl exit\n',''),(51,'rpm','rpm rpm -q -a --qf \'%10{SIZE}t%{NAME}n\' | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)\nRPM 包 - （Fedora, Redhat及类似系统）\nrpm -ivh package.rpm 安装一个rpm包\nrpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告\nrpm -U package.rpm 更新一个rpm包但不改变其配置文件\nrpm -F package.rpm 更新一个确定已经安装的rpm包\nrpm -e package_name.rpm 删除一个rpm包\nrpm -qa 显示系统中所有已经安装的rpm包\nrpm -qa | grep httpd 显示所有名称中包含 \"httpd\" 字样的rpm包\nrpm -qi package_name 获取一个已安装包的特殊信息\nrpm -qg \"System Environment/Daemons\" 显示一个组件的rpm包\nrpm -ql package_name 显示一个已经安装的rpm包提供的文件列表\nrpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表\nrpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表\nrpm -q package_name --whatprovides 显示一个rpm包所占的体积\nrpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l\nrpm -q package_name --changelog 显示一个rpm包的修改历史\nrpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供\nrpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表\nrpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书\nrpm --checksig package.rpm 确认一个rpm包的完整性\nrpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性\nrpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间\nrpm -Va 检查系统中所有已安装的rpm包- 小心使用\nrpm -Vp package.rpm 确认一个rpm包还未安装\nrpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件\nrpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包\nrpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包\n',''),(52,'for','for for 循环语句 \r\n  EX1 for循环遍历数组: \r\n   \r\n  #!/bin/sh \r\n  WORD=\"a b c d e f g h i j l m n o p q r s t u v w x y z\" \n  for i in $WORD ; do   // 遍历WORD变量里面的数据 \r\n  echo $i                     // 输出WORD数据集中的没有元素 \r\n  done                         // 循环结束 \r\n  程序依次读入WORD中的元素赋给变量i,然后输出i的值,有没有发现,shell的语法中,变量没有数据类型?是的,就是这样.  \r\n   \r\n  EX2 for循环遍历文件: \r\n   \r\n  #!/bin/sh \r\n  FILES=`ls /txt/*.txt` \r\n  for txt in $FILES ; do  \r\n  mv $txt /newDir/$txt \r\n  done \r\n  以上代码是将/txt/*.txt转移到新目录下，数据集来源于ls指令的结果，通过重定向输入到变量FILES中。 \r\n   \r\n   \r\n  EX3 while循环: \r\n   \r\n  #!/bin/sh \r\n  while : ; do \r\n  echo \"do something forever here\" \r\n  sleep 5 \r\n  done \r\n  无限循环打印\"do something forever here\" ，间隔5秒\n','// 注意,等号两边不要留空格.这会产生运行错误.  \r'),(53,'qemu','qemu qemu 简要说明\r\n \r\n    qemu是一款很好的虚拟机，下面废话不说，直接说安装过程。 \r\n   \r\n  （1）安装qemu    \r\n   \r\n    仿真ARM需要使用qemu-system-arm，安装模拟器    \r\n   \r\n    sudo apt-get install  qemu-kvm qemu-kvm-extras \r\n   \r\n  （2）下载内核镜像。以下名称叫ubuntu.iso \r\n   \r\n  （3）创建一个虚拟磁盘 \r\n   \r\n    sudo qemu-img create -f qcow2 /opt/vm/ubuntu1010.img 10G \r\n   \r\n  （4）安装虚拟机操作系统 \r\n   \r\n    sudo qemu-system-x86_64 -hda /opt/vm/ubuntu1010.img -cdrom /opt/iso/ubuntu.iso -boot d -m 1024 -no-acpi \r\n   \r\n    -hda 指定了硬盘是哪个虚拟磁盘，这里用刚刚创建的ubuntu1010.img \r\n   \r\n    -cdrom指定cdrom是哪个，可以用iso文件，烨可以用机器光驱，我们选择用iso文件。 \r\n   \r\n    -boot指定启动的时候从磁盘，硬盘，光驱还是网络上启动，我们安装的时候选择从光驱启动，所以用d \r\n   \r\n    -m虚拟机使用的内存大小，单位是MB，默认是128mb，这个用1024 \r\n   \r\n    -no-acpi由于qemu支持不大好导致系统很慢，所以暂时禁止掉。 \r\n   \r\n    进入之后安装向导安装即可。 \r\n   \r\n  （ 5）启动虚拟机 \r\n   \r\n    sudo qemu-system-x86_64 /opt/vm/ubuntu1010.img -m 1024\n',''),(54,'jquery','jquery jquery 选择器\r\njQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 \r\n   \r\n  常用选择器 \r\n   \r\n    $(\"#myELement\")    选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素 \r\n    $(\"div\")           选择所有的div标签元素，返回div元素数组 \r\n    $(\".myClass\")      选择使用myClass类的css的所有元素 \r\n    $(\"*\")             选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$(\"#myELement,div,.myclass\") \r\n   \r\n  层叠选择器： \r\n   \r\n    $(\"form input\")         选择所有的form元素中的input元素 \r\n    $(\"#main > *\")          选择id值为main的所有的子元素 \r\n    $(\"label + input\")     选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素 \r\n    $(\"#prev ~ div\")       同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 \r\n   \r\n  基本过滤选择器： \r\n   \r\n    $(\"tr:first\")               选择所有tr元素的第一个 \r\n    $(\"tr:last\")                选择所有tr元素的最后一个 \r\n    $(\"input:not(:checked) + span\")   \r\n   \r\n  过滤掉：checked的选择器的所有的input元素 \r\n   \r\n    $(\"tr:even\")               选择所有的tr元素的第0，2，4... ...个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始） \r\n     \r\n    $(\"tr:odd\")                选择所有的tr元素的第1，3，5... ...个元素 \r\n    $(\"td:eq(2)\")             选择所有的td元素中序号为2的那个td元素 \r\n    $(\"td:gt(4)\")             选择td元素中序号大于4的所有td元素 \r\n    $(\"td:ll(4)\")              选择td元素中序号小于4的所有的td元素 \r\n    $(\":header\") \r\n    $(\"div:animated\") \r\n   \r\n  内容过滤选择器： \r\n   \r\n    $(\"div:contains(\'John\')\") 选择所有div中含有John文本的元素 \r\n    $(\"td:empty\")           选择所有的为空（也不包括文本节点）的td元素的数组 \r\n    $(\"div:has(p)\")        选择所有含有p标签的div元素 \r\n    $(\"td:parent\")          选择所有的以td为父节点的元素数组 \r\n   \r\n  可视化过滤选择器： \r\n   \r\n    $(\"div:hidden\")        选择所有的被hidden的div元素 \r\n    $(\"div:visible\")        选择所有的可视化的div元素 \r\n   \r\n  属性过滤选择器： \r\n   \r\n    $(\"div[id]\")              选择所有含有id属性的div元素 \r\n    $(\"input[name=\'newsletter\']\")    选择所有的name属性等于\'newsletter\'的input元素 \r\n     \r\n    $(\"input[name!=\'newsletter\']\") 选择所有的name属性不等于\'newsletter\'的input元素 \r\n     \r\n    $(\"input[name^=\'news\']\")         选择所有的name属性以\'news\'开头的input元素 \r\n    $(\"input[name$=\'news\']\")         选择所有的name属性以\'news\'结尾的input元素 \r\n    $(\"input[name*=\'man\']\")          选择所有的name属性包含\'news\'的input元素 \r\n     \r\n    $(\"input[id][name$=\'man\']\")    可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 \r\n   \r\n  子元素过滤选择器： \r\n   \r\n    $(\"ul li:nth-child(2)\"),$(\"ul li:nth-child(odd)\"),$(\"ul li:nth-child(3n + 1)\") \r\n     \r\n    $(\"div span:first-child\")          返回所有的div元素的第一个子节点的数组 \r\n    $(\"div span:last-child\")           返回所有的div元素的最后一个节点的数组 \r\n    $(\"div button:only-child\")       返回所有的div中只有唯一一个子节点的所有子节点的数组 \r\n   \r\n  表单元素选择器： \r\n   \r\n    $(\":input\")                  选择所有的表单输入元素，包括input, textarea, select 和 button \r\n     \r\n    $(\":text\")                     选择所有的text input元素 \r\n    $(\":password\")           选择所有的password input元素 \r\n    $(\":radio\")                   选择所有的radio input元素 \r\n    $(\":checkbox\")            选择所有的checkbox input元素 \r\n    $(\":submit\")               选择所有的submit input元素 \r\n    $(\":image\")                 选择所有的image input元素 \r\n    $(\":reset\")                   选择所有的reset input元素 \r\n    $(\":button\")                选择所有的button input元素 \r\n    $(\":file\")                     选择所有的file input元素 \r\n    $(\":hidden\")               选择所有类型为hidden的input元素或表单的隐藏域 \r\n   \r\n  表单元素过滤选择器： \r\n   \r\n    $(\":enabled\")             选择所有的可操作的表单元素 \r\n    $(\":disabled\")            选择所有的不可操作的表单元素 \r\n    $(\":checked\")            选择所有的被checked的表单元素 \r\n    $(\"select option:selected\") 选择所有的select 的子元素中被selected的元素 \r\n   \r\n    \r\n   \r\n  选取一个 name 为”S_03_22″的input text框的上一个td的text值 \r\n  $(”input[@ name =S_03_22]“).parent().prev().text() \r\n   \r\n  名字以”S_”开始，并且不是以”_R”结尾的 \r\n  $(”input[@ name ^=\'S_\']“).not(”[@ name $=\'_R\']“) \r\n   \r\n  一个名为 radio_01的radio所选的值 \r\n  $(”input[@ name =radio_01][@checked]“).val(); \r\n   \r\n    \r\n   \r\n    \r\n   \r\n  $(\"A B\") 查找A元素下面的所有子节点，包括非直接子节点 \r\n  $(\"A>B\") 查找A元素下面的直接子节点 \r\n  $(\"A+B\") 查找A元素后面的兄弟节点，包括非直接子节点 \r\n  $(\"A~B\") 查找A元素后面的兄弟节点，不包括非直接子节点 \r\n   \r\n  1. $(\"A B\") 查找A元素下面的所有子节点，包括非直接子节点 \r\n   \r\n  例子：找到表单中所有的 input 元素 \r\n   \r\n  HTML 代码: \r\n   \r\n  <form> \r\n  <label>Name:</label> \r\n  <input name=\"name\" /> \r\n  <fieldset> \r\n        <label>Newsletter:</label> \r\n        <input name=\"newsletter\" /> \r\n  </fieldset> \r\n  </form> \r\n  <input name=\"none\" /> \r\n  jQuery 代码: \r\n   \r\n  $(\"form input\") \r\n  结果: \r\n   \r\n  [ <input name=\"name\" />, <input name=\"newsletter\" /> ] \r\n   \r\n  2. $(\"A>B\") 查找A元素下面的直接子节点 \r\n  例子：匹配表单中所有的子级input元素。 \r\n   \r\n  HTML 代码: \r\n   \r\n  <form> \r\n  <label>Name:</label> \r\n  <input name=\"name\" /> \r\n  <fieldset> \r\n        <label>Newsletter:</label> \r\n        <input name=\"newsletter\" /> \r\n  </fieldset> \r\n  </form> \r\n  <input name=\"none\" /> \r\n  jQuery 代码: \r\n   \r\n  $(\"form > input\") \r\n  结果: \r\n   \r\n  [ <input name=\"name\" /> ] \r\n   \r\n  3. $(\"A+B\") 查找A元素后面的兄弟节点，包括非直接子节点 \r\n  例子：匹配所有跟在 label 后面的 input 元素 \r\n   \r\n  HTML 代码: \r\n   \r\n  <form> \r\n  <label>Name:</label> \r\n  <input name=\"name\" /> \r\n  <fieldset> \r\n        <label>Newsletter:</label> \r\n        <input name=\"newsletter\" /> \r\n  </fieldset> \r\n  </form> \r\n  <input name=\"none\" /> \r\n  jQuery 代码: \r\n   \r\n  $(\"label + input\") \r\n  结果: \r\n   \r\n  [ <input name=\"name\" />, <input name=\"newsletter\" /> ] \r\n   \r\n   \r\n  4. $(\"A~B\") 查找A元素后面的兄弟节点，不包括非直接子节点 \r\n  例子：找到所有与表单同辈的 input 元素 \r\n   \r\n  HTML 代码: \r\n   \r\n  <form> \r\n  <label>Name:</label> \r\n  <input name=\"name\" /> \r\n  <fieldset> \r\n        <label>Newsletter:</label> \r\n        <input name=\"newsletter\" /> \r\n  </fieldset> \r\n  </form> \r\n  <input name=\"none\" /> \r\n  jQuery 代码: \r\n   \r\n  $(\"form ~ input\") \r\n  结果: \r\n   \r\n  [ <input name=\"none\" /> ]\n',''),(55,'shell','shell shell \r\n  一、基本语法 \r\n   \r\n  1.1、shell文件开头 \r\n   \r\n    shell文件必须以下面的行开始（必须方在文件的第一行）： \r\n    #!/bin/sh \r\n    符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。 \r\n    当编辑好脚本时，如果要执行该脚本，还必须使其可执行。 \r\n    要使脚本可执行： \r\n    运行chmod +x filename 这样才能用./filename 来运行 \r\n   \r\n  1.2 注释 \r\n   \r\n    在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。 \r\n    如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用 \r\n    及工作原理。 \r\n   \r\n  1.3 变量 \r\n   \r\n    在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明，直接赋值就可以，应用变量的话，用$+变量名的形式。 \r\n    要赋值给一个变量，您可以这样写： \r\n    a=\"hello world\" \r\n    现在打印变量a的内容： \r\n    echo \"A is:\" \r\n    echo $a \r\n    有时候变量名很容易与其他文字混淆，比如： \r\n    num=2 \r\n    echo \"this is the $numnd\" \r\n    这并不会打印出\"this is the 2nd\"，而仅仅打印\"this is the \"，因为shell会去搜索变量numnd的值， \r\n    但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量： \r\n    num=2 \r\n    echo \"this is the ${num}nd\" \r\n    这将打印： this is the 2nd \r\n   \r\n  1.4 环境变量 \r\n   \r\n    由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录 \r\n    脚本中使用环境变量。 \r\n   \r\n  二、概念: 管道, 重定向和 backtick \r\n   \r\n   \r\n    这些不是系统命令，但是他们真的很重要。 \r\n    管道 (|)： 将一个命令的输出作为另外一个命令的输入。 \r\n    grep \"hello\" file.txt | wc -l \r\n    在file.txt中搜索包含有”hello”的行并计算其行数。 \r\n    在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。 \r\n    重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。 \r\n    > 写入文件并覆盖旧文件 \r\n    >> 加到文件的尾部，保留旧文件内容。 \r\n    反短斜线 \r\n    使用反短斜线(\"`\")可以将一个命令的输出作为另外一个命令的一个命令行参数。 \r\n    命令： \r\n    find . -mtime -1 -type f -print \r\n    用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您 \r\n    想将所有查找到的文件打一个包，则可以使用以下脚本： \r\n    #!/bin/sh \r\n    # The ticks are backticks (`) not normal quotes (\'): \r\n    tar -zcvf lastmod.tar.gz `find . -mtime -1 -type f -print` \r\n   \r\n  三、 流程控制语句 \r\n   \r\n  3.1、if \r\n   \r\n    \"if\" 表达式 如果条件为真则执行then后面的部分： \r\n    if ....; then \r\n    ....  \r\n    elif ....; then \r\n    ....  \r\n    else \r\n    ....  \r\n    fi \r\n   \r\n    大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件 \r\n    是否存在及是否可读等等… \r\n    通常用\" [ ] \"来表示条件测试。注意这里的空格很重要。要确保方括号的空格。 \r\n    [ -f \"somefile\" ] ：判断是否是一个文件 \r\n    [ -x \"/bin/ls\" ] ：判断/bin/ls是否存在并有可执行权限 \r\n    [ -n \"$var\" ] ：判断$var变量是否有值 \r\n    [ \"$a\" = \"$b\" ] ：判断$a和$b是否相等 ,注意“=”和变量之间要有空格。 \r\n    执行man test可以查看所有测试表达式可以比较和判断的类型。 \r\n    直接执行以下脚本： \r\n    #!/bin/sh \r\n    if [ \"$SHELL\" = \"/bin/bash\" ]; then \r\n    echo \"your login shell is the bash (bourne again shell)\" \r\n    else \r\n    echo \"your login shell is not bash but $SHELL\" \r\n    fi \r\n    变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。 \r\n   \r\n  3.2、快捷操作符&&和|| \r\n   \r\n    熟悉C语言的朋友可能会很喜欢下面的表达式： \r\n    [ -f \"/etc/shadow\" ] && echo \"This computer uses shadow passwors\" \r\n    这里 && 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。 \r\n    您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在 \r\n    则打印” This computer uses shadow passwors”。同样或操作(||)在shell编程中也是 \r\n    可用的。这里有个例子： \r\n    #!/bin/sh \r\n    mailfolder=/var/spool/mail/james \r\n    [ -r \"$mailfolder\" ]||{ echo \"Can not read $mailfolder\" ; exit 1; } \r\n    echo \"$mailfolder has mail from:\" \r\n    grep \"^From \" $mailfolder \r\n    该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的\"From\" 一行。如果不可读 \r\n    则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令： \r\n    -打印错误信息 \r\n    -退出程序 \r\n    我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。 \r\n    不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。 \r\n   \r\n  3.3、case \r\n   \r\n    case :表达式可以用来匹配一个给定的字符串，而不是数字。 \r\n    case ... in \r\n    ...) do something here ;; \r\n    esac \r\n    以下是一个使用case的实例： \r\n    dirs=`ls $sourceRoot/android | tr \'\r\n\' \' \'` \r\n    for i in $dirs \r\n    do \r\n    sourceFold=$sourceRoot/android/${i} \r\n    case ${i} in \r\n    out) \r\n    echo \"skip ${i}\";; \r\n    kernel|frameworks|vendor|build) \r\n    cp -rfu $sourceFold $workRoot/android \r\n    echo \"copy ${i}\";; \r\n    *) \r\n    ln -sf $sourceFold $workRoot/android \r\n    echo \"linking ${i}\";; \r\n    esac \r\n    done \r\n    再让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如： \r\n    file lf.gz \r\n    这将返回： \r\n    lf.gz: gzip compressed data, deflated, original filename, \r\n    last modified: Mon Aug 27 23:09:18 2001, os: Unix \r\n    下面有个一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件： \r\n    #!/bin/sh \r\n    ftype=`file \"$1\"` \r\n    case \"$ftype\" in \r\n    \"$1: Zip archive\"*) \r\n    unzip \"$1\" ;; \r\n    \"$1: gzip compressed\"*) \r\n    gunzip \"$1\" ;; \r\n    \"$1: bzip2 compressed\"*) \r\n    bunzip2 \"$1\" ;; \r\n    *) echo \"File $1 can not be uncompressed with smartzip\";; \r\n    esac \r\n    您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一个参数值。 \r\n    也就是说，当我们运行： \r\n    smartzip articles.zip \r\n    $1 就是字符串 articles.zip \r\n   \r\n  3.4、 selsect \r\n   \r\n    select 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。 \r\n    select var in ... ; do \r\n    break \r\n    done \r\n    .... now $var can be used ....  \r\n    下面是一个例子： \r\n    #!/bin/sh \r\n    echo \"What is your favourite OS?\" \r\n    select var in \"Linux\" \"Gnu Hurd\" \"Free BSD\" \"Other\"; do \r\n    break \r\n    done \r\n    echo \"You have selected $var\" \r\n    下面是该脚本运行的结果： \r\n    What is your favourite OS?  \r\n    1) Linux \r\n    2) Gnu Hurd \r\n    3) Free BSD \r\n    4) Other \r\n    #? 1 \r\n    You have selected Linux \r\n    注意：select是扩展应用。 \r\n   \r\n  3.4、while \r\n   \r\n    while表达式： \r\n    while ...; do \r\n    ....  \r\n    done \r\n    当while中的表达式为真时，将一直循环。 \r\n    可以用关键字\"break\" 用来跳出循环；也可以用关键字”continue”用来不执行余下的部分而直接跳到下一个循环。 \r\n    实例3-4-1 \r\n    #!/bin/sh \r\n    num=10 \r\n    while [ ! \"$num\" = \"0\" ]; do \r\n    #num=num-1 \r\n    num=`expr \"$num\" \"-\" \"1\"` \r\n    echo $num \r\n    done \r\n    3.5、for \r\n    for-loop表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量： \r\n    for var in ....; do \r\n    ....  \r\n    done \r\n    在下面的例子中，将分别打印ABC到屏幕上： \r\n    #!/bin/sh \r\n    for var in A B C ; do \r\n    echo \"var is $var\" \r\n    done \r\n    下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息： \r\n    #!/bin/sh \r\n    # list a content summary of a number of RPM packages \r\n    # USAGE: showrpm rpmfile1 rpmfile2 ...  \r\n    # EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm \r\n    for rpmpackage in $*; do \r\n    if [ -r \"$rpmpackage\" ];then \r\n    echo \"=============== $rpmpackage ==============\" \r\n    rpm -qi -p $rpmpackage \r\n    else \r\n    echo \"ERROR: cannot read file $rpmpackage\" \r\n    fi \r\n    done \r\n    这里出现了第二个特殊的变量$*，该变量包含了所有输入的命令行参数值。 \r\n    如果您运行showrpm openssh.rpm w3m.rpm webgrep.rpm \r\n    此时 $* 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm.  \r\n   \r\n  四、引号 \r\n   \r\n    在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通配符 \r\n    （比如*）替换成合适的文件名，它变量替换成变量值。为了防 止程序作这种替换，您可以使用 \r\n    引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg文件， mail.jpg 和tux.jpg。 \r\n    echo *.jpg \r\n    这将打印出\"mail.jpg tux.jpg\"的结果。 \r\n    引号 (单引号和双引号) 将防止这种通配符扩展： \r\n    #!/bin/sh \r\n    echo \"*.jpg\" \r\n    echo \'*.jpg\' \r\n    这将打印\"*.jpg\" 两次。 \r\n    单引号更严格一些。它可以防止任何变量扩展。双引号可以防止通配符扩展但允许变量扩展。 \r\n    #!/bin/sh \r\n    echo $SHELL \r\n    echo \"$SHELL\" \r\n    echo \'$SHELL\' \r\n    运行结果为： \r\n    /bin/bash \r\n    /bin/bash \r\n    $SHELL \r\n    最后，还有一种防止这种扩展的方法，那就是使用转义字符——反斜杆： \r\n    echo \\*.jpg \r\n    echo \\$SHELL \r\n    这将输出： \r\n    *.jpg \r\n    $SHELL \r\n   \r\n  五、函数 \r\n   \r\n    如果您写了一些稍微复杂一些的程序，您就会发现在程序中可能在几个地方使用了相同的代码， \r\n    并且您也会发现，如果我们使用了函数，会方便很多。一个函数是这个样子的： \r\n    functionname() \r\n    { \r\n    # inside the body $1 is the first argument given to the function \r\n    # $2 the second ...  \r\n    body \r\n    } \r\n    您需要在每个程序的开始对函数进行声明。 \r\n    下面是一个叫做xtitlebar的脚本，使用这个脚本您可以改变终端窗口的名称。 \r\n    这里使用了一个叫做help的函数。正如您可以看到的那样，这个定义的函数被使用了两次。 \r\n    #!/bin/sh \r\n    # vim: set sw=4 ts=4 et: \r\n    help() \r\n    { \r\n    cat << HELP \r\n    xtitlebar -- change the name of an xterm, gnome-terminal or kde konsole \r\n    USAGE: xtitlebar [-h] \"string_for_titelbar\" \r\n    OPTIONS: -h help text \r\n    EXAMPLE: xtitlebar \"cvs\" \r\n    HELP \r\n    exit 0 \r\n    } \r\n    # in case of error or if -h is given we call the function help: \r\n    [ -z \"$1\" ] && help \r\n    [ \"$1\" = \"-h\" ] && help \r\n    # send the escape sequence to change the xterm titelbar: \r\n    echo $1 \r\n    echo -e \"33]0;\"$1\"07\" \r\n    # \r\n    在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。命令行参数我们已经见过$* 和 $1, $2 ... $9 等特殊变量，这些特殊变量包含了用户从命令行输入的参数。迄今为止，我们仅仅了解了一些简单的命令行语法（比如一些强制性的参数和查看帮助的-h选项）。 但是在编写更复杂的程序时，您可能会发现您需要更多的自定义的选项。通常的惯例是在所有可选的参数之前加一个减号，后面再加上参数值 (比如文件名)。 有好多方法可以实现对输入参数的分析，但是下面的使用case表达式的例子无疑是一个不错的方法。 \r\n    文件test.sh \r\n    #!/bin/sh \r\n    help() \r\n    { \r\n    cat << HELP \r\n    This is a generic command line parser demo.  \r\n    USAGE EXAMPLE: cmdparser -l hello -f somefile1 somefile2 \r\n    HELP \r\n    exit 0 \r\n    } \r\n    while [ -n \"$1\" ]; do \r\n    case $1 in \r\n    -h) help;shift 1;; # function help is called \r\n    -f) opt_f=1;shift 1;; # variable opt_f is set \r\n    -l) opt_l=$2;shift 2;; # -l takes an argument -> shift by 2 \r\n    -*) echo \"error: no such option $1. -h for help\";exit 1;; \r\n    *) break;; \r\n    esac \r\n    done \r\n    echo \"opt_f is $opt_f\" \r\n    echo \"opt_l is $opt_l\" \r\n    echo \"first arg is $1\" \r\n    echo \"2nd arg is $2\" \r\n    您可以这样运行该脚本： \r\n    sh test.sh -l hello -f a b \r\n    返回的结果是： \r\n    opt_f is 1 \r\n    opt_l is hello \r\n    first arg is a \r\n    2nd arg is b \r\n    这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数 \r\n    与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例， \r\n    首先输入的应该是包含减号的参数.  \r\n   \r\n   \r\n  六、 Here documents \r\n   \r\n    当要将几行文字传递给一个命令时，here documents（译者注：目前还没有见到过对该词适合的翻译） \r\n    一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果我们使用here documents技术 \r\n     就不必用echo函数一行行输出。 一个 Here document 以 << 开头，后面接上一个字符串(任意的)，假设是“robin” \r\n    在你文本结束后，再用这个字符串(“robin”)追加一行，以表示文本结束。这个字符串我暂称之为边界区分字符串。下面是一个例子， \r\n    #!/bin/sh \r\n    cat << HELP \r\n    ren -- renames a number of files using sed regular expressions \r\n    USAGE: ren \'regexp\' \'replacement\' files...  \r\n    EXAMPLE: rename all *.HTM files in *.html: \r\n    ren \'HTM$\' \'html\' *.HTM \r\n    HELP \r\n    上面我们是选用HELP作为边界区分字符串的。其实我们也可以使用任意的字符串，比如robin，那么上例将变成如下： \r\n    #!/bin/sh \r\n    cat << robin \r\n    ren -- renames a number of files using sed regular expressions \r\n    USAGE: ren \'regexp\' \'replacement\' files...  \r\n    EXAMPLE: rename all *.HTM files in *.html: \r\n    ren \'HTM$\' \'html\' *.HTM \r\n    robin \r\n   \r\n  七、调试 \r\n   \r\n    最简单的调试命令当然是使用echo命令。您可以使用echo在任何怀疑出错的地方打印任何变量值。这也是绝大多数的shell程序员要花费80%的时间来调试程序的原因。Shell程序的好处在于不需要重新编译，插入一个echo命令也不需要多少时间。 \r\n    shell也有一个真实的调试模式。如果在脚本中有错误，您可以这样来进行调试： \r\n    sh -x test.sh \r\n    这将执行该脚本并显示所有变量的值。 \r\n    shell还有一个不需要执行脚本只是检查语法的模式。可以这样使用： \r\n    sh -n test,sh \r\n    这将返回所有语法错误 \r\n    八、 Shell基本命令 \r\n    在shell脚本中可以使用任意的unix/linux命令，但是还是由一些相对更常用的命令。这些命令通常是用来 \r\n    进行文件和文字操作的。 \r\n    关于linux命令的详细内容请参考《Linux命令简介》 \r\n    常用命令语法及功能 \r\n    echo \"some text\": 将文字内容打印在屏幕上 \r\n    ls: 文件列表 \r\n    wc –l filewc或-w filewc或-c file: 计算文件行数；计算文件中的单词数；计算文件中的字符数 \r\n    cp sourcefile destfile: 文件拷贝 \r\n    mv oldname newname : 重命名文件或移动文件 \r\n    rm file: 删除文件 \r\n    grep \'pattern\' file: 在文件内搜索字符串比如：grep \'searchstring\' file.txt \r\n    cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出 \r\n    每行第5个到第9个字符cut -b5-9 file.txt \r\n    cat file.txt: 输出文件内容到标准输出设备（屏幕）上 \r\n    file somefile: 得到文件类型 \r\n    read var: 提示用户输入，并将输入赋值给变量 \r\n    sort file.txt: 对file.txt文件中的行进行排序 \r\n    uniq: 删除文本文件中出现的行列比如： sort file.txt | uniq \r\n    expr: 进行数学运算Example: add 2 and 3expr 2 \"+\" 3 \r\n    find: 搜索文件比如：根据文件名搜索find . -name filename -print \r\n    tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile \r\n    basename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux \r\n    dirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin \r\n    head file: 打印文本文件开头几行 \r\n    tail file : 打印文本文件末尾几行 \r\n    sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将 \r\n    结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。 \r\n    不要和shell中的通配符相混淆。比如：将linuxfocus 替换为 \r\n    LinuxFocus ：cat text.file | sed \'s/linuxfocus/LinuxFocus/\' > newtext.file \r\n    awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。 \r\n    cat file.txt | awk -F, \'{print $1 \",\" $3 }\'这里我们使用，作为字段分割符，同时打印 \r\n    第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA \r\n    命令输出结果为：Adam Bor, IndiaKerry Miller\n',''),(56,'java','java java java性能调优 \r\n\r\n \r\n######################################################### \r\n##  注意：在java程序调试过程中如果想知道工具有那些选项 ## \r\n##   可以使用 -options 显示，例如： jstat -options     ## \r\n#########################################################\r\n\r\n \r\n  jps -- Java Virtual Machine Process Status Tool \r\n  可以列出本机所有java进程的pid \r\n  jps [ options ] [ hostid ] \r\n  -q 仅输出VM标识符，不包括class name,jar name,arguments in main method \r\n  -m 输出main method的参数 \r\n  -l 输出完全的包名，应用主类名，jar的完全路径名 \r\n  -v 输出jvm参数 \r\n  -V 输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件 \r\n  -Joption 传递参数到vm,例如:-J-Xms48m \r\n   \r\n  hostid: \r\n  [protocol:][[\n   \r\n  输出格式: \r\n  lvmid [ [ classname | JARfilename | \"Unknown\"] [ arg* ] [ jvmarg* ] ] \r\n   \r\n  样例: \r\n  jps -v \r\n  jps -lv \r\n   \r\n  ==================================================== \r\n  jstack -- Stack Trace \r\n  此命令打印java线程的堆栈跟踪，可以得知哪些线程被阻塞或正等待，以便于查找原因 \r\n  jstack [ option ] pid \r\n  -m 打印混合模式(java,c/c++ stack trace) \r\n   \r\n  样例： \r\n  jstack pid \r\n   \r\n  ==================================================== \r\n  jmap -- Memory Map \r\n  此命令打印java的共享对象内存map和堆内存的细节 \r\n  jmap [ option ] pid \r\n  -- 打印共享对象mapping \r\n  -dump:[live,]format=b,file= -- dump堆中的对象到文件 \r\n  -finalizerinfo  打印等待回收对象的信息 \r\n  -heap  打印堆总结 \r\n  -histo[:live]  打印堆的对象统计，包括对象数、内存大小等等 \r\n  -permstat  打印java堆perm区的classloader统计 \r\n  -F  强制，在jmap -dump或jmap -histo中使用，如果pid没有相应的回复 \r\n  -J  提供jvm选项，如：-J-Xms256m \r\n   \r\n  样例： \r\n   \r\n  jmap -heap pid \r\n  jmap -dump:live,file=   dump堆中的live对象到文件 \r\n  jmap -dump:file=   dump堆中的所有对象 \r\n  jmap -dump:live,format=b,file=   以二进制格式dump \r\n   \r\n  ======================================== \r\n  jhat -- Java Heap Analysis Tool \r\n  -port  jhat的http server端口号 \r\n  -J  提供jvm选项 \r\n   \r\n  jmap -dump:live,file= -- dump堆中live对象到文件,可以利用jhat去查看dump文件 \r\n  jhat 并且访问网址http://localhost:7000/ \r\n  如果报内存不够，则用jhat -J-Xmx256m 即可 \r\n   \r\n  ======================================== \r\n  jconsole \r\n  使用JTop插件 \r\n  <JDK6>/bin/jconsole -pluginpath <JDK6>/demo/management/JTop/JTop.jar \r\n   \r\n   \r\n   \r\n  jstat \r\n  工具特别强大，有众多的可选项，详细查看堆内各个部分的使用量，以及加载类的数量。使用时，需加上查看进程的进程id，和所选参数。以下详细介绍各个参数的意义。 \r\n  jstat -class pid:显示加载class的数量，及所占空间等信息。 \r\n  jstat -compiler pid:显示VM实时编译的数量等信息。 \r\n  jstat -gc pid:可以显示gc的信息，查看gc的次数，及时间。其中最后五项，分别是young gc的次数，young gc的时间，full gc的次数，full gc的时间，gc的总时间。 \r\n  jstat -gccapacity:可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。其他的可以根据这个类推， OC是old内纯的占用量。 \r\n  jstat -gcnew pid:new对象的信息。 \r\n  jstat -gcnewcapacity pid:new对象的信息及其占用量。 \r\n  jstat -gcold pid:old对象的信息。 \r\n  jstat -gcoldcapacity pid:old对象的信息及其占用量。 \r\n  jstat -gcpermcapacity pid: perm对象的信息及其占用量。 \r\n  jstat -util pid:统计gc信息统计。 \r\n  jstat -printcompilation pid:当前VM执行的信息。 \r\n  除了以上一个参数外，还可以同时加上 两个数字，如：jstat -printcompilation 3024 250 6是每250毫秒打印一次，一共打印6次，还可以加上-h3每三行显示一下标题。 \r\n  jmap是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。使用方法 jmap -histo pid。如果连用SHELL jmap -histo pid>a.log可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出GC回收了哪些对象。jmap -dump:format=b,file=String 3024可以将3024进程的内存heap输出出来到String文件里。 \r\n  jinfo:的用处比较简单，就是能输出并修改运行时的java进程的运行参数。用法是jinfo -opt  pid 如：查看2788的MaxPerm大小可以用  jinfo -flag MaxPermSize 2788。 \r\n  jps:查看当前运行的jvm进程号 \r\n  jstack：打印当前某个jvm的详细的线程堆栈信息 \r\n######################################################### \r\n##  注意：在java程序调试过程中如果想知道工具有那些选项 ## \r\n##   可以使用 -options 显示，例如： jstat -options     ## \r\n#########################################################\r\n\r\n\n','//]hostname][:port][/servername] \r'),(57,'wget','wget wget 使用文档\r\n \r\n  1、使用wget下载单个文件 \r\n   \r\n    下的例子是从网络下载一个文件并保存在当前目录 \r\n   \r\n    get http:\n   \r\n    下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。 \r\n   \r\n  2、使用wget -O下载并以不同的文件名保存 \r\n   \r\n    get默认会以最后一个符合”/”的后面的字符来命令，对于动态链接的下载通常文件名会不正确。 \r\n    误：下面的例子会下载一个文件并以名称download.php?id=1080保存 \r\n   \r\n    get http://www.centos.bz/download?id=1 \r\n    使下载的文件是zip格式，它仍然以download.php?id=1080命令。 \r\n    确：为了解决这个问题，我们可以使用参数-O来指定一个文件名： \r\n   \r\n    get -O wordpress.zip http://www.centos.bz/download.php?id=1080 \r\n   \r\n  3、使用wget –limit -rate限速下载 \r\n    你执行wget的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。 \r\n   \r\n    get –limit-rate=300k http:\n   \r\n  4、使用wget -c断点续传 \r\n    用wget -c重新启动下载中断的文件: \r\n   \r\n    get -c http:\n    于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。 \r\n   \r\n  5、使用wget -b后台下载 \r\n    于下载非常大的文件的时候，我们可以使用参数-b进行后台下载。 \r\n   \r\n    get -b http:\n    ontinuing in background, pid 1840.  \r\n    utput will be written to `wget-log’.  \r\n    可以使用以下命令来察看下载进度 \r\n   \r\n    ail -f wget-log \r\n   \r\n  6、伪装代理名称下载 \r\n    些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过–user-agent参数伪装。 \r\n   \r\n    get –user-agent=”Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16″ 下载链接 \r\n   \r\n  7、使用wget –spider测试下载链接 \r\n    你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。 \r\n   \r\n    get –spider URL \r\n    果下载链接正确，将会显示 \r\n   \r\n    get –spider URL \r\n    pider mode enabled. Check if remote file exists.  \r\n    TTP request sent, awaiting response… 200 OK \r\n    ength: unspecified [text/html] \r\n    emote file exists and could contain further links, \r\n    ut recursion is disabled — not retrieving.  \r\n    保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误 \r\n   \r\n    get –spider url \r\n    pider mode enabled. Check if remote file exists.  \r\n    TTP request sent, awaiting response… 404 Not Found \r\n    emote file does not exist — broken link!!!  \r\n    可以在以下几种情况下使用spider参数： \r\n   \r\n    时下载之前进行检查 \r\n    隔检测网站是否可用 \r\n    查网站页面的死链接 \r\n   \r\n  8、使用wget –tries增加重试次数 \r\n    果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用–tries增加重试次数。 \r\n   \r\n    get –tries=40 URL \r\n   \r\n  9、使用wget -i下载多个文件 \r\n    先，保存一份下载链接文件 \r\n   \r\n    at > filelist.txt \r\n    rl1 \r\n    rl2 \r\n    rl3 \r\n    rl4 \r\n    着使用这个文件和参数-i下载 \r\n   \r\n    get -i filelist.txt \r\n   \r\n  10、使用wget –mirror镜像网站 \r\n    面的例子是下载整个网站到本地。 \r\n   \r\n    get –mirror -p –convert-links -P ./LOCAL URL \r\n    miror:开户镜像下载 \r\n    p:下载所有为了html页面显示正常的文件 \r\n    convert-links:下载后，转换成本地的链接 \r\n    P ./LOCAL：保存所有文件和目录到本地指定目录 \r\n   \r\n  11、使用wget –reject过滤指定格式下载 \r\n    想下载一个网站，但你不希望下载图片，你可以使用以下命令。 \r\n   \r\n    get –reject=gif url \r\n   \r\n  12、使用wget -o把下载信息存入日志文件 \r\n    不希望下载信息直接显示在终端而是在一个日志文件，可以使用以下命令： \r\n   \r\n    get -o download.log URL \r\n   \r\n  13、使用wget -Q限制总下载文件大小 \r\n    你想要下载的文件超过5M而退出下载，你可以使用以下命令: \r\n   \r\n    get -Q5m -i filelist.txt \r\n    意：这个参数对单个文件下载不起作用，只能递归下载时才有效。 \r\n   \r\n  14、使用wget -r -A下载指定格式文件 \r\n    以在以下情况使用该功能 \r\n   \r\n    载一个网站的所有图片 \r\n    载一个网站的所有视频 \r\n    载一个网站的所有PDF文件 \r\n    get -r -A.pdf url \r\n   \r\n  15、使用wget FTP下载 \r\n    可以使用wget来完成ftp链接的下载。 \r\n    用wget匿名ftp下载 \r\n   \r\n    get ftp-url \r\n   \r\n    用wget用户名和密码认证的ftp下载 \r\n   \r\n    get –ftp-user=USERNAME –ftp-password=PASSWORD url \r\n   \r\n    get是在Linux下开发的开放源代码的软件，作者是Hrvoje Niksic，后来被移植到包括Windows在内的各个平台上。它有以下功能和特点： \r\n   \r\n    1）支持断点下传功能；这一点，也是网络蚂蚁和FlashGet当年最大的卖点，现在，Wget也可以使用此功能，那些网络不是太好的用户可以放心了； \r\n    2）同时支持FTP和HTTP下载方式；尽管现在大部分软件可以使用HTTP方式下载，但是，有些时候，仍然需要使用FTP方式下载软件； \r\n    3）支持代理服务器；对安全强度很高的系统而言，一般不会将自己的系统直接暴露在互联网上，所以，支持代理是下载软件必须有的功能； \r\n    4）设置方便简单；可能，习惯图形界面的用户已经不是太习惯命令行了，但是，命令行在设置上其实有更多的优点，最少，鼠标可以少点很多次，也不要担心是否错点鼠标； \r\n    5）程序小，完全免费；程序小可以考虑不计，因为现在的硬盘实在太大了；完全免费就不得不考虑了，即使网络上有很多所谓的免费软件，但是，这些软件的广告却不是我们喜欢的； \r\n   \r\n    get虽然功能强大，但是使用起来还是比较简单的，基本的语法是：wget [参数列表] URL。下面就结合具体的例子来说明一下wget的用法。 \r\n   \r\n  1、下载整个http或者ftp站点。 \r\n    get http://place.your.url/here \r\n    个命令可以将http://place.your.url/here 首页下载下来。使用-x会强制建立服务器上一模一样的目录，如果使用-nd参数，那么服务器上下载的所有内容都会加到本地当前目录。 \r\n   \r\n    get -r http://place.your.url/here \r\n     个命令会按照递归的方法，下载服务器上所有的目录和文件，实质就是下载整个网站。这个命令一定要小心使用，因为在下载的时候，被下载网站指向的所有地址同 样会被下载，因此，如果这个网站引用了其他网站，那么被引用的网站也会被下载下来！基于这个原因，这个参数不常用。可以用-l number参数来指定下载的层次。例如只下载两层，那么使用-l 2。 \r\n   \r\n    是您想制作镜像站点，那么可以使用－m参数，例如：wget -m http://place.your.url/here \r\n    时wget会自动判断合适的参数来制作镜像站点。此时，wget会登录到服务器上，读入robots.txt并按robots.txt的规定来执行。 \r\n   \r\n  2、断点续传。 \r\n    文件特别大或者网络特别慢的时候，往往一个文件还没有下载完，连接就已经被切断，此时就需要断点续传。wget的断点续传是自动的，只需要使用-c参数，例如： \r\n    get -c http://the.url.of/incomplete/file \r\n    用断点续传要求服务器支持断点续传。-t参数表示重试次数，例如需要重试100次，那么就写-t 100，如果设成-t 0，那么表示无穷次重试，直到连接成功。-T参数表示超时等待时间，例如-T 120，表示等待120秒连接不上就算超时。 \r\n   \r\n  3、批量下载。 \r\n    果有多个文件需要下载，那么可以生成一个文件，把每个文件的URL写一行，例如生成文件download.txt，然后用命令：wget -i download.txt \r\n    样就会把download.txt里面列出的每个URL都下载下来。（如果列的是文件就下载文件，如果列的是网站，那么下载首页） \r\n   \r\n  4、选择性的下载。 \r\n    以指定让wget只下载一类文件，或者不下载什么文件。例如： \r\n    get -m –reject=gif http://target.web.site/subdirectory \r\n    示下载http://target.web.site/subdirectory，但是忽略gif文件。–accept=LIST 可以接受的文件类型，–reject=LIST拒绝接受的文件类型。 \r\n   \r\n  5、密码和认证。 \r\n    get只能处理利用用户名/密码方式限制访问的网站，可以利用两个参数： \r\n    http-user=USER设置HTTP用户 \r\n    http-passwd=PASS设置HTTP密码 \r\n    于需要证书做认证的网站，就只能利用其他下载工具了，例如curl。 \r\n   \r\n  6、利用代理服务器进行下载。 \r\n    果用户的网络需要经过代理服务器，那么可以让wget通过代理服务器进行文件的下载。此时需要在当前用户的目录下创建一个.wgetrc文件。文件中可以设置代理服务器： \r\n    ttp-proxy = 111.111.111.111:8080 \r\n    tp-proxy = 111.111.111.111:8080 \r\n    别表示http的代理服务器和ftp的代理服务器。如果代理服务器需要密码则使用： \r\n    proxy-user=USER设置代理用户 \r\n    proxy-passwd=PASS设置代理密码 \r\n    两个参数。 \r\n    用参数–proxy=on/off 使用或者关闭代理。 \r\n    get还有很多有用的功能，需要用户去挖掘。 \r\n   \r\n    录： \r\n   \r\n    令格式： \r\n    get [参数列表] [目标软件、网页的网址] \r\n   \r\n    V,–version 显示软件版本号然后退出； \r\n    h,–help显示软件帮助信息； \r\n    e,–execute=COMMAND 执行一个 “.wgetrc”命令 \r\n   \r\n    o,–output-file=FILE 将软件输出信息保存到文件； \r\n    a,–append-output=FILE将软件输出信息追加到文件； \r\n    d,–debug显示输出信息； \r\n    q,–quiet 不显示输出信息； \r\n    i,–input-file=FILE 从文件中取得URL； \r\n   \r\n    t,–tries=NUMBER 是否下载次数（0表示无穷次） \r\n    O –output-document=FILE下载文件保存为别的文件名 \r\n    nc, –no-clobber 不要覆盖已经存在的文件 \r\n    N,–timestamping只下载比本地新的文件 \r\n    T,–timeout=SECONDS 设置超时时间 \r\n    Y,–proxy=on/off 关闭代理 \r\n   \r\n    nd,–no-directories 不建立目录 \r\n    x,–force-directories 强制建立目录 \r\n   \r\n    http-user=USER设置HTTP用户 \r\n    http-passwd=PASS设置HTTP密码 \r\n    proxy-user=USER设置代理用户 \r\n    proxy-passwd=PASS设置代理密码 \r\n   \r\n    r,–recursive 下载整个网站、目录（小心使用） \r\n    l,–level=NUMBER 下载层次 \r\n   \r\n    A,–accept=LIST 可以接受的文件类型 \r\n    R,–reject=LIST拒绝接受的文件类型 \r\n    D,–domains=LIST可以接受的域名 \r\n    exclude-domains=LIST拒绝的域名 \r\n    L,–relative 下载关联链接 \r\n    follow-ftp 只下载FTP链接 \r\n    H,–span-hosts 可以下载外面的主机 \r\n    I,–include-directories=LIST允许的目录 \r\n    X,–exclude-directories=LIST 拒绝的目录 \r\n   \r\n    文文档名在平常的情况下会被编码， 但是在 –cut-dirs 时又是正常的， \r\n    get -r -np -nH –cut-dirs=3 ftp://host/test/ \r\n    试.txt \r\n    get -r -np -nH -nd ftp://host/test/ \r\n    B4%FA%B8%D5.txt \r\n    get “ftp://host/test/*” \r\n    B4%FA%B8%D5.txt \r\n   \r\n     於不知名的原因，可能是为了避开特殊档名， wget 会自动将抓取档名的部分用 encode_string 处理过， 所以该 patch 就把被 encode_string 处理成 “%3A” 这种东西， 用 decode_string 还原成 “:”，并套用在目录与档案名称的部分，decode_string 是 wget 内建的函式。 \r\n   \r\n    get -t0 -c -nH -x -np -b -m -P /home/sunny/NOD32view/ http://downloads1.kaspersky-labs.com/bases/ -o wget.log\n','//cn.wordpress.org/wordpress-3.1-zh_CN.zip \r'),(58,'curl','curl curl 使用文档 \r\n   对于windows用户如果用Cygwin模拟unix环境的话，里面没有带curl命令，要自己装，所以建议用Gow来模拟，它已经自带了curl工具，安装后直接在cmd环境中用curl命令就可，因为路径已经自动给你配置好了。 \r\n      linux curl是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称url为下载工具。 \r\n  一，curl命令参数，有好多我没有用过，也不知道翻译的对不对，如果有误的地方，还请指正。 \r\n  　　-a/--append 上传文件时，附加到目标文件 \r\n  　　-A/--user-agent <string>  设置用户代理发送给服务器 \r\n  　　- anyauth   可以使用“任何”身份验证方法 \r\n  　　-b/--cookie <name=string/file> cookie字符串或文件读取位置 \r\n  　　- basic 使用HTTP基本验证 \r\n  　　-B/--use-ascii 使用ASCII /文本传输 \r\n  　　-c/--cookie-jar <file> 操作结束后把cookie写入到这个文件中 \r\n  　　-C/--continue-at <offset>  断点续转 \r\n  　　-d/--data <data>   HTTP POST方式传送数据 \r\n  　　--data-ascii <data>  以ascii的方式post数据 \r\n  　　--data-binary <data> 以二进制的方式post数据 \r\n  　　--negotiate     使用HTTP身份验证 \r\n  　　--digest        使用数字身份验证 \r\n  　　--disable-eprt  禁止使用EPRT或LPRT \r\n  　　--disable-epsv  禁止使用EPSV \r\n  　　-D/--dump-header <file> 把header信息写入到该文件中 \r\n  　　--egd-file <file> 为随机数据(SSL)设置EGD socket路径 \r\n  　　--tcp-nodelay   使用TCP_NODELAY选项 \r\n  　　-e/--referer 来源网址 \r\n  　　-E/--cert <cert[:passwd]> 客户端证书文件和密码 (SSL) \r\n  　　--cert-type <type> 证书文件类型 (DER/PEM/ENG) (SSL) \r\n  　　--key <key>     私钥文件名 (SSL) \r\n  　　--key-type <type> 私钥文件类型 (DER/PEM/ENG) (SSL) \r\n  　　--pass  <pass>  私钥密码 (SSL) \r\n  　　--engine <eng>  加密引擎使用 (SSL). \"--engine list\" for list \r\n  　　--cacert <file> CA证书 (SSL) \r\n  　　--capath <directory> CA目录 (made using c_rehash) to verify peer against (SSL) \r\n  　　--ciphers <list>  SSL密码 \r\n  　　--compressed    要求返回是压缩的形势 (using deflate or gzip) \r\n  　　--connect-timeout <seconds> 设置最大请求时间 \r\n  　　--create-dirs   建立本地目录的目录层次结构 \r\n  　　--crlf          上传是把LF转变成CRLF \r\n  　　-f/--fail          连接失败时不显示http错误 \r\n  　　--ftp-create-dirs 如果远程目录不存在，创建远程目录 \r\n  　　--ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用 \r\n  　　--ftp-pasv      使用 PASV/EPSV 代替端口 \r\n  　　--ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址 \r\n  　　--ftp-ssl       尝试用 SSL/TLS 来进行ftp数据传输 \r\n  　　--ftp-ssl-reqd  要求用 SSL/TLS 来进行ftp数据传输 \r\n  　　-F/--form <name=content> 模拟http表单提交数据 \r\n  　　-form-string <name=string> 模拟http表单提交数据 \r\n  　　-g/--globoff 禁用网址序列和范围使用{}和[] \r\n  　　-G/--get 以get的方式来发送数据 \r\n  　　-h/--help 帮助 \r\n  　　-H/--header <line>自定义头信息传递给服务器 \r\n  　　--ignore-content-length  忽略的HTTP头信息的长度 \r\n  　　-i/--include 输出时包括protocol头信息 \r\n  　　-I/--head  只显示文档信息 \r\n  　　从文件中读取-j/--junk-session-cookies忽略会话Cookie \r\n  　　- 界面<interface>指定网络接口/地址使用 \r\n  　　- krb4 <级别>启用与指定的安全级别krb4 \r\n  　　-j/--junk-session-cookies 读取文件进忽略session cookie \r\n  　　--interface <interface> 使用指定网络接口/地址 \r\n  　　--krb4 <level>  使用指定安全级别的krb4 \r\n  　　-k/--insecure 允许不使用证书到SSL站点 \r\n  　　-K/--config  指定的配置文件读取 \r\n  　　-l/--list-only 列出ftp目录下的文件名称 \r\n  　　--limit-rate <rate> 设置传输速度 \r\n  　　--local-port<NUM> 强制使用本地端口号 \r\n  　　-m/--max-time <seconds> 设置最大传输时间 \r\n  　　--max-redirs <num> 设置最大读取的目录数 \r\n  　　--max-filesize <bytes> 设置最大下载的文件总量 \r\n  　　-M/--manual  显示全手动 \r\n  　　-n/--netrc 从netrc文件中读取用户名和密码 \r\n  　　--netrc-optional 使用 .netrc 或者 URL来覆盖-n \r\n  　　--ntlm          使用 HTTP NTLM 身份验证 \r\n  　　-N/--no-buffer 禁用缓冲输出 \r\n  　　-o/--output 把输出写到该文件中 \r\n  　　-O/--remote-name 把输出写到该文件中，保留远程文件的文件名 \r\n  　　-p/--proxytunnel   使用HTTP代理 \r\n  　　--proxy-anyauth 选择任一代理身份验证方法 \r\n  　　--proxy-basic   在代理上使用基本身份验证 \r\n  　　--proxy-digest  在代理上使用数字身份验证 \r\n  　　--proxy-ntlm    在代理上使用ntlm身份验证 \r\n  　　-P/--ftp-port <address> 使用端口地址，而不是使用PASV \r\n  　　-Q/--quote <cmd>文件传输前，发送命令到服务器 \r\n  　　-r/--range <range>检索来自HTTP/1.1或FTP服务器字节范围 \r\n  　　--range-file 读取（SSL）的随机文件 \r\n  　　-R/--remote-time   在本地生成文件时，保留远程文件时间 \r\n  　　--retry <num>   传输出现问题时，重试的次数 \r\n  　　--retry-delay <seconds>  传输出现问题时，设置重试间隔时间 \r\n  　　--retry-max-time <seconds> 传输出现问题时，设置最大重试时间 \r\n  　　-s/--silent静音模式。不输出任何东西 \r\n  　　-S/--show-error   显示错误 \r\n  　　--socks4 <host[:port]> 用socks4代理给定主机和端口 \r\n  　　--socks5 <host[:port]> 用socks5代理给定主机和端口 \r\n  　　--stderr <file> \r\n      -t/--telnet-option <OPT=val> Telnet选项设置 \r\n  　　--trace <file>  对指定文件进行debug \r\n  　　--trace-ascii <file> Like --跟踪但没有hex输出 \r\n  　　--trace-time    跟踪/详细输出时，添加时间戳 \r\n  　　-T/--upload-file <file> 上传文件 \r\n  　　--url <URL>     Spet URL to work with \r\n  　　-u/--user <user[:password]>设置服务器的用户和密码 \r\n  　　-U/--proxy-user <user[:password]>设置代理用户名和密码 \r\n  　　-v/--verbose \r\n  　　-V/--version 显示版本信息 \r\n  　　-w/--write-out [format]什么输出完成后 \r\n  　　-x/--proxy <host[:port]>在给定的端口上使用HTTP代理 \r\n  　　-X/--request <command>指定什么命令 \r\n  　　-y/--speed-time 放弃限速所要的时间。默认为30 \r\n  　　-Y/--speed-limit 停止传输速度的限制，速度时间\'秒 \r\n  　　-z/--time-cond  传送时间设置 \r\n  　　-0/--http1.0  使用HTTP 1.0 \r\n  　　-1/--tlsv1  使用TLSv1（SSL） \r\n  　　-2/--sslv2 使用SSLv2的（SSL） \r\n  　　-3/--sslv3         使用的SSLv3（SSL） \r\n  　　--3p-quote      like -Q for the source URL for 3rd party transfer \r\n  　　--3p-url        使用url，进行第三方传送 \r\n  　　--3p-user       使用用户名和密码，进行第三方传送 \r\n  　　-4/--ipv4   使用IP4 \r\n  　　-6/--ipv6   使用IP6 \r\n  　　-#/--progress-bar 用进度条显示当前的传送状态 \r\n  　　-a/--append 上传文件时，附加到目标文件 \r\n  　　-A/--user-agent <string>  设置用户代理发送给服务器 \r\n  　　- anyauth   可以使用“任何”身份验证方法 \r\n  　　-b/--cookie <name=string/file> cookie字符串或文件读取位置 \r\n  　　- basic 使用HTTP基本验证 \r\n  　　-B/--use-ascii 使用ASCII /文本传输 \r\n  　　-c/--cookie-jar <file> 操作结束后把cookie写入到这个文件中 \r\n  　　-C/--continue-at <offset>  断点续转 \r\n  　　-d/--data <data>   HTTP POST方式传送数据 \r\n  　　--data-ascii <data>  以ascii的方式post数据 \r\n  　　--data-binary <data> 以二进制的方式post数据 \r\n  　　--negotiate     使用HTTP身份验证 \r\n  　　--digest        使用数字身份验证 \r\n  　　--disable-eprt  禁止使用EPRT或LPRT \r\n  　　--disable-epsv  禁止使用EPSV \r\n  　　-D/--dump-header <file> 把header信息写入到该文件中 \r\n  　　--egd-file <file> 为随机数据(SSL)设置EGD socket路径 \r\n  　　--tcp-nodelay   使用TCP_NODELAY选项 \r\n  　　-e/--referer 来源网址 \r\n  　　-E/--cert <cert[:passwd]> 客户端证书文件和密码 (SSL) \r\n  　　--cert-type <type> 证书文件类型 (DER/PEM/ENG) (SSL) \r\n  　　--key <key>     私钥文件名 (SSL) \r\n  　　--key-type <type> 私钥文件类型 (DER/PEM/ENG) (SSL) \r\n  　　--pass  <pass>  私钥密码 (SSL) \r\n  　　--engine <eng>  加密引擎使用 (SSL). \"--engine list\" for list \r\n  　　--cacert <file> CA证书 (SSL) \r\n  　　--capath <directory> CA目录 (made using c_rehash) to verify peer against (SSL) \r\n  　　--ciphers <list>  SSL密码 \r\n  　　--compressed    要求返回是压缩的形势 (using deflate or gzip) \r\n  　　--connect-timeout <seconds> 设置最大请求时间 \r\n  　　--create-dirs   建立本地目录的目录层次结构 \r\n  　　--crlf          上传是把LF转变成CRLF \r\n  　　-f/--fail          连接失败时不显示http错误 \r\n  　　--ftp-create-dirs 如果远程目录不存在，创建远程目录 \r\n  　　--ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用 \r\n  　　--ftp-pasv      使用 PASV/EPSV 代替端口 \r\n  　　--ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址 \r\n  　　--ftp-ssl       尝试用 SSL/TLS 来进行ftp数据传输 \r\n  　　--ftp-ssl-reqd  要求用 SSL/TLS 来进行ftp数据传输 \r\n  　　-F/--form <name=content> 模拟http表单提交数据 \r\n  　　-form-string <name=string> 模拟http表单提交数据 \r\n  　　-g/--globoff 禁用网址序列和范围使用{}和[] \r\n  　　-G/--get 以get的方式来发送数据 \r\n  　　-h/--help 帮助 \r\n  　　-H/--header <line>自定义头信息传递给服务器 \r\n  　　--ignore-content-length  忽略的HTTP头信息的长度 \r\n  　　-i/--include 输出时包括protocol头信息 \r\n  　　-I/--head  只显示文档信息 \r\n  　　从文件中读取-j/--junk-session-cookies忽略会话Cookie \r\n  　　- 界面<interface>指定网络接口/地址使用 \r\n  　　- krb4 <级别>启用与指定的安全级别krb4 \r\n  　　-j/--junk-session-cookies 读取文件进忽略session cookie \r\n  　　--interface <interface> 使用指定网络接口/地址 \r\n  　　--krb4 <level>  使用指定安全级别的krb4 \r\n  　　-k/--insecure 允许不使用证书到SSL站点 \r\n  　　-K/--config  指定的配置文件读取 \r\n  　　-l/--list-only 列出ftp目录下的文件名称 \r\n  　　--limit-rate <rate> 设置传输速度 \r\n  　　--local-port<NUM> 强制使用本地端口号 \r\n  　　-m/--max-time <seconds> 设置最大传输时间 \r\n  　　--max-redirs <num> 设置最大读取的目录数 \r\n  　　--max-filesize <bytes> 设置最大下载的文件总量 \r\n      -M/--manual  显示全手动 \r\n  　　-n/--netrc 从netrc文件中读取用户名和密码 \r\n  　　--netrc-optional 使用 .netrc 或者 URL来覆盖-n \r\n  　　--ntlm          使用 HTTP NTLM 身份验证 \r\n  　　-N/--no-buffer 禁用缓冲输出 \r\n  　　-o/--output 把输出写到该文件中 \r\n  　　-O/--remote-name 把输出写到该文件中，保留远程文件的文件名 \r\n  　　-p/--proxytunnel   使用HTTP代理 \r\n  　　--proxy-anyauth 选择任一代理身份验证方法 \r\n  　　--proxy-basic   在代理上使用基本身份验证 \r\n  　　--proxy-digest  在代理上使用数字身份验证 \r\n  　　--proxy-ntlm    在代理上使用ntlm身份验证 \r\n  　　-P/--ftp-port <address> 使用端口地址，而不是使用PASV \r\n  　　-Q/--quote <cmd>文件传输前，发送命令到服务器 \r\n  　　-r/--range <range>检索来自HTTP/1.1或FTP服务器字节范围 \r\n  　　--range-file 读取（SSL）的随机文件 \r\n  　　-R/--remote-time   在本地生成文件时，保留远程文件时间 \r\n  　　--retry <num>   传输出现问题时，重试的次数 \r\n  　　--retry-delay <seconds>  传输出现问题时，设置重试间隔时间 \r\n  　　--retry-max-time <seconds> 传输出现问题时，设置最大重试时间 \r\n  　　-s/--silent静音模式。不输出任何东西 \r\n  　　-S/--show-error   显示错误 \r\n  　　--socks4 <host[:port]> 用socks4代理给定主机和端口 \r\n  　　--socks5 <host[:port]> 用socks5代理给定主机和端口 \r\n  　　--stderr <file> \r\n  　　-t/--telnet-option <OPT=val> Telnet选项设置 \r\n  　　--trace <file>  对指定文件进行debug \r\n  　　--trace-ascii <file> Like --跟踪但没有hex输出 \r\n  　　--trace-time    跟踪/详细输出时，添加时间戳 \r\n  　　-T/--upload-file <file> 上传文件 \r\n  　　--url <URL>     Spet URL to work with \r\n  　　-u/--user <user[:password]>设置服务器的用户和密码 \r\n  　　-U/--proxy-user <user[:password]>设置代理用户名和密码 \r\n  　　-v/--verbose \r\n  　　-V/--version 显示版本信息 \r\n  　　-w/--write-out [format]什么输出完成后 \r\n  　　-x/--proxy <host[:port]>在给定的端口上使用HTTP代理 \r\n  　　-X/--request <command>指定什么命令 \r\n  　　-y/--speed-time 放弃限速所要的时间。默认为30 \r\n  　　-Y/--speed-limit 停止传输速度的限制，速度时间\'秒 \r\n  　　-z/--time-cond  传送时间设置 \r\n  　　-0/--http1.0  使用HTTP 1.0 \r\n  　　-1/--tlsv1  使用TLSv1（SSL） \r\n  　　-2/--sslv2 使用SSLv2的（SSL） \r\n  　　-3/--sslv3         使用的SSLv3（SSL） \r\n  　　--3p-quote      like -Q for the source URL for 3rd party transfer \r\n  　　--3p-url        使用url，进行第三方传送 \r\n  　　--3p-user       使用用户名和密码，进行第三方传送 \r\n  　　-4/--ipv4   使用IP4 \r\n  　　-6/--ipv6   使用IP6 \r\n  　　-#/--progress-bar 用进度条显示当前的传送状态 \r\n  二，常用curl实例 \r\n  　　 \r\n      1，抓取页面内容到一个文件中 \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -o home.html  http:\n  　　[root@krlcgcms01 mytest]# curl -o home.html  http:\n  　　 \r\n      2，用-O（大写的），后面的url要具体到某个文件，不然抓不下来。我们还可以用正则来抓取东西 \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -O \r\n  　　[root@krlcgcms01 mytest]# curl -O \r\n  　　 \r\n      3，模拟表单信息，模拟登录，保存cookie信息 \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -c ./cookie_c.txt -F log=aaaa -F pwd=****** http://blog.51yip.com/wp-login.php \r\n  　　[root@krlcgcms01 mytest]# curl -c ./cookie_c.txt -F log=aaaa -F pwd=****** http://blog.51yip.com/wp-login.php \r\n  　　 \r\n      4，模拟表单信息，模拟登录，保存头信息 \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -D ./cookie_D.txt -F log=aaaa -F pwd=****** http://blog.51yip.com/wp-login.php \r\n  　　[root@krlcgcms01 mytest]# curl -D ./cookie_D.txt -F log=aaaa -F pwd=****** http://blog.51yip.com/wp-login.php \r\n  　　-c(小写)产生的cookie和-D里面的cookie是不一样的。 \r\n  　　 \r\n      5，使用cookie文件 \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -b ./cookie_c.txt  http://blog.51yip.com/wp-admin \r\n  　　[root@krlcgcms01 mytest]# curl -b ./cookie_c.txt  http://blog.51yip.com/wp-admin \r\n  　　 \r\n      6，断点续传，-C(大写的) \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -C -O \r\n  　　 \r\n      7，传送数据,最好用登录页面测试，因为你传值过去后，curl回抓数据，你可以看到你传值有没有成功 \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -d log=aaaa  http://blog.51yip.com/wp-login.php \r\n  　　[root@krlcgcms01 mytest]# curl -d log=aaaa  http://blog.51yip.com/wp-login.php \r\n  　　 \r\n      8，显示抓取错误，下面这个例子，很清楚的表明了。 \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -f http://blog.51yip.com/asdf \r\n  　　curl: (22) The requested URL returned error: 404 \r\n  　　[root@krlcgcms01 mytest]# curl http://blog.51yip.com/asdf \r\n  　　<HTML><HEAD><TITLE>404,not found</TITLE> \r\n  　　。。。。。。。。。。。。 \r\n  　　[root@krlcgcms01 mytest]# curl -f http://blog.51yip.com/asdf \r\n  　　curl: (22) The requested URL returned error: 404 \r\n  　　[root@krlcgcms01 mytest]# curl http://blog.51yip.com/asdf \r\n  　　<HTML><HEAD><TITLE>404,not found</TITLE> \r\n  　　。。。。。。。。。。。。 \r\n  　　 \r\n      9，伪造来源地址，有的网站会判断，请求来源地址。 \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -e http://localhost http://blog.51yip.com/wp-login.php \r\n  　　[root@krlcgcms01 mytest]# curl -e http://localhost http://blog.51yip.com/wp-login.php \r\n  　　10，当我们经常用curl去搞人家东西的时候，人家会把你的IP给屏蔽掉的,这个时候,我们可以用代理 \r\n  　　[root@krlcgcms01 mytest]# curl -x 24.10.28.84:32779 -o home.html http:\n  　　[root@krlcgcms01 mytest]# curl -x 24.10.28.84:32779 -o home.html http:\n      \r\n      11，比较大的东西，我们可以分段下载 \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -r 0-100 -o img.part1 http://blog.51yip.com/wp- \r\n  　　content/uploads/2010/09/compare_varnish.jpg \r\n  　　% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current \r\n  　　Dload  Upload   Total   Spent    Left  Speed \r\n  　　100   101  100   101    0     0    105      0 --:--:-- --:--:-- --:--:--     0 \r\n  　　[root@krlcgcms01 mytest]# curl -r 100-200 -o img.part2 http://blog.51yip.com/wp- \r\n  　　content/uploads/2010/09/compare_varnish.jpg \r\n  　　% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current \r\n  　　Dload  Upload   Total   Spent    Left  Speed \r\n  　　100   101  100   101    0     0     57      0  0:00:01  0:00:01 --:--:--     0 \r\n  　　[root@krlcgcms01 mytest]# curl -r 200- -o img.part3 http://blog.51yip.com/wp- \r\n  　　content/uploads/2010/09/compare_varnish.jpg \r\n  　　% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current \r\n  　　Dload  Upload   Total   Spent    Left  Speed \r\n  　　100  104k  100  104k    0     0  52793      0  0:00:02  0:00:02 --:--:-- 88961 \r\n  　　[root@krlcgcms01 mytest]# ls |grep part | xargs du -sh \r\n  　　4.0K    one.part1 \r\n  　　112K    three.part3 \r\n  　　4.0K    two.part2 \r\n  　　[root@krlcgcms01 mytest]# curl -r 0-100 -o img.part1 http://blog.51yip.com/wp- \r\n  　　content/uploads/2010/09/compare_varnish.jpg \r\n  　　% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current \r\n  　　Dload  Upload   Total   Spent    Left  Speed \r\n  　　100   101  100   101    0     0    105      0 --:--:-- --:--:-- --:--:--     0 \r\n  　　[root@krlcgcms01 mytest]# curl -r 100-200 -o img.part2 http://blog.51yip.com/wp- \r\n  　　content/uploads/2010/09/compare_varnish.jpg \r\n  　　% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current \r\n  　　Dload  Upload   Total   Spent    Left  Speed \r\n  　　100   101  100   101    0     0     57      0  0:00:01  0:00:01 --:--:--     0 \r\n  　　[root@krlcgcms01 mytest]# curl -r 200- -o img.part3 http://blog.51yip.com/wp- \r\n  　　content/uploads/2010/09/compare_varnish.jpg \r\n  　　% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current \r\n  　　Dload  Upload   Total   Spent    Left  Speed \r\n  　　100  104k  100  104k    0     0  52793      0  0:00:02  0:00:02 --:--:-- 88961 \r\n  　　[root@krlcgcms01 mytest]# ls |grep part | xargs du -sh \r\n  　　4.0K    one.part1 \r\n  　　112K    three.part3 \r\n  　　4.0K    two.part2 \r\n  　　用的时候，把他们cat一下就OK了,cat img.part* >img.jpg \r\n  　　 \r\n      12，不会显示下载进度信息 \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -s -o aaa.jpg \r\n  　　 \r\n      13，显示下载进度条 \r\n   \r\n  　　[root@krlcgcms01 mytest]# curl -# -O \r\n  　　######################################################################## 100.0% \r\n  　　14,通过ftp下载文件 \r\n  　　[zhangy@BlackGhost ~]$ curl -u 用户名:密码 -O http://blog.51yip.com/demo/curtain/bbstudy_files/style.css \r\n  　　% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current \r\n  　　Dload  Upload   Total   Spent    Left  Speed \r\n  　　101  1934  101  1934    0     0   3184      0 --:--:-- --:--:-- --:--:--  7136 \r\n  　　[zhangy@BlackGhost ~]$ curl -u 用户名:密码 -O http://blog.51yip.com/demo/curtain/bbstudy_files/style.css \r\n  　　% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current \r\n  　　Dload  Upload   Total   Spent    Left  Speed \r\n  　　101  1934  101  1934    0     0   3184      0 --:--:-- --:--:-- --:--:--  7136 \r\n  　　或者用下面的方式 \r\n  　　[zhangy@BlackGhost ~]$ curl -O ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/style.css \r\n  　　[zhangy@BlackGhost ~]$ curl -O ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/style.css \r\n  　　 \r\n      15，通过ftp上传 \r\n   \r\n  　　[zhangy@BlackGhost ~]$ curl -T test.sql ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/ \r\n  　　[zhangy@BlackGhost ~]$ curl -T test.sql ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/\n','//blog.51yip.com \r'),(59,'netstat','netstat netstat 使用说明书\r\n \r\n  简介 \r\n   \r\n  Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。 \r\n  输出信息含义 \r\n   \r\n  执行netstat后，其输出结果为 \r\n   \r\n   \r\n  Active Internet connections (w/o servers) \r\n  Proto Recv-Q Send-Q Local Address Foreign Address State \r\n  tcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 ESTABLISHED \r\n  tcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn ESTABLISHED \r\n  tcp 0 0 localhost.localdom:9001 localhost.localdom:1162 ESTABLISHED \r\n  tcp 0 0 localhost.localdom:1162 localhost.localdom:9001 ESTABLISHED \r\n  tcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn CLOSE \r\n   \r\n  Active UNIX domain sockets (w/o servers) \r\n  Proto RefCnt Flags Type State I-Node Path \r\n  unix 1 [ ] STREAM CONNECTED 16178 @000000dd \r\n  unix 1 [ ] STREAM CONNECTED 16176 @000000dc \r\n  unix 9 [ ] DGRAM 5292 /dev/log \r\n  unix 1 [ ] STREAM CONNECTED 16182 @000000df \r\n   \r\n   \r\n   \r\n   \r\n  从整体上看，netstat的输出结果可以分为两个部分： \r\n   \r\n  一个是Active Internet connections，称为有源TCP连接，其中\"Recv-Q\"和\"Send-Q\"指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。 \r\n   \r\n  另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。 \r\n  Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。 \r\n  常见参数 \r\n   \r\n  -a (all)显示所有选项，默认不显示LISTEN相关 \r\n  -t (tcp)仅显示tcp相关选项 \r\n  -u (udp)仅显示udp相关选项 \r\n  -n 拒绝显示别名，能显示数字的全部转化成数字。 \r\n  -l 仅列出有在 Listen (监听) 的服務状态 \r\n   \r\n  -p 显示建立相关链接的程序名 \r\n  -r 显示路由信息，路由表 \r\n  -e 显示扩展信息，例如uid等 \r\n  -s 按各个协议进行统计 \r\n  -c 每隔一个固定时间，执行该netstat命令。 \r\n   \r\n  提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到 \r\n   \r\n   \r\n  实用命令实例 \r\n   \r\n  1. 列出所有端口 (包括监听和未监听的) \r\n   \r\n    列出所有端口 netstat -a \r\n   \r\n   \r\n  # netstat -a | more \r\n   Active Internet connections (servers and established) \r\n   Proto Recv-Q Send-Q Local Address           Foreign Address         State \r\n   tcp        0      0 localhost:30037         *:*                     LISTEN \r\n   udp        0      0 *:bootpc                *:* \r\n   \r\n  Active UNIX domain sockets (servers and established) \r\n   Proto RefCnt Flags       Type       State         I-Node   Path \r\n   unix  2      [ ACC ]     STREAM     LISTENING     6135     /tmp/.X11-unix/X0 \r\n   unix  2      [ ACC ]     STREAM     LISTENING     5140     /var/run/acpid.socket \r\n   \r\n   \r\n   \r\n    列出所有 tcp 端口 netstat -at \r\n   \r\n   \r\n  # netstat -at \r\n   Active Internet connections (servers and established) \r\n   Proto Recv-Q Send-Q Local Address           Foreign Address         State \r\n   tcp        0      0 localhost:30037         *:*                     LISTEN \r\n   tcp        0      0 localhost:ipp           *:*                     LISTEN \r\n   tcp        0      0 *:smtp                  *:*                     LISTEN \r\n   tcp6       0      0 localhost:ipp           [::]:*                  LISTEN \r\n   \r\n   \r\n   \r\n    列出所有 udp 端口 netstat -au \r\n   \r\n  # netstat -au \r\n   Active Internet connections (servers and established) \r\n   Proto Recv-Q Send-Q Local Address           Foreign Address         State \r\n   udp        0      0 *:bootpc                *:* \r\n   udp        0      0 *:49119                 *:* \r\n   udp        0      0 *:mdns                  *:* \r\n   \r\n   \r\n  2. 列出所有处于监听状态的 Sockets \r\n   \r\n    只显示监听端口 netstat -l \r\n   \r\n  # netstat -l \r\n   Active Internet connections (only servers) \r\n   Proto Recv-Q Send-Q Local Address           Foreign Address         State \r\n   tcp        0      0 localhost:ipp           *:*                     LISTEN \r\n   tcp6       0      0 localhost:ipp           [::]:*                  LISTEN \r\n   udp        0      0 *:49119                 *:* \r\n   \r\n    只列出所有监听 tcp 端口 netstat -lt \r\n   \r\n  # netstat -lt \r\n   Active Internet connections (only servers) \r\n   Proto Recv-Q Send-Q Local Address           Foreign Address         State \r\n   tcp        0      0 localhost:30037         *:*                     LISTEN \r\n   tcp        0      0 *:smtp                  *:*                     LISTEN \r\n   tcp6       0      0 localhost:ipp           [::]:*                  LISTEN \r\n   \r\n    只列出所有监听 udp 端口 netstat -lu \r\n   \r\n  # netstat -lu \r\n   Active Internet connections (only servers) \r\n   Proto Recv-Q Send-Q Local Address           Foreign Address         State \r\n   udp        0      0 *:49119                 *:* \r\n   udp        0      0 *:mdns                  *:* \r\n   \r\n    只列出所有监听 UNIX 端口 netstat -lx \r\n   \r\n   \r\n  # netstat -lx \r\n   Active UNIX domain sockets (only servers) \r\n   Proto RefCnt Flags       Type       State         I-Node   Path \r\n   unix  2      [ ACC ]     STREAM     LISTENING     6294     private/maildrop \r\n   unix  2      [ ACC ]     STREAM     LISTENING     6203     public/cleanup \r\n   unix  2      [ ACC ]     STREAM     LISTENING     6302     private/ifmail \r\n   unix  2      [ ACC ]     STREAM     LISTENING     6306     private/bsmtp \r\n   \r\n   \r\n   \r\n   \r\n   \r\n  3. 显示每个协议的统计信息 \r\n   \r\n    显示所有端口的统计信息 netstat -s \r\n   \r\n   \r\n  # netstat -s \r\n   Ip: \r\n   11150 total packets received \r\n   1 with invalid addresses \r\n   0 forwarded \r\n   0 incoming packets discarded \r\n   11149 incoming packets delivered \r\n   11635 requests sent out \r\n   Icmp: \r\n   0 ICMP messages received \r\n   0 input ICMP message failed.  \r\n   Tcp: \r\n   582 active connections openings \r\n   2 failed connection attempts \r\n   25 connection resets received \r\n   Udp: \r\n   1183 packets received \r\n   4 packets to unknown port received.  \r\n   .....  \r\n   \r\n   \r\n   \r\n    显示 TCP 或 UDP 端口的统计信息 netstat -st 或 -su \r\n   \r\n  # netstat -st \r\n  # netstat -su \r\n   \r\n   \r\n  4. 在 netstat 输出中显示 PID 和进程名称 netstat -p \r\n   \r\n  netstat -p 可以与其它开关一起使用，就可以添加 “PID/进程名称” 到 netstat 输出中，这样 debugging 的时候可以很方便的发现特定端口运行的程序。 \r\n   \r\n  # netstat -pt \r\n   Active Internet connections (w/o servers) \r\n   Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name \r\n   tcp        1      0 ramesh-laptop.loc:47212 192.168.185.75:www        CLOSE_WAIT  2109/firefox \r\n   tcp        0      0 ramesh-laptop.loc:52750 lax:www ESTABLISHED 2109/firefox \r\n   \r\n  5. 在 netstat 输出中不显示主机，端口和用户名 (host, port or user) \r\n   \r\n  当你不想让主机，端口和用户名显示，使用 netstat -n。将会使用数字代替那些名称。 \r\n   \r\n  同样可以加速输出，因为不用进行比对查询。 \r\n   \r\n  # netstat -an \r\n   \r\n  如果只是不想让这三个名称中的一个被显示，使用以下命令 \r\n   \r\n  # netsat -a --numeric-ports \r\n  # netsat -a --numeric-hosts \r\n  # netsat -a --numeric-users \r\n   \r\n   \r\n  6. 持续输出 netstat 信息 \r\n   \r\n  netstat 将每隔一秒输出网络信息。 \r\n   \r\n   \r\n  # netstat -c \r\n   Active Internet connections (w/o servers) \r\n   Proto Recv-Q Send-Q Local Address           Foreign Address         State \r\n   tcp        0      0 ramesh-laptop.loc:36130 101-101-181-225.ama:www ESTABLISHED \r\n   tcp        1      1 ramesh-laptop.loc:52564 101.11.169.230:www      CLOSING \r\n   tcp        0      0 ramesh-laptop.loc:43758 server-101-101-43-2:www ESTABLISHED \r\n   tcp        1      1 ramesh-laptop.loc:42367 101.101.34.101:www      CLOSING \r\n   ^C \r\n   \r\n   \r\n   \r\n  7. 显示系统不支持的地址族 (Address Families) \r\n   \r\n  netstat --verbose \r\n   \r\n  在输出的末尾，会有如下的信息 \r\n   \r\n  netstat: no support for `AF IPX\' on this system.  \r\n  netstat: no support for `AF AX25\' on this system.  \r\n  netstat: no support for `AF X25\' on this system.  \r\n  netstat: no support for `AF NETROM\' on this system.  \r\n   \r\n   \r\n  8. 显示核心路由信息 netstat -r \r\n   \r\n  # netstat -r \r\n   Kernel IP routing table \r\n   Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface \r\n   192.168.1.0     *               255.255.255.0   U         0 0          0 eth2 \r\n   link-local      *               255.255.0.0     U         0 0          0 eth2 \r\n   default         192.168.1.1     0.0.0.0         UG        0 0          0 eth2 \r\n   \r\n  注意： 使用 netstat -rn 显示数字格式，不查询主机名称。 \r\n   \r\n  9. 找出程序运行的端口 \r\n   \r\n  并不是所有的进程都能找到，没有权限的会不显示，使用 root 权限查看所有的信息。 \r\n   \r\n  # netstat -ap | grep ssh \r\n   tcp        1      0 dev-db:ssh           101.174.100.22:39213        CLOSE_WAIT  - \r\n   tcp        1      0 dev-db:ssh           101.174.100.22:57643        CLOSE_WAIT  - \r\n   \r\n    找出运行在指定端口的进程 \r\n   \r\n  # netstat -an | grep \':80\' \r\n   \r\n   \r\n  10. 显示网络接口列表 \r\n   \r\n  # netstat -i \r\n   Kernel Interface table \r\n   Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg \r\n   eth0       1500 0         0      0      0 0             0      0      0      0 BMU \r\n   eth2       1500 0     26196      0      0 0         26883      6      0      0 BMRU \r\n   lo        16436 0         4      0      0 0             4      0      0      0 LRU \r\n   \r\n  显示详细信息，像是 ifconfig 使用 netstat -ie: \r\n   \r\n   \r\n  # netstat -ie \r\n   Kernel Interface table \r\n   eth0      Link encap:Ethernet  HWaddr 00:10:40:11:11:11 \r\n   UP BROADCAST MULTICAST  MTU:1500  Metric:1 \r\n   RX packets:0 errors:0 dropped:0 overruns:0 frame:0 \r\n   TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 \r\n   collisions:0 txqueuelen:1000 \r\n   RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B) \r\n   Memory:f6ae0000-f6b00000 \r\n   \r\n   \r\n   \r\n   \r\n  11. IP和TCP分析 \r\n   \r\n    查看连接某服务端口最多的的IP地址 \r\n   \r\n   \r\n  wss8848@ubuntu:~$ netstat -nat | grep \"192.168.1.15:22\" |awk \'{print $5}\'|awk -F: \'{print $1}\'|sort|uniq -c|sort -nr|head -20 \r\n  18 221.136.168.36 \r\n  3 154.74.45.242 \r\n  2 78.173.31.236 \r\n  2 62.183.207.98 \r\n  2 192.168.1.14 \r\n  2 182.48.111.215 \r\n  2 124.193.219.34 \r\n  2 119.145.41.2 \r\n  2 114.255.41.30 \r\n  1 75.102.11.99 \r\n   \r\n   \r\n   \r\n    TCP各种状态列表 \r\n   \r\n   \r\n  wss8848@ubuntu:~$ netstat -nat |awk \'{print $6}\' \r\n  established) \r\n  Foreign \r\n  LISTEN \r\n  TIME_WAIT \r\n  ESTABLISHED \r\n  TIME_WAIT \r\n  SYN_SENT \r\n   \r\n   \r\n   \r\n    先把状态全都取出来,然后使用uniq -c统计，之后再进行排序。 \r\n   \r\n   \r\n   \r\n  wss8848@ubuntu:~$ netstat -nat |awk \'{print $6}\'|sort|uniq -c \r\n  143 ESTABLISHED \r\n  1 FIN_WAIT1 \r\n  1 Foreign \r\n  1 LAST_ACK \r\n  36 LISTEN \r\n  6 SYN_SENT \r\n  113 TIME_WAIT \r\n  1 established) \r\n   \r\n   \r\n   \r\n    最后的命令如下: \r\n   \r\n  netstat -nat |awk \'{print $6}\'|sort|uniq -c|sort -rn \r\n   \r\n  分析access.log获得访问前10位的ip地址 \r\n   \r\n  awk \'{print $1}\' access.log |sort|uniq -c|sort -nr|head -10 \r\n  \nnetstat -tup show all active network connections and their PID\nnetstat -tupl show all network services listening on the system and their PID\nnetstat -n | awk \'/^tcp/ {++state[$NF]} END {for(key in state) print key,\"  \",state[key]}\' 统计网络状态\n',''),(60,'tar','tar tar -cvf archive.tar file1 创建一个非压缩的 tarball\ntar -cvf archive.tar file1 file2 dir1 创建一个包含了 \'file1\', \'file2\' 以及 \'dir1\'的档案文件\ntar -tf archive.tar 显示一个包中的内容\ntar -xvf archive.tar 释放一个包\ntar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下\ntar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包\ntar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包\ntar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包\ntar -xvfz archive.tar.gz 解压一个gzip格式的压缩包\ntar -Puf backup.tar /home/user 执行一次对 \'/home/user\' 目录的交互式备份操作\ntar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接\n',''),(61,'time','time time 时间设定\r\n \r\n  　　查看/修改Linux时区和时间 \r\n  一、时区 \r\n  　　1. 查看当前时区 \r\n  　　date -R \r\n  　　2. 修改设置时区 \r\n  　　方法(1) \r\n  　　tzselect \r\n  　　方法(2) 仅限于RedHat Linux 和 CentOS \r\n  　　timeconfig \r\n  　　方法(3) 适用于Debian \r\n  　　dpkg-reconfigure tzdata \r\n  　　3. 复制相应的时区文件，替换系统时区文件；或者创建链接文件 \r\n  　　cp /usr/share/zoneinfo/$主时区/$次时区 /etc/localtime \r\n  　　在中国可以使用： \r\n  　　cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \r\n  二、时间 \r\n  　　1、查看时间和日期 \r\n  　　date \r\n  　　2、设置时间和日期 \r\n  　　将系统日期设定成1996年6月10日的命令 \r\n  　　date -s 06/22/96 \r\n  　　将系统时间设定成下午1点52分0秒的命令 \r\n  　　date -s 13:52:00 \r\n  　　3. 将当前时间和日期写入BIOS，避免重启后失效 \r\n  　　hwclock -w \r\n  三、定时同步时间 \r\n  　　* * * * * /usr/sbin/ntpdate 210.72.145.44 > /dev/null 2>&1 \r\n   \r\n   \r\n   \r\n  　在Linux中，用于时钟查看和设置的命令主要有date、hwclock和clock。其中，clock和hwclock用法相近，只用一个就行，只不过clock命令除了支持x86硬件体系外，还支持Alpha硬件体系。 \r\n   \r\n  　　查看Linux系统时间： \r\n  date \r\n  　　修改Linux系统时间： \r\n  date -s (后面跟时间) \r\n   \r\n  　　查看Linux硬件时间： \r\n  hwclock \r\n  或 \r\n  clock \r\n  或 \r\n  hwclock –show \r\n  或 \r\n  clock –show \r\n   \r\n  　　修改Linux硬件时间： \r\n  hwclock –set –date \r\n  或 \r\n  clock –set –date \r\n   \r\n  　　让系统时间与硬件时钟同步，用： \r\n  hwclock –hctosys \r\n  或 \r\n  clock –hctosys \r\n   \r\n  　　相反地，让硬件时钟与系统时间同步： \r\n  hwclock –systohc \r\n  或 \r\n  clock –systohc \r\n   \r\n  　　让系统时间每隔十分钟去同步一下硬件时间。 \r\n   \r\n  [hqw@localhost root]$ vi /etc/crontab \r\n  SHELL=/bin/bash \r\n  PATH=/sbin:/bin:/usr/sbin:/usr/bin  \r\n  MAILTO=root \r\n  HOME=/ \r\n  # run-parts  01 * * * * root run-parts /etc/cron.hourly \r\n  02 4 * * * root run-parts /etc/cron.daily \r\n  22 4 * * 0 root run-parts /etc/cron.weekly \r\n  42 4 1 * * root run-parts /etc/cron.monthly \r\n  */10 * * * * root hwclock --hctosys \r\n  #我加入了这么一行，表示每隔10分钟执行一次hwclock --hctosys。\n',''),(62,'date','date date 显示系统日期\ndate 041217002007.00 设置日期和时间 - 月日时分年.秒\n',''),(63,'crontab','crontab crontab 修改默认编辑器 \r\n  crontab默认编辑器为nano.  \r\n  修改crontab默认编辑器为vi或者其他的编辑器。 \r\n  法一： \r\n      export EDITOR=\"/usr/bin/vim\" ; crontab -e \r\n  法二： \r\n      执行命令：select-editor \r\n  然后选择编辑器.\r\n\r\n\r\n \r\n   crontab 使用说明\r\n\r\n\r\n \r\n  第1列分钟1～59 \r\n  第2列小时1～23（0表示子夜） \r\n  第3列日1～31 \r\n  第4列月1～12 \r\n  第5列星期0～6（0表示星期天） \r\n  第6列要运行的命令 \r\n   \r\n  下面是crontab的格式： \r\n  分 时 日 月 星期 要运行的命令 \r\n   \r\n  这里有crontab文件条目的一些例子： \r\n   \r\n  30 21 * * * /usr/local/apache/bin/apachectl restart \r\n  上面的例子表示每晚的21:30重启apache。 \r\n   \r\n  45 4 1,10,22 * * /usr/local/apache/bin/apachectl restart \r\n  上面的例子表示每月1、10、22日的4 : 45重启apache。 \r\n   \r\n  10 1 * * 6,0 /usr/local/apache/bin/apachectl restart \r\n  上面的例子表示每周六、周日的1 : 10重启apache。 \r\n   \r\n  0,30 18-23 * * * /usr/local/apache/bin/apachectl restart \r\n  上面的例子表示在每天18 : 00至23 : 00之间每隔30分钟重启apache。 \r\n   \r\n  0 23 * * 6 /usr/local/apache/bin/apachectl restart \r\n  上面的例子表示每星期六的11 : 00 pm重启apache。 \r\n   \r\n  * */1 * * * /usr/local/apache/bin/apachectl restart \r\n  每一小时重启apache \r\n   \r\n  * 23-7/1 * * * /usr/local/apache/bin/apachectl restart \r\n  晚上11点到早上7点之间，每隔一小时重启apache \r\n   \r\n  0 11 4 * mon-wed /usr/local/apache/bin/apachectl restart \r\n  每月的4号与每周一到周三的11点重启apache \r\n   \r\n  0 4 1 jan * /usr/local/apache/bin/apachectl restart \r\n  一月一号的4点重启apache\n',''),(64,'gzip','gzip gzip file1 压缩一个叫做 \'file1\'的文件\ngzip -9 file1 最大程度压缩\ngzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件\n',''),(65,'mk','mk mkdir dir1 创建一个叫做 \'dir1\' 的目录\'\nmkdir dir1 dir2 同时创建两个目录\nmkdir -p /tmp/dir1/dir2 创建一个目录树\nmkfs /dev/hda1 在hda1分区创建一个文件系统\nmke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统\nmke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统\nmkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统\nmkswap /dev/hda3 创建一个swap文件系统\nmkswap /dev/hda3 创建一个swap文件系统\nmkisofs /dev/cdrom > cd.iso 在磁盘上创建一个光盘的iso镜像文件\nmkisofs /dev/cdrom | gzip > cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件\nmkisofs -J -allow-leading-dots -R -V \"Label CD\" -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件\nmksf.ext3 /dev/sdb1 把第二块硬盘的第一个主分区格式化为ext3\nmkswap /dev/sdb2 初始化swap区，此区不可格式化。\n',''),(66,'route','route route -n show routing table\nroute add -net 0/0 gw IP_Gateway configura default gateway\nroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network \'192.168.0.0/16\'\nroute del 0/0 gw IP_gateway remove static route\nroute route详解 \r\n    为了让设备能访问另一个子网，需要在设备里增加路由到子网络，下面是一些资料。基本操作如下： \r\n   \r\n  一般来说，都是为了能访问别的子网才设置路由的，比如说，你的主机处于192.168.10.0/24，而你想访问192.168.20.0/24网的主机，当然你知道一个网关IP，例如192.168.10.1（必须和你主机处于同一子网），那么，你可以这样配置路由。 \r\n   \r\n  添加路由 \r\n   \r\n  route add -net 192.168.20.0 netmask 255.255.255.0 gw 192.168.10.1 \r\n   \r\n  查看路由状态 \r\n   \r\n  route -n \r\n   \r\n  删除路由 \r\n   \r\n  route del -net 192.168.20.0 netmask 255.255.255.0 \r\n   \r\n   \r\n   \r\n  摘自鸟哥的私房菜 \r\n  路由修改 route       \r\n      我们在网路基础的时候谈过关于路由的问题，两部主机之间一定要有路由才能够互通 TCP/IP 的协定，否则就无法进行连线啊！ \r\n  一般来说，只要有网路介面，该介面就会产生一个路由，例如在鸟哥实验室内部的主机有一个 eth0 及 lo ，所以： \r\n  [root@linux ~]# route [-nee] \r\n  [root@linux ~]# route add [-net|-host] [网域或主机] netmask [mask] [gw|dev] \r\n  [root@linux ~]# route del [-net|-host] [网域或主机] netmask [mask] [gw|dev] \r\n  观察的参数： \r\n     -n  ：不要使用通讯协定或主机名称，直接使用 IP 或 port number； \r\n     -ee ：使用更详细的资讯来显示 \r\n  增加 (add) 与删除 (del) 路由的相关参数： \r\n     -net    ：表示后面接的路由为一个网域； \r\n     -host   ：表示后面接的为连接到单部主机的路由； \r\n     netmask ：与网域有关，可以设定 netmask 决定网域的大小； \r\n     gw      ：gateway 的简写，后续接的是 IP 的数值喔，与 dev 不同； \r\n     dev     ：如果只是要指定由那一块网路卡连线出去，则使用这个设定，后面接 eth0 等 \r\n  范例一：单纯的观察路由状态 \r\n  [root@linux ~]# route -n \r\n  Kernel IP routing table \r\n  Destination     Gateway         Genmask         Flags Metric Ref    Use Iface \r\n  192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 eth0 \r\n  169.254.0.0     0.0.0.0         255.255.0.0     U     0      0        0 eth0 \r\n  0.0.0.0         192.168.10.30   0.0.0.0         UG    0      0        0 eth0 \r\n  [root@linux ~]# route \r\n  Kernel IP routing table \r\n  Destination     Gateway         Genmask         Flags Metric Ref    Use Iface \r\n  192.168.10.0    *               255.255.255.0   U     0      0        0 eth0 \r\n  169.254.0.0     *               255.255.0.0     U     0      0        0 eth0 \r\n  default         server.cluster      0.0.0.0         UG    0      0        0 eth0 \r\n     由上面的例子当中仔细观察 route 与 route -n 的输出结果，你可以发现有加 -n参数的主要是显示出 IP ，至于使用 route 而已的话，显示的则是『主机名称』喔！也就是说，在预设的情况下， route 会去找出该 IP 的主机名称，如果找不到呢？就会显示的钝钝的(有点小慢)，所以说，鸟哥通常都直接使用 route -n 啦！由上面看起来，我们也知道 default = 0.0.0.0/0.0.0.0 ，而上面的资讯有哪些你必须要知道的呢？ \r\n                 \r\n   \r\n  · Destination, Genmask：这两个玩意儿就是分别是 network 与netmask 啦！所以这两个咚咚就组合成为一个完整的网域囉！ \r\n   \r\n  · Gateway：该网域是通过那个 gateway 连接出去的？ 如果显示 0.0.0.0 表示该路由是直接由本机传送，亦即可以透过区域网路的 MAC 直接传讯；如果有显示 IP 的话，表示该路由需要经过路由器 (通讯闸) 的帮忙才能够传送出去。 \r\n   \r\n  · Flags：总共有多个旗标，代表的意义如下：                        \r\n   \r\n  o U (route is up)：该路由是启动的；                       \r\n   \r\n  o H (target is a host)：目标是一部主机 (IP) 而非网域；                       \r\n   \r\n  o G (use gateway)：需要透过外部的主机 (gateway) 来转递封包；                       \r\n   \r\n  o R (reinstate route for dynamic routing)：使用动态路由时，恢复路由资讯的旗标；                       \r\n   \r\n  o D (dynamically installed by daemon or redirect)：已经由服务或转 port 功能设定为动态路由                       \r\n   \r\n  o M (modified from routing daemon or redirect)：路由已经被修改了；                       \r\n   \r\n  o !  (reject route)：这个路由将不会被接受(用来抵挡不安全的网域！) \r\n   \r\n  · Iface：这个路由传递封包的介面。 \r\n   \r\n  此外，观察一下上面的路由排列顺序喔，依序是由小网域(192.168.10.0/24 是 Class C)，逐渐到大网域(169.254.0.0/16 Class B) 最后则是预设路由 (0.0.0.0/0.0.0.0)。然后当我们要判断某个网路封包应该如何传送的时候，该封包会经由这个路由的过程来判断喔！举例来说，我上头仅有三个路由，若我有一个传往 192.168.10.20 的封包要传递，那首先会找 192.168.10.0/24 这个网域的路由，找到了！所以直接由 eth0 传送出去；如果是传送到 Yahoo 的主机呢？ Yahoo 的主机 IP 是 202.43.195.52，我通过判断 \r\n   \r\n  1)不是 192.168.10.0/24， \r\n         2)不是 169.254.0.0/16 结果到达 \r\n   \r\n  3)0/0 时，OK！传出去了，透过 eth0 将封包传给 192.168.10.30那部 gateway 主机啊！所以说，路由是有顺序的。因此当你重复设定多个同样的路由时，例如在你的主机上的两张网路卡设定为相同网域的 IP 时，会出现什么情况？会出现如下的情况： \r\n  Kernel IP routing table \r\n  Destination     Gateway         Genmask         Flags Metric Ref    Use Iface \r\n  192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 eth0 \r\n  192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 eth1 \r\n  也就是说，由于路由是依照顺序来排列与传送的，所以不论封包是由那个介面 (eth0, eth1) 所接收，都会由上述的 eth0 传送出去，所以，在一部主机上面设定两个相同网域的 IP 本身没有什么意义！有点多此一举就是了。除非是类似虚拟主机 (Xen, VMware 等软体) 所架设的多主机时，才会有这个必要～ \r\n  范例二：路由的增加与删除 \r\n  [root@linux ~]# route del -net 169.254.0.0 netmask 255.255.0.0 dev eth0 \r\n  # 上面这个动作可以删除掉 169.254.0.0/16 这个网域！ \r\n  # 请注意，在删除的时候，需要将路由表上面出现的资讯都写入 \r\n  # 包括  netmask , dev 等等参数喔！注意注意 \r\n  [root@linux ~]# route add -net 192.168.100.0 netmask 255.255.255.0 dev eth0 \r\n  # 透过 route add 来增加一个路由！请注意，这个路由必须要能够与你互通。 \r\n  # 举例来说，如果我下达底下的指令就会显示错误： \r\n  # route add -net 192.168.200.0 netmask 255.255.255.0 gw 192.168.200.254 \r\n  # 因为我的环境内仅有 192.168.10.100 这个 IP ，所以不能与 192.168.200.254 \r\n  # 这个网段直接使用 MAC 互通！这样说，可以理解喔！？ \r\n  [root@linux ~]# route add default gw 192.168.10.30 \r\n  # 增加预设路由的方法！请注意，只要有一个预设路由就够了喔！ \r\n  # 在这个地方如果您随便设定后，记得使用底下的指令重新设定你的网路 \r\n  # /etc/init.d/network restart \r\n        如果是要进行路由的删除与增加，那就得要参考上面的例子了，其实，使用 man route 里面的资料就很丰富了！仔细查阅一下囉！你只要记得，当出现『SIOCADDRT: Network is unreachable』这个错误时，肯定是由于 gw 后面接的 IP 无法直接与您的网域沟通 (Gateway 并不在你的网域内)，所以，赶紧检查一下是否输入错误啊！加油吧！ \r\n   \r\n   \r\n   \r\n  # route 命令添加的路由，机器重启或者网卡重启后就没掉了，在linux下设置永久路由的方法： \r\n  1.在/etc/rc.local里添加 \r\n  2.在/etc/sysconfig/network里添加到末尾 \r\n  3./etc/sysconfig/static-router : \r\n  any net x.x.x.x/24 gw y.y.y.y \r\n   \r\n   \r\n   \r\n  ===========================================================================================   WINDOWS下的route命令： \r\n   \r\n  简单的的操作如下， \r\n   \r\n  查看路由状态：route print \r\n   \r\n  只查看ipv4（ipv6）路由状态：route print -4(-6) \r\n   \r\n  添加路由：route add 目的网络 mask 子网掩码 网关 ——重启机器或网卡失效 \r\n   \r\n  route add 192.168.20.0 mask 255.255.255.0 192.168.10.1 \r\n   \r\n  添加永久：route -p add 目的网络 mask 子网掩码网关 \r\n   \r\n  route -p add 192.168.20.0 mask 255.255.255.0 192.168.10.1 \r\n   \r\n  删除路由：route delete 目的网络 mask 子网掩码 \r\n   \r\n  route delete 192.168.20.0 mask 255.255.255.0\n',''),(67,'unix2dos','unix2dos unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS\n',''),(68,'dos2unix','dos2unix dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX\n',''),(69,'if','if if 条件判断 \r\n  #!/bin/sh \r\n  SYSTEM=`uname -s`    #获取操作系统类型，我本地是linux \r\n  if [ $SYSTEM = \"Linux\" ] ; then     #如果是linux的话打印linux字符串 \r\n  echo \"Linux\" \r\n  elif [ $SYSTEM = \"FreeBSD\" ] ; then   \r\n  echo \"FreeBSD\" \r\n  elif [ $SYSTEM = \"Solaris\" ] ; then \r\n  echo \"Solaris\" \r\n  else \r\n  echo \"What?\" \r\n  fi     #ifend \r\n  基本上和其他脚本语言一样。没有太大区别。不过值得注意的是。[]里面的条件判断。 \r\n  1 字符串判断 \r\n  str1 = str2　　　　　　当两个串有相同内容、长度时为真 \r\n  str1 != str2　　　　　 当串str1和str2不等时为真 \r\n  -n str1　　　　　　　 当串的长度大于0时为真(串非空) \r\n  -z str1　　　　　　　 当串的长度为0时为真(空串) \r\n  str1　　　　　　　　   当串str1为非空时为真 \r\n  2 数字的判断 \r\n  int1 -eq int2　　　　两数相等为真 \r\n  int1 -ne int2　　　　两数不等为真 \r\n  int1 -gt int2　　　　int1大于int2为真 \r\n  int1 -ge int2　　　　int1大于等于int2为真 \r\n  int1 -lt int2　　　　int1小于int2为真 \r\n  int1 -le int2　　　　int1小于等于int2为真 \r\n   \r\n  3 文件的判断 \r\n  -r file　　　　　用户可读为真 \r\n  -w file　　　　　用户可写为真 \r\n  -x file　　　　　用户可执行为真 \r\n  -f file　　　　　文件为正规文件为真 \r\n  -d file　　　　　文件为目录为真 \r\n  -c file　　　　　文件为字符特殊文件为真 \r\n  -b file　　　　　文件为块特殊文件为真 \r\n  -s file　　　　　文件大小非0时为真 \r\n  -t file　　　　　当文件描述符(默认为1)指定的设备为终端时为真 \r\n  3 复杂逻辑判断 \r\n  -a 　 　　　　　 与 \r\n  -o　　　　　　　 或 \r\n  !　　　　　　　　非\n',''),(70,'for','for for 循环语句 \r\n  EX1 for循环遍历数组: \r\n   \r\n  #!/bin/sh \r\n  WORD=\"a b c d e f g h i j l m n o p q r s t u v w x y z\" \n  for i in $WORD ; do   // 遍历WORD变量里面的数据 \r\n  echo $i                     // 输出WORD数据集中的没有元素 \r\n  done                         // 循环结束 \r\n  程序依次读入WORD中的元素赋给变量i,然后输出i的值,有没有发现,shell的语法中,变量没有数据类型?是的,就是这样.  \r\n   \r\n  EX2 for循环遍历文件: \r\n   \r\n  #!/bin/sh \r\n  FILES=`ls /txt/*.txt` \r\n  for txt in $FILES ; do  \r\n  mv $txt /newDir/$txt \r\n  done \r\n  以上代码是将/txt/*.txt转移到新目录下，数据集来源于ls指令的结果，通过重定向输入到变量FILES中。 \r\n   \r\n   \r\n  EX3 while循环: \r\n   \r\n  #!/bin/sh \r\n  while : ; do \r\n  echo \"do something forever here\" \r\n  sleep 5 \r\n  done \r\n  无限循环打印\"do something forever here\" ，间隔5秒\n','// 注意,等号两边不要留空格.这会产生运行错误.  \r'),(71,'mount','mount mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 \'/ mnt/hda2\' 已经存在\nmount /dev/fd0 /mnt/floppy 挂载一个软盘\nmount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom\nmount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom\nmount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom\nmount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件\nmount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统\nmount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备\nmount -t smbfs -o username=user,password=pass \nmount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件\nmount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share mount a windows network share\nmount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share mount a windows network share\n','//WinClient/share /mnt/share 挂载一个windows网络共享'),(72,'gdb','gdb gdb 简要说明\r\n \r\n  一、执行文件 \r\n   \r\n  file <文件名>   加载被调试的可执行程序文件。 \r\n  因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。   \r\n  (gdb) file gdb-sample \r\n   \r\n  二、运行程序 \r\n   \r\n  r Run的简写，运行被调试的程序。 \r\n  如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。  \r\n  (gdb) r \r\n   \r\n  三、继续运行 \r\n   \r\n  c   Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。  \r\n  (gdb) c \r\n   \r\n  四、断点 \r\n   \r\n  b <行号> \r\n  b <函数名称> \r\n  b *<函数名称> \r\n  b *<代码地址> \r\n  d [编号] \r\n  b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。 \r\n  其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。 \r\n  d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。 \r\n      \r\n  (gdb) b 8 \r\n  (gdb) b main \r\n  (gdb) b *main \r\n  (gdb) b *0x804835c \r\n  (gdb) d \r\n   \r\n  五、单步调试 \r\n   \r\n  s, n    s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数； \r\n  n: 执行一行源程序代码，此行代码中的函数调用也一并执行。 \r\n  s 相当于其它调试器中的“Step Into (单步跟踪进入)”； \r\n  n 相当于其它调试器中的“Step Over (单步跟踪)”。 \r\n  这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。 \r\n  (gdb) s \r\n  (gdb) n \r\n  si, ni  si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。  \r\n  (gdb) si \r\n  (gdb) ni \r\n   \r\n   \r\n  六、打印变最 \r\n   \r\n  p <变量名称>    Print的简写，显示指定变量（临时变量或全局变量）的值。   \r\n  (gdb) p i \r\n   \r\n   \r\n  (gdb) p nGlobalVar \r\n  display ...  \r\n   \r\n  七、打印信息 \r\n   \r\n  undisplay <编号> \r\n  display，设置程序中断后欲显示的数据及其格式。 \r\n  例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令 \r\n  “display /i $pc” \r\n  其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。 \r\n  undispaly，取消先前的display设置，编号从1开始递增。 \r\n  (gdb) display /i $pc \r\n  (gdb) undisplay 1 \r\n  i   Info的简写，用于显示各类信息，详情请查阅“help i”。 \r\n  (gdb) i r \r\n  q   Quit的简写，退出GDB调试环境。   \r\n  (gdb) q \r\n  help [命令名称]     GDB帮助命令，提供对GDB名种命令的解释说明。 \r\n  如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。   \r\n  (gdb)\n',''),(73,'nmap','nmap nmap nmap 命令使用 \r\n  扫描单一的一个主机，命令如下： \r\n   \r\n  #nmap nxadmin.com \r\n   \r\n  #nmap 192.168.1.2 \r\n   \r\n  扫描整个子网,命令如下: \r\n   \r\n  #nmap 192.168.1.1/24 \r\n   \r\n  扫描多个目标,命令如下： \r\n   \r\n  #nmap 192.168.1.2 192.168.1.5 \r\n   \r\n  扫描一个范围内的目标,如下： \r\n   \r\n  #nmap 192.168.1.1-100 (扫描IP地址为192.168.1.1-192.168.1.100内的所有主机) \r\n   \r\n  如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下,扫描这个txt内的所有主机，命令如下： \r\n   \r\n  #nmap -iL target.txt \r\n   \r\n  如果你想看到你扫描的所有主机的列表，用以下命令: \r\n   \r\n  #nmap -sL 192.168.1.1/24 \r\n   \r\n  扫描除过某一个ip外的所有子网主机,命令： \r\n   \r\n  #nmap 192.168.1.1/24 -exclude 192.168.1.1 \r\n   \r\n  扫描除过某一个文件中的ip外的子网主机命令 \r\n   \r\n  #nmap 192.168.1.1/24 -exclude file xxx.txt  (xxx.txt中的文件将会从扫描的主机中排除) \r\n   \r\n  扫描特定主机上的80,21,23端口,命令如下 \r\n   \r\n  #nmap -p80,21,23 192.168.1.1 \r\n   \r\n   \r\n   \r\n   \r\n  从上面我们已经了解了Nmap的基础知识，下面我们深入的探讨一下Nmap的扫描技术.  \r\n   \r\n  Tcp SYN Scan (sS) \r\n   \r\n  这是一个基本的扫描方式,它被称为半开放扫描，因为这种技术使得Nmap不需要通过完整的握手，就能获得远程主机的信息。Nmap发送SYN包到远程主机，但是它不会产生任何会话.因此不会在目标主机上产生任何日志记录,因为没有形成会话。这个就是SYN扫描的优势.  \r\n   \r\n  如果Nmap命令中没有指出扫描类型,默认的就是Tcp SYN.但是它需要root/administrator权限.  \r\n   \r\n  #nmap -sS 192.168.1.1 \r\n   \r\n  Tcp connect() scan(sT) \r\n   \r\n  如果不选择SYN扫描,TCP connect()扫描就是默认的扫描模式.不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect().Tcp connect()扫描技术只适用于找出TCP和UDP端口.  \r\n   \r\n  #nmap -sT 192.168.1.1 \r\n   \r\n  Udp scan(sU) \r\n   \r\n  顾名思义,这种扫描技术用来寻找目标主机打开的UDP端口.它不需要发送任何的SYN包，因为这种技术是针对UDP端口的。UDP扫描发送UDP数据包到目标主机，并等待响应,如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的.  \r\n   \r\n  #nmap -sU 192.168.1.1 \r\n   \r\n  FIN scan (sF) \r\n   \r\n  有时候Tcp SYN扫描不是最佳的扫描模式,因为有防火墙的存在.目标主机有时候可能有IDS和IPS系统的存在,防火墙会阻止掉SYN数据包。发送一个设置了FIN标志的数据包并不需要完成TCP的握手.  \r\n   \r\n  root@bt:~# nmap -sF 192.168.1.8 \r\n   \r\n  Starting Nmap 5.51  at 2012-07-08 19:21 PKT \r\n   \r\n  Nmap scan report for 192.168.1.8 \r\n   \r\n  Host is up (0.000026s latency).  \r\n   \r\n  Not shown: 999 closed ports \r\n   \r\n  PORT STATE SERVICE \r\n   \r\n  111/tcp open|filtered rpcbind \r\n   \r\n  FIN扫描也不会在目标主机上创建日志(FIN扫描的优势之一).个类型的扫描都是具有差异性的,FIN扫描发送的包只包含FIN标识,NULL扫描不发送数据包上的任何字节,XMAS扫描发送FIN、PSH和URG标识的数据包.  \r\n   \r\n  PING Scan (sP) \r\n   \r\n  PING扫描不同于其它的扫描方式，因为它只用于找出主机是否是存在在网络中的.它不是用来发现是否开放端口的.PING扫描需要ROOT权限，如果用户没有ROOT权限,PING扫描将会使用connect()调用.  \r\n   \r\n  #nmap -sP 192.168.1.1 \r\n   \r\n  版本检测(sV) \r\n   \r\n  版本检测是用来扫描目标主机和端口上运行的软件的版本.它不同于其它的扫描技术，它不是用来扫描目标主机上开放的端口，不过它需要从开放的端口获取信息来判断软件的版本.使用版本检测扫描之前需要先用TCP SYN扫描开放了哪些端口.  \r\n   \r\n  #nmap -sV 192.168.1.1 \r\n   \r\n  Idle scan (sL) \r\n   \r\n  Idle scan是一种先进的扫描技术，它不是用你真实的主机Ip发送数据包，而是使用另外一个目标网络的主机发送数据包.  \r\n   \r\n  #nmap -sL 192.168.1.6 192.168.1.1 \r\n   \r\n  Idle scan是一种理想的匿名扫描技术,通过目标网络中的192.168.1.6向主机192.168.1.1发送数据，来获取192.168.1.1开放的端口 \r\n   \r\n  有需要其它的扫描技术，如FTP bounce（FTP反弹）, fragmentation scan（碎片扫描）, IP protocol scan（IP协议扫描）,以上讨论的是几种最主要的扫描方式.  \r\n   \r\n  Nmap的OS检测（O） \r\n   \r\n  Nmap最重要的特点之一是能够远程检测操作系统和软件，Nmap的OS检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的，通过获取的信息你可以知道已知的漏洞。Nmap有一个名为的nmap-OS-DB数据库，该数据库包含超过2600操作系统的信息。Nmap把TCP和UDP数据包发送到目标机器上，然后检查结果和数据库对照。 \r\n   \r\n  Initiating SYN Stealth Scan at 10:21 \r\n  Scanning localhost (127.0.0.1) [1000 ports] \r\n  Discovered open port 111/tcp on 127.0.0.1 \r\n  Completed SYN Stealth Scan at 10:21, 0.08s elapsed (1000 total ports) \r\n  Initiating OS detection (try #1) against localhost (127.0.0.1) \r\n  Retrying OS detection (try #2) against localhost (127.0.0.1) \r\n   \r\n  上面的例子清楚地表明，Nmap的首次发现开放的端口，然后发送数据包发现远程操作系统。操作系统检测参数是O（大写O） \r\n   \r\n   \r\n   \r\n   \r\n  Nmap的操作系统指纹识别技术： \r\n   \r\n  设备类型（路由器，工作组等） \r\n  运行（运行的操作系统） \r\n  操作系统的详细信息（操作系统的名称和版本） \r\n  网络距离（目标和攻击者之间的距离跳） \r\n   \r\n  如果远程主机有防火墙，IDS和IPS系统，你可以使用-PN命令来确保不ping远程主机，因为有时候防火墙会组织掉ping请求.-PN命令告诉Nmap不用ping远程主机。 \r\n   \r\n  # nmap -O -PN 192.168.1.1/24 \r\n   \r\n  以上命令告诉发信主机远程主机是存活在网络上的，所以没有必要发送ping请求,使用-PN参数可以绕过PING命令,但是不影响主机的系统的发现.  \r\n   \r\n  Nmap的操作系统检测的基础是有开放和关闭的端口，如果OS scan无法检测到至少一个开放或者关闭的端口，会返回以下错误： www.2cto.com \r\n   \r\n  Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port \r\n   \r\n  OS Scan的结果是不可靠的，因为没有发现至少一个开放或者关闭的端口.  \r\n   \r\n  这种情况是非常不理想的，应该是远程主机做了针对操作系统检测的防范。如果Nmap不能检测到远程操作系统类型，那么就没有必要使用-osscan_limit检测。 \r\n   \r\n   \r\n   \r\n  想好通过Nmap准确的检测到远程操作系统是比较困难的，需要使用到Nmap的猜测功能选项, –osscan-guess 猜测认为最接近目标的匹配操作系统类型。 \r\n   \r\n  # nmap -O --osscan-guess 192.168.1.1 \r\n   \r\n  总结 \r\n   \r\n  Nmap是一个非常强大的工具，它具有覆盖渗透测试的第一方面的能力，其中包括信息的收集和统计。本文从初级到高级的讲解了Nmap入侵扫描工具的使用.希望对大家有所帮助.\n',''),(74,'chattr','chattr chattr +a file1 只允许以追加方式读写文件\nchattr +c file1 允许这个文件能被内核自动压缩/解压\nchattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件\nchattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接\nchattr +s file1 允许一个文件被安全地删除\nchattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘\nchattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件\n',''),(75,'chage','chage chage -E 2005-12-31 user1 设置用户口令的失效期限\n',''),(76,'vsftp','vsftp vsftp vsftpd配置\r\n \r\n  之前配置的vsftp，为了省事和方便，都是用系统用户。今天有人找我配置一个采用虚拟用户的系统 \r\n  CU看了看精华帖子，然后照做之，很容易就成功了 \r\n  需要说明的是，如果系统已经安装了rpm，可以直接修改rpm的配置文件 \r\n  rpm的配置文件在/etc/vsftpd/vsftpd.conf \r\n  如果是tar源码安装，配置文件在/etc/vsftpd.conf \r\n  rpm的可执行文件在/usr/sbin/vsftpd \r\n  tar的可执行文件在/usr/local/sbin/vsftpd \r\n  不要在已经安装了rpm的情况下去用tar编译，我就是这么干的，结果弄的我晕死 \r\n  因为默认的PATH搜索路径中，/usr/sbin/ 是比/usr/local/sbin/优先的。 \r\n  rpm安装很简单，tar安装也很简单，需要做的工作就是修改配置文件 \r\n  如果从源码安装，我们可以打开一些功能 \r\n  # vi builddefs.h  \\\\编辑builddefs.h 文件，文件内容如下： \r\n  #ifndef VSF_BUILDDEFS_H \r\n  #define VSF_BUILDDEFS_H \r\n  #undef VSF_BUILD_TCPWRAPPERS \r\n  #define VSF_BUILD_PAM \r\n  #undef VSF_BUILD_SSL \r\n  把需要的功能前面的undef 改成define，然后编译就可以用了。 \r\n  tcp_wrappers是一个比较有用的功能， \r\n  创建必要的帐号，目录： \r\n  # useradd nobody  \n  # mkdir /usr/share/empty  //可能你的系统已经存在此目录，那就不用建立 \r\n  # mkdir /var/ftp  //可能你的系统已经存在此目录，那就不用建立 \r\n  # useradd -d /var/ftp ftp  \n  # chown root:root /var/ftp \r\n  # chmod og-w /var/ftp \r\n  请记住，如果你不想让用户在本地登陆，那么你需要把他的登陆SHELL设置成/sbin/nologin，比如以上的nobody和ftp我就设置成/sbin/nologin \r\n  #make \r\n  #make install \r\n  这样就安装完成了。接下来要做的事情就是修改配置文件 \r\n  虚拟用户形式实现（db及mysql形式） \r\n  虚拟用户可以采用两种方法，一种是db，一种是mysql集成 \r\n  db方式 \r\n   \r\n  1)先看系统是否安装了db的软件包。默认应该是有了 \r\n  # rpm –qa | grep db4 \r\n  db4-devel-4.2.52-7.1 \r\n  db4-4.2.52-7.1 \r\n  db4-utils-4.2.52-7.1 \r\n   \r\n  2)建立一个logins.txt的文件，单行为用户名，双行为密码，例如 \r\n  # vi /home/logins.txt \r\n  coolerfeng \r\n  12345 \r\n   \r\n  (3)建立数据库文件并设置文件属性 \r\n  # db_load -T -t hash -f /home/logins.txt /etc/vsftpd_login.db \r\n  # chmod 600 /etc/vsftpd_login.db \r\n   \r\n  (4)建立认证文件 \r\n  # vi /etc/pam.d/ftp 插入如下两行 \r\n  auth required /lib/security/pam_userdb.so db=/etc/vsftpd_login \r\n  account required /lib/security/pam_userdb.so db=/etc/vsftpd_login \r\n   \r\n  (5)建立一个虚拟用户 \r\n  useradd -d /home/vsftpd -s /sbin/nologin vsftpd \r\n  ls -ld /home/vsftpd \r\n  drwx------  3 vsftpd vsftpd 1024 Jun  6 22:55 /home/vsftpd/ \r\n   \r\n  (6)编写配置文件(注意事项请参看匿名用户的配置，这里不再赘述) \r\n  # vi /etc/vsftpd-pam.conf \r\n  listen=YES \r\n  listen_port=21 \r\n  tcp_wrappers=YES //支持tcp_wrappers,限制访问(/etc/hosts.allow,/etc/hosts.deny) \r\n  listen=YES的意思是使用standalone启动vsftpd，而不是super daemon(xinetd)控制它 (vsftpd推荐使用standalone方式) \r\n  anonymous_enable=NO \r\n  local_enable=YES  //PAM方式此处必须为YES，如果不是将出现如下错误： \r\n  500 OOPS: vsftpd: both local and anonymous access disabled!  \r\n  write_enable=NO \r\n  anon_upload_enable=NO \r\n  anon_mkdir_write_enable=NO \r\n  anon_other_write_enable=NO \r\n  chroot_local_user=YES \r\n  guest_enable=YES \r\n  guest_username=vsftpd //这两行的意思是采用虚拟用户形式 \r\n  virtual_use_local_privs=YES //虚拟用户和本地用户权限相同 \r\n  pasv_enable=YES //建立资料联机采用被动方式 \r\n  pasv_min_port=30000 //建立资料联机所可以使用port 范围的上界，0表示任意。默认值为0。 \r\n  pasv_max_port=30999 //建立资料联机所可以使用port 范围的下界，0表示任意。默认值为0。 \r\n   \r\n  (7)启动程序 \r\n  # /usr/local/sbin/vsftpd-pam /etc/vsftpd-pam.conf & \r\n   \r\n  (8)测试连通及功能 \r\n  # vi /home/vsftpd/test //建立一个文件，内容如下 \r\n  1234567890 \r\n  # chown vsftpd.vsftpd /home/vsftpd/test \r\n  # ftp 127.0.0.1 \r\n  Connected to 127.0.0.1.  \r\n  220 (vsFTPd 2.0.3) \r\n  530 Please login with USER and PASS.  \r\n  530 Please login with USER and PASS.  \r\n  KERBEROS_V4 rejected as an authentication type \r\n  Name (127.0.0.1:root): xuchen \r\n  331 Please specify the password.  \r\n  Password: \r\n  230 Login successful.  \r\n  Remote system type is UNIX.  \r\n  Using binary mode to transfer files.  \r\n  ftp>; pwd \r\n  257 \"/\" \r\n  ftp>; size test \r\n  213 11 \r\n  ftp>; quit \r\n  221 Goodbye.  \r\n  OK，用户名为xuchen,密码为12345可以连接到FTP服务器，看不到文件列表，但可以下载已知文件名的文件，不能上传文件，非常安全吧！！ \r\n  如果我们需要用户看到文件，怎么办？也好办,在配置文件中加入如下语句： \r\n  anon_world_readable_only=NO  //匿名登入者不能下载可阅读的档案，默认值为YES \r\n  如果需要让用户上传文件和下载文件分开，建议如下这么做 \r\n  # vi /home/logins.txt \r\n  xuchen \r\n  12345 \r\n  upload \r\n  45678 \r\n  //首先建立虚拟用户upload，密码为45678 \r\n  # db_load -T -t hash -f /home/logins.txt /etc/vsftpd_login.db //更新数据文件 \r\n  # mkdir /home/vsftpd/upload \r\n  # vi /etc/vsftpd-pam.conf 加入如下语句 \r\n  user_config_dir=/etc/vsftpd_user_conf \r\n  # mkdir /etc/vsftpd_user_conf \r\n  # vi /etc/vsftpd_user_conf/upload 文件内容如下 \r\n  local_root=/home/vsftpd/upload \r\n  write_enable=YES \r\n  anon_world_readable_only=NO \r\n  anon_upload_enable=YES \r\n  anon_mkdir_write_enable=YES \r\n  anon_other_write_enable=YES \r\n  # chmod 700 /home/vsftpd/upload \r\n  # chown vsftpd.vsftpd /home/vsftpd/upload/ \r\n  这样，xuchen用户可以下载/home/vsftpd里的文件及upload里的文件，而upload用户可以上传和下载/home/vsftpd/upload文件夹的东西，但不能到/home/vsftpd里下载文件，很简单得实现了分用户上传和下载 \r\n  对于用Mysql库存储用户名及密码的方式来说： \r\n  就是把用户名和密码放在mysql库里，实现起来也相当简单 \r\n  （1）建立一个库并设置相应权限 \r\n  # mysql –p \r\n  mysql>;create database ftpd; \r\n  mysql>;use ftpd; \r\n  mysql>;create table user(name char(20) binary,passwd char(20) binary); \r\n  mysql>;insert into user (name,passwd) values (\'test1\',\'12345\'); \r\n  mysql>;insert into user (name,passwd) values (\'test2\',\'54321\'); \r\n  mysql>;grant select on ftpd.user to ftpd@localhost identified by \'123456\'; \r\n  mysql>;flush privileges; 刷新权限设置 \r\n  mysql>;quit \r\n  （2）下载libpam-mysql进行安装编译 \r\n  下载地址如下： \r\n  [url]http://nchc.dl.sourceforge.net/sourceforge/pam-mysql/pam_mysql-0.5.tar.gz[/url] \r\n  假设我们把它放在了/home/xuchen目录下 \r\n  # cd /home/xuchen \r\n  # tar xzvf pam_mysql-0.5.tar.gz \r\n  # cd pam_mysql \r\n  # make \r\n  # cp pam_mysql.so /lib/security \r\n  （3）建立PAM认证信息 \r\n  # vi /etc/pam.d/ftp ,内容如下 \r\n  auth required /lib/security/pam_mysql.so user=ftpd passwd=123456 host=localhost db=ftpd table=user usercolumn=name passwdcolumn=passwd crypt=0 \r\n  account required /lib/security/pam_mysql.so user=ftpd passwd=123456 host=localhost db=ftpd table=user usercolumn=name passwdcolumn=passwd crypt=0 \r\n  注意： \r\n  crypt= n \r\n  crypt=0: 明文密码 \r\n  crypt=1: 使用crpyt()函数(对应SQL数据里的encrypt()，encrypt()随机产生salt) \r\n  crypt=2: 使用MYSQL中的password()函数加密 \r\n  crypt=3：表示使用md5的散列方式 \r\n  （4）建立本地虚拟用户 \r\n  # useradd -d /home/ftpd -s /sbin/nologin ftpd \r\n  （5）下面就差修改vsftpd.conf文件了，我把我的提供给大家参考吧：） \r\n  # vi /etc/vsftpd-pam1.conf \r\n  anonymous_enable=NO \r\n  local_enable=YES \r\n  write_enable=YES \r\n  local_umask=022 \r\n  anon_upload_enable=YES \r\n  anon_mkdir_write_enable=YES \r\n  anon_other_write_enable=YES \r\n  chroot_local_user=YES \r\n  guest_enable=YES \r\n  guest_username=ftpd \r\n  listen=YES \r\n  listen_port=21 \r\n  pasv_enable=YES \r\n  pasv_min_port=30000 \r\n  pasv_max_port=30999 \r\n  anon_world_readable_only=NO \r\n  virtual_use_local_privs=YES \r\n  #user_config_dir=/etc/vsftpd_user_conf \r\n  可以看出，和前面的用db库来验证没有多大区别，其实就是一个东西，一个用mysql来验证，一个用db库，我个人比较倾向于用db库来验证，在这个环境下，相对于Mysql来说，安全系数更高一点。 \r\n   \r\n  (6)# /usr/local/sbin/vsftpd-pam /etc/vsftpd-pam1.conf &   //以后台方式启动 \r\n   \r\n  (7)测试连通 \r\n  # ftp 127.0.0.1 \r\n  Connected to 127.0.0.1.  \r\n  220 (vsFTPd 2.0.3) \r\n  530 Please login with USER and PASS.  \r\n  530 Please login with USER and PASS.  \r\n  KERBEROS_V4 rejected as an authentication type \r\n  Name (127.0.0.1:root): test1 \r\n  331 Please specify the password.  \r\n  Password: \r\n  230 Login successful.  \r\n  Remote system type is UNIX.  \r\n  Using binary mode to transfer files.  \r\n  ftp>; pwd \r\n  257 \"/\" \r\n  ftp>; quit \r\n  221 Goodbye.\n','//可能你的系统已经存在此帐号，那就不用建立 \r'),(77,'ruby','ruby \r\nwhile\r\n	Ruby while声明：\r\n	语法：\r\n\r\n\r\n	while conditional [do]\r\n	   code\r\n	end\r\n\r\n	执行while的条件是真实的的的的代码。一个while循环的条件是保留字做，换行，反斜杠\\，或分号分隔的代码;\r\n	例如：\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	$i = 0;\r\n	$num = 5;\r\n\r\n	while $i < $num  do\r\n	   puts(\"Inside the loop i = #$i\" );\r\n	   $i +=1;\r\n	end\r\n\r\n	这将输出结果如下：\r\n\r\n	Inside the loop i = 0\r\n	Inside the loop i = 1\r\n	Inside the loop i = 2\r\n	Inside the loop i = 3\r\n	Inside the loop i = 4\r\n\r\nif \r\n\r\n	 Ruby if...else语句：\r\n\r\n	语法：\r\n\r\n	if conditional [then]\r\n		  code...\r\n	[elsif conditional [then]\r\n		  code...]...\r\n	[else\r\n		  code...]\r\n	end\r\n\r\n	如果表达式是用于条件执行。值false和nil是假的，一切是真实的。公告Ruby使用ELSIF，不是别的，如果也不ELIF。\r\n\r\n	如果条件为真执行代码。如果条件是不正确的，执行else子句中指定的代码。\r\n	一个表达的条件是从代码分离的保留字，那么，一个换行符或分号。\r\n\r\n	例如：\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	x=1\r\n	if x > 2\r\n	   puts \"x is greater than 2\"\r\n	elsif x <= 2 and x!=0\r\n	   puts \"x is 1\"\r\n	else\r\n	   puts \"I can\'t guess the number\"\r\n	end\r\n\r\n\r\n\r\narray\r\n\r\n	 Ruby的数组是有序的，任何对象的整数索引的集合。数组中的每个元素与指数。\r\n	数组索引从0开始，如C或Java。负指数假设数组的末尾---是，指数为-1表示最后一个元素，-2是数组中的最后一个元素，等等。\r\n	Ruby的数组能容纳的对象，如字符串，整数，Fixnum对象，哈希，符号，甚至其他的Array对象。 Ruby的数组是没有像在其他语言的阵列刚性。 Ruby的数组自动增长，同时增加他们的元素.\r\n	创建数组:\r\n\r\n	有许多方法来创建或初始化数组。一种方法是用新的类方法:\r\n\r\n	names = Array.new\r\n\r\n	在创建阵列时，您可以设置一个数组的大小:\r\n\r\n	names = Array.new(20)\r\n\r\n	该数组的名称现在有一个的20元素的的的的的大小或的长度。你可以返回一个数组的大小与大小或长度的方法:\r\n\r\n	months.size  # This returns 20\r\n	months.length # This also returns 20\r\n\r\n	您可以指定阵列中的每个元素值如下:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	names = Array.new(4, \"mac\")\r\n\r\n	puts \"#{names}\"\r\n\r\n	This will produce following result:\r\n\r\n	macmacmacmac\r\n\r\n	您还可以使用新块，填充块评估的每个元素:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	nums = Array.new(10) { |e| e = e * 2 }\r\n\r\n	puts \"#{nums}\"\r\n\r\n	这将产生以下结果:\r\n\r\n	024681012141618\r\n\r\n	还有另一个阵列的方法，[]。它是这样工作:\r\n\r\n	nums = Array.[](1, 2, 3, 4,5)\r\n\r\n	创建数组的形式如下 :\r\n\r\n	nums = Array[1, 2, 3, 4,5]\r\n\r\n	内核模块的核心Ruby，有一个阵列的方法，该方法只接受一个参数。这里的方法作为参数的范围，以创建一个数字数组:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	digits = Array(0..9)\r\n\r\n	puts \"#{digits}\"\r\n\r\n	这将产生以下结果:\r\n\r\n	0123456789\r\n\r\n	数组内建方法:\r\n\r\n	我们需要有一个Array对象的实例，调用一个数组的方法。正如我们所看到的，下面是创建一个Array对象的实例:\r\n\r\n	Array.[](...) [or] Array[...] [or] [...]\r\n\r\n	这将返回给定对象的填充一个新的数组。现在我们可以使用创建的对象调用任何可用的实例方法。例如:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	digits = Array(0..9)\r\n\r\n	num = digits.at(6)\r\n\r\n	puts \"#{num}\"\r\n\r\n	这将产生以下结果:\r\n\r\n\r\n	尝试下面的例子来包装各种数据.\r\n\r\n	a = [ \"a\", \"b\", \"c\" ]\r\n	n = [ 65, 66, 67 ]\r\n	a.pack(\"A3A3A3\")   #=> \"a  b  c  \"\r\n	a.pack(\"a3a3a3\")   #=> \"a\\000\\000b\\000\\000c\\000\\000\"\r\n	n.pack(\"ccc\")      #=> \"ABC\"\r\n\r\n\r\nhash\r\n\r\n\r\n\r\n	哈希是这样一个键 - 值对的集合：“雇员”=>“工资”。它是一个数组类似，除了通过任何类型的对象，不是一个整数索引的任意键进行索引。\r\n\r\n	以便在其中任一键或值遍历哈希看似随意，一般不会在插入顺序。如果您尝试访问一个不存在一个关键的哈希值，该方法将返回nil\r\n	创建哈希:\r\n\r\n	阵列，有各种各样的方式来创建哈希。你可以创建一个新的类方法的空哈希:\r\n\r\n	months = Hash.new\r\n\r\n	您还可以使用新创建一个默认值，否则只是nil:\r\n\r\n	months = Hash.new( \"month\" )\r\n	or\r\n	months = Hash.new \"month\"\r\n\r\n	当您访问任何一个哈希键有一个默认值，如果键或值不存在，访问哈希将返回默认值:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	months = Hash.new( \"month\" )\r\n\r\n	puts \"#{months[0]}\"\r\n	puts \"#{months[72]}\"\r\n\r\n	这将产生结果如下:\r\n\r\n	month\r\n	month\r\n\r\n	这里是一个简单的方式创建和访问哈希的键/值:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	H = Hash[\"a\" => 100, \"b\" => 200]\r\n\r\n	puts \"#{H[\'a\']}\"\r\n	puts \"#{H[\'b\']}\"\r\n\r\n	这将产生结果如下:\r\n\r\n	100\r\n	200\r\n\r\n	你可以使用任何一个键或值，甚至数组Ruby对象，所以下面的例子是一个有效的:\r\n\r\n	[1,\"jan\"] => \"January\"\r\n\r\n	哈希内建方法:\r\n\r\n	我们需要有一个Hash对象的实例，调用哈希方法。正如我们已经看到，下面的方式来创建一个Hash对象的实例:\r\n\r\n	Hash[[key =>|, value]* ] or\r\n\r\n	Hash.new [or] Hash.new(obj) [or]\r\n\r\n	Hash.new { |hash, key| block }\r\n\r\n	这将返回给定对象的填充一个新的哈希。现在我们可以使用创建的对象调用任何可用的实例方法。例如:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	$, = \", \"\r\n	months = Hash.new( \"month\" )\r\n\r\n	months = {\"1\" => \"January\", \"2\" => \"February\"}\r\n\r\n	keys = months.keys\r\n\r\n	puts \"#{keys}\"\r\n\r\n\r\n\r\neach & collect\r\n\r\n\r\n\r\n\r\n	迭代器是什么也不是，但集合的方法支持。存储一组数据成员的对象被称为集合。在Ruby中，数组和哈希可以被称为集合.\r\n\r\n	迭代器返回一个集合的所有元素，一前一后。我们将讨论两个迭代器，在这里，每个收集。让我们来看看这些细节.\r\n	Ruby each 迭代:\r\n\r\n	每个迭代器返回一个数组的所有元素或哈希.\r\n	语法:\r\n\r\n	collection.each do |variable|\r\n	   code\r\n	end\r\n\r\n	在集合中的每个元素执行的代码。这里收集可能是一个数组或ruby哈希.\r\n	例子:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	ary = [1,2,3,4,5]\r\n	ary.each do |i|\r\n	   puts i\r\n	end\r\n\r\n	这将产生结果如下:\r\n\r\n	1\r\n	2\r\n	3\r\n	4\r\n	5\r\n\r\n	你总是与块关联的每个迭代。它返回数组的每个值，逐个块。该值存储在变量i，然后在屏幕上显示.\r\n	Ruby collect 迭代:\r\n\r\n	收集的迭代器返回一个集合的所有元素.\r\n	语法:\r\n\r\n	collection = collection.collect\r\n\r\n	收集方法并不总是需要块。收集方法返回整个集合，无论它是一个数组或哈希.\r\n	例如:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	a = [1,2,3,4,5]\r\n	b = Array.new\r\n	b = a.collect\r\n	puts b\r\n\r\n	这将产生以下结果:\r\n\r\n	1\r\n	2\r\n	3\r\n	4\r\n	5\r\n\r\n	注: 收集方法是不正确的方式做阵列之间的复制。还有另一种方法称为克隆，应使用一个数组复制到另一个阵列.\r\n\r\n	您通常使用的收集方法，当你想要做的东西与每个值，以获取新的阵列。例如，这段代码包含在每个值的10倍，产生一个数组b.\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	a = [1,2,3,4,5]\r\n	b = a.collect{|x| 10*x}\r\n	puts b\r\n\r\n	这将产生以下结果:\r\n\r\n	10\r\n	20\r\n	30\r\n	40\r\n	50\r\n\r\n\r\n\r\n\r\n\r\nclass \r\n\r\n	这些功能已被讨论了面向对象的Ruby。\r\n\r\n	一个面向对象的程序，涉及到的类和对象。一类是从个别对象的创建蓝图。在面向对象的条件，我们说，你的自行车是自行车作为已知的对象类的一个实例。\r\n\r\n	采取的任何车辆的例子。它包括车轮，马力，燃油或燃气罐容量。这些特点形成的类车辆的数据成员。帮助这些特点可以区别于其他一辆车。\r\n\r\n	车辆也有一定的功能，如制止，驾驶，加快。即使这些功能形成类车辆的数据成员。因此，您可以定义类的特点和功能相结合。\r\n\r\n	A级车可以被定义为：\r\n\r\n	Class Vehicle\r\n	{\r\n	   Number no_of_wheels\r\n	   Number horsepower\r\n	   Characters type_of_tank\r\n	   Number Capacity\r\n	   Function speeding{\r\n\r\n	   }\r\n	   Function driving{\r\n\r\n	   }\r\n	   Function halting{\r\n\r\n	   }\r\n	} \r\n\r\n	通过这些数据成员分配不同的值，可以形成类车辆的几个实例。例如，飞机上有三个轮子，1000马力，燃油型坦克，和一个100升的容量。以同样的方式，有车有四个轮子，200马力，天然气作为坦克的类型，容量为25升。\r\n\r\n	Ruby中定义 类：\r\n\r\n	通过使用Ruby来实现面向对象编程，你需要先学习如何创建对象和Ruby类。\r\n	在Ruby中的类总是启动关键字类与类的名称。这个名字应该总是在最初的资本。一流的定制可以显示如下：\r\n\r\n	lass Customer\r\n	end \r\n\r\n	 \r\n	Ruby类的变量：\r\n\r\n	Ruby提供了四种类型的变量：\r\n\r\n	    * 局部变量：局部变量是在一个方法中定义的变量。局部变量以外的方法。你会看到更多有关方法在后续章节的细节。局部变量用小写字母或_开始。\r\n	    * 实例变量：实例变量是在任何特定的实例或对象的方法。这意味着，从对象到对象的实例变量改变。实例变量的变量名的符号（@）之前。\r\n	    * 类变量：类变量是在不同的对象。 A类变量属于类是类的一个特点。他们都是由前面的符号@ @变量名。\r\n	    * 全局变量：类变量是不能跨类。如果你想有一个单独的变量，这是可跨类，你需要定义一个全局变量。全局变量总是先用美元符号（$）。\r\n	例如：\r\n	使用类变量@@ no_of_customers，你可确定正在创建的对象的数量。这使中获得的客户数量。\r\n\r\n	class Customer\r\n	   @@no_of_customers=0\r\n	end \r\n\r\n\r\n	在Ruby中创建的对象使用new方法：\r\n\r\n	对象是类的实例。现在，您将学习如何创建一个Ruby类的对象。在Ruby中，你可以通过使用新的类的方法创建对象。\r\n	新的方法是一个独特的方法，这是Ruby库中的预定义类型。新的方法属于类的方法。\r\n	下面是创建两个对象cust1和一流的客户cust2的例子：\r\n\r\n	cust1 = Customer. new\r\n	cust2 = Customer. new \r\n\r\n	在这里，cust1和cust2是两个对象的名字。等于符号（=）后的类的名称将按照你写的对象的名称。然后，点运算和新的关键字将随之而来。\r\n	 \r\n	自定义的方法来创建Ruby对象：\r\n\r\n	您可以通过新方法的参数，这些参数可以被用来初始化类变量。\r\n	当你计划申报与参数的新方法，您需要申报的方法初始化类的创建时间。\r\n	initialize方法是特殊类型的方法，将类的新方法与参数调用时执行。\r\n	下面是创建初始化方法的例子：\r\n\r\n	class Customer\r\n	   @@no_of_customers=0\r\n	   def initialize(id, name, addr)\r\n	      @cust_id=id\r\n	      @cust_name=name\r\n	      @cust_addr=addr\r\n	   end\r\n	end \r\n\r\n	在这个例子中，你声明为局部变量initialize方法的ID，name，addr。这里def和结束被用来定义一个Ruby方法Initialize。您将了解在以后的章节中的方法。\r\n\r\n	在initialize方法，通过对这些局部变量的值的实例变量@ CUST_ID，CUST_NAME，@ cust_addr。这里的局部变量持有值，通过用新的方法。\r\n\r\n	现在你可以创建对象如下：\r\n\r\n	cust1=Customer.new(\"1\", \"John\", \"Wisdom Apartments, Ludhiya\")\r\n	cust2=Customer.new(\"2\", \"Poul\", \"New Empire road, Khandala\")\r\n\r\n	Ruby类的成员函数：\r\n\r\n	在Ruby中，函数调用的方法。每一类中的方法，方法名称关键字def开始。\r\n	总是首选的方法名称以小写字母。你在Ruby中的方法使用关键字年底结束。\r\n	下面是定义一个Ruby方法的例子：\r\n\r\n	class Sample\r\n	   def function\r\n	      statement 1\r\n	      statement 2\r\n	   end\r\n	end \r\n\r\n	这里语句1和语句2类内样本的方法函数体的一部分。这些statments可以是任何有效的Ruby语句。例如，我们可以提出一个方法使打印您好红宝石如下：\r\n\r\n	class Sample\r\n	   def hello\r\n	      puts \"Hello Ruby!\"\r\n	   end\r\n	end \r\n\r\n	现在在下面的例子创建Sample类的一个对象，并调用hello方法和看到的结果：\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	class Sample\r\n	   def hello\r\n	      puts \"Hello Ruby!\"\r\n	   end\r\n	end\r\n\r\n	# Now using above class to create objects\r\n	object = Sample. new\r\n	object.hello \r\n\r\n	以上代码将输出结果如下：\r\n\r\n	Hello Ruby!\r\n	\r\nIO\r\n\r\n	 Ruby提供了一整套的I / O相关的内核模块中实现的方法。所有的I / O方法都来源于类IO。\r\n	IO类提供所有的基本方法，如读，写，获取，readline时，getc和printf.\r\n\r\n	本章将覆盖所有ithe基本I/O功能，在Ruby中，更多的功能，请引用一个Ruby的IO类.\r\n	puts 语句:\r\n\r\n	在前面的章节中，您指定的值到变量，然后打印输出使用了puts语句.\r\n\r\n	puts语句指示的程序来显示存储在变量中的值。这将添加一个新行，在每行写入结束.\r\n	例子:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	val1 = \"This is variable one\"\r\n	val2 = \"This is variable two\"\r\n	puts val1\r\n	puts val2\r\n\r\n	这将产生以下结果:\r\n\r\n	This is variable one\r\n	This is variable two\r\n\r\n	gets 语句:\r\n\r\n	gets语句可用于任何输入，从用户称为stdin标准屏幕.\r\n	例子:\r\n\r\n	下面的代码显示了如何使用获得的声明。此代码将提示用户输入一个值，将存储在变量val，终于将stdout（标准输出）上打印.\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	puts \"Enter a value :\"\r\n	val = gets\r\n	puts val\r\n\r\n	这将产生以下结果:\r\n\r\n	Enter a value :\r\n	This is entered value\r\n	This is entered value\r\n\r\n	putc 语句:\r\n\r\n	不同于puts语句，输出到屏幕上的整个字符串，的putc可以用来输出一个字符.\r\n	例子:\r\n\r\n	下面的代码的输出仅仅是字符H:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	str=\"Hello Ruby!\"\r\n	putc str\r\n\r\n	这将产生以下结果:\r\n\r\n	H\r\n\r\n	print 语句:\r\n\r\n	print语句是类似puts语句。唯一不同的是，puts到下一行，而与print光标定位在同一行上打印的内容后.\r\n	例子:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	print \"Hello World\"\r\n	print \"Good Morning\"\r\n\r\n	这将产生以下结果:\r\n\r\n	Hello WorldGood Morning\r\n\r\n	打开和关闭文件:\r\n\r\n	到现在为止，您已经阅读和写作的标准输入和输出。现在，我们将看到如何发挥与实际的数据文件.\r\n	File.new 方法:\r\n\r\n	你可以创建一个文件对象，读，写，或同时使用File.new方法，根据模式字符串。最后可以使用File.close的方法来关闭该文件.\r\n	语法:\r\n\r\n	aFile = File.new(\"filename\", \"mode\")\r\n	   # ... process the file\r\n	aFile.close\r\n\r\n	File.open 方法:\r\n\r\n	你可以使用File.Open方法创建一个新的文件对象，并分配到一个文件，文件对象。然而，有一个的File.Open和File.new方法之间的差异。所不同的是File.Open方法可以用块，而你不能这样做的同时使用File.new方法.\r\n\r\n	File.open(\"filename\", \"mode\") do |aFile|\r\n	   # ... process the file\r\n	end\r\n\r\n	这里是一个不同的模式打开一个文件列表:\r\n	模式 	描述\r\n	r 	只读模式. 文件指针放置在文件的开头,这是默认模式.\r\n	r+ 	读写模式。文件指针将会在文件的开头.\r\n	w 	只写模式。如果该文件存在，覆盖该文件。如果该文件不存在，创建一个新的书面文件.\r\n	w+ 	读写模式。如果该文件存在，将覆盖现有的文件。如果该文件不存在，创建一个新的文件读和写.\r\n	a 	只写模式。文件指针是在结束的文件，如果该文件存在。也就是说，该文件是在追加模式。如果该文件不存在，它创建了一个新的书面文件.\r\n	a+ 	读写模式。文件指针是在结束的文件，如果该文件存在。在追加模式打开该文件。如果该文件不存在，它会创建一个新的文件阅读和写作.\r\n	读和写文件:\r\n\r\n	同样的方法，我们一直在使用“简单”的I / O可用于所有文件对象。因此，获取从标准输入中读取行，aFile.gets读取的文件对象aFile行.\r\n\r\n	然而，I/O对象的访问方法提供了另外一组，以使我们的更轻松.\r\n	sysread 方法:\r\n\r\n	你可以使用该方法sysread读文件的内容。你可以在任何模式中打开文件时使用的方法sysread。例如 :\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	aFile = File.new(\"/var/www/yiibai.com/ruby/test\", \"r\")\r\n	if aFile\r\n	   content = aFile.sysread(20)\r\n	   puts content\r\n	else\r\n	   puts \"Unable to open file!\"\r\n	end\r\n\r\n	这条语句将输出文件的前20个字符。文件指针将被放置在文件中的第21字符.\r\n	syswrite 方法:\r\n\r\n	你可以使用方法syswrite，写入到一个文件的内容。你需要在写入模式打开文件使用方法syswrite时。例如 :\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	aFile = File.new(\"/var/www/yiibai.com/ruby/test\", \"r+\")\r\n	if aFile\r\n	   aFile.syswrite(\"ABCDEF\")\r\n	else\r\n	   puts \"Unable to open file!\"\r\n	end\r\n\r\n	本声明将写入文件“ABCDEF的”.\r\n	each_byte 方法:\r\n\r\n	这种方法属于类文件。方法each_byte总是与一个块。请看下面的代码示例：:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	aFile = File.new(\"/var/www/yiibai.com/ruby/test\", \"r\")\r\n	if aFile\r\n	   aFile.syswrite(\"ABCDEF\")\r\n	   aFile.each_byte {|ch| putc ch; putc ?. }\r\n	else\r\n	   puts \"Unable to open file!\"\r\n	end\r\n\r\n	字符通过一个个变量ch，然后如下的屏幕上显示:\r\n\r\n	T.h.i.s. .i.s. .l.i.n.e. .o.n.e.\r\n	.T.h.i.s. .i.s. .l.i.n.e. .t.w.o.\r\n	.T.h.i.s. .i.s. .l.i.n.e. .t.h.r.e.e.\r\n	.A.n.d. .s.o. .o.n.......\r\n\r\n	IO.readlines 方法:\r\n\r\n	类文件的类IO的一个子类。类IO也有一些方法可用于对文件进行操作.\r\n\r\n	IO类的方法之一是IO.readlines。此方法返回行的文件的内容，下面的代码显示使用方法IO.readlines:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	arr = IO.readlines(\"/var/www/yiibai.com/ruby/test\")\r\n	puts arr[0]\r\n	puts arr[1]\r\n\r\n	在这段代码中，变量arr是一个数组。文件测试的每一行，将是一个数组arr的元素。因此，arr[0]将包含首行，而arr[1]将包含文件的第二行.\r\n	IO.foreach 方法:\r\n\r\n	这种方法也返回逐行输出。该方法之间的差异foreachand readlines方法的方法是该方法的foreach块。然而，不同的方法readlines方法，该方法的foreach不返回一个数组。例如:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	IO.foreach(\"test\"){|block| puts block}\r\n\r\n	此代码将通过的文件测试线，由线到可变块的内容，然后输出将显示在屏幕上.\r\n	重命名和删除文件:\r\n\r\n	你可以重命名和删除文件与红宝石，重命名和删除方法编程。\r\n	以下是示例重命名现有的文件test1.txt:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	# Rename a file from test1.txt to test2.txt\r\n	File.rename( \"test1.txt\", \"test2.txt\" )\r\n\r\n	以下是示例删除一个现有的文件test2.txt的:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	# Delete file test2.txt\r\n	File.delete(\"text2.txt\")\r\n\r\n	文件模式和所有权:\r\n\r\n	使用掩码的的CHMOD方法改变的模式或文件的权限/访问列表：\r\n	以下是示例模式，以改变现有的文件test.txt一个掩码值:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	file = File.new( \"test.txt\", \"w\" )\r\n	file.chmod( 0755 )\r\n\r\n	以下为表中，它可以帮助您选择不同的面具chmod的方法:\r\n	Mask 	Description\r\n	0700 	rwx mask for owner\r\n	0400 	r for owner\r\n	0200 	w for owner\r\n	0100 	x for owner\r\n	0070 	rwx mask for group\r\n	0040 	r for group\r\n	0020 	w for group\r\n	0010 	x for group\r\n	0007 	rwx mask for other\r\n	0004 	r for other\r\n	0002 	w for other\r\n	0001 	x for other\r\n	4000 	Set user ID on execution\r\n	2000 	Set group ID on execution\r\n	1000 	Save swapped text, even after use\r\n	文件查询:\r\n\r\n	下面的命令测试文件是否存在打开它之前:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	File.open(\"file.rb\") if File::exists?( \"file.rb\" )\r\n\r\n	下面的命令查询文件是否是一个真正的文件:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	# This returns either true or false File.file?( \"text.txt\" ) \r\n\r\n	下面的命令找出，是否给定的文件名是一个目录:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	# a directory\r\n	File::directory?( \"/usr/local/bin\" ) # => true\r\n\r\n	# a file\r\n	File::directory?( \"file.rb\" ) # => false\r\n\r\n	下面的命令找出，是否给定的文件可读, 可写或可执行:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	File.readable?( \"test.txt\" )   # => true\r\n	File.writable?( \"test.txt\" )   # => true\r\n	File.executable?( \"test.txt\" ) # => false\r\n\r\n	下面的命令查找该文件是否有大小为零或非:\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	File.zero?( \"test.txt\" )      # => true\r\n\r\n	以下的命令查找返回文件的大小 :\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	File.size?( \"text.txt\" )     # => 1002\r\n\r\n	下面的命令可以用来找出一个文件类型 :\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	File::ftype( \"test.txt\" )     # => file\r\n\r\n	ftype方法识别的文件类型返回下列之一：文件，目录，characterSpecial，blockSpecial，fifo，link，socket，或未知.\r\n\r\n	下面的命令可以用来发现，当一个文件被创建，修改或上次访问 :\r\n\r\n	#!/usr/bin/ruby\r\n\r\n	File::ctime( \"test.txt\" ) # => Fri May 09 10:06:37 -0700 2008\r\n	File::mtime( \"text.txt\" ) # => Fri May 09 10:44:44 -0700 2008\r\n	File::atime( \"text.txt\" ) # => Fri May 09 10:45:01 -0700 2008\r\n\r\n	Ruby 中的目录:\r\n\r\n	所有文件都包含在不同的目录，Ruby没有处理这些问题。而File类处理文件，目录与Dirclass处理.\r\n	通过目录浏览:\r\n\r\n	要改变在一个Ruby程序的目录，使用如下Dir.chdir。这个例子改变当前目录到/usr/bin中.\r\n\r\n	Dir.chdir(\"/usr/bin\")\r\n\r\n	你可以用Dir.pwd找出哪些当前目录:\r\n\r\n	puts Dir.pwd # This will return something like /usr/bin\r\n\r\n	你可以得到特定使用Dir.entries目录内的文件和目录列表:\r\n\r\n	puts Dir.entries(\"/usr/bin\").join(\' \')\r\n\r\n	dir.entries返回一个数组指定的目录内的所有条目。 Dir.foreachprovides的相同的功能:\r\n\r\n	Dir.foreach(\"/usr/bin\") do |entry|\r\n	   puts entry\r\n	end\r\n\r\n	一个更简洁的方式是使用目录类数组的方法得到目录列表:\r\n\r\n	Dir[\"/usr/bin/*\"]\r\n\r\n	创建一个目录:\r\n\r\n	Dir.mkdir可以用来创建目录:\r\n\r\n	Dir.mkdir(\"mynewdir\")\r\n\r\n	您还可以用mkdir设置一个新的目录（不是一个已经存在的权限）:\r\n\r\n	注: 面具755设置权限，所有者，组，word[anyone] rwxr-XR-X，r=读，w=写，x=执行.\r\n\r\n	Dir.mkdir( \"mynewdir\", 755 )\r\n\r\n	删除目录:\r\n\r\n	Dir.delete可以用来删除一个目录。 Dir.unlink和Dir.rmdir执行完全相同的功能，并提供了方便.\r\n\r\n	Dir.delete(\"testdir\")\r\n\r\n	创建文件和临时目录:\r\n\r\n	临时文件，可能会创建程序的执行过程中短暂的，但不是永久存储的信息。\r\n	dir.tmpdir提供对当前系统的临时目录的路径，虽然方法不是默认可用的。到使Dir.tmpdir可用它有必要使用规定“tmpdir”.\r\n\r\n	可以使用与File.join Dir.tmpdir，创建一个平台独立的临时文件:\r\n\r\n	require \'tmpdir\'\r\n	   tempfilename = File.join(Dir.tmpdir, \"tingtong\")\r\n	   tempfile = File.new(tempfilename, \"w\")\r\n	   tempfile.puts \"This is a temporary file\"\r\n	   tempfile.close\r\n	   File.delete(tempfilename)\r\n\r\n	此代码创建一个临时文件，写入数据，并删除它。 Ruby的标准库还包括称为Tempfile必须是一个库，可以为您创建的临时文件:\r\n\r\n	require \'tempfile\'\r\n	   f = Tempfile.new(\'tingtong\')\r\n	   f.puts \"Hello\"\r\n	   puts f.path\r\n	   f.close\r\n','');
/*!40000 ALTER TABLE `cmdhelp` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2015-05-16 11:18:12
